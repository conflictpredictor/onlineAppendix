=========================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_223c3_48e24\rev_223c3-48e24.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_ca347_22323\rev_ca347-22323.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_a2337_a406a\rev_a2337-a406a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_99e0d_a3130\rev_99e0d-a3130.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
@AfterMethod(groups = "short")
    public void cleanup() {
        ListenableFuture<List<ResultSet>> f = Futures.successfulAsList(Lists.newArrayList(
            session.executeAsync("DROP TABLE lowercase.table1"),
            session.executeAsync("DROP TABLE \"CaseSensitive\".table1"),
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611689680\fstmerge_var1_1966604378341295615
            session.executeAsync("DROP TYPE ks.type1"),
            session.executeAsync("DROP TYPE \"CaseSensitive\".type1"),
            session.executeAsync("DROP KEYSPACE ks2"),
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611689680\fstmerge_base_7919012040589728705
            session.executeAsync("DROP KEYSPACE ks2"),
=======
            session.executeAsync("DROP KEYSPACE lowercase2"),
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611689680\fstmerge_var2_4533776194122340682
            session.executeAsync("DROP KEYSPACE \"CaseSensitive2\"")
        ));
        Futures.getUnchecked(f);
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_99e0d_a3130\rev_rev_left_99e0d-rev_right_a3130\driver-core\src\test\java\com\datastax\driver\core\SchemaChangesTest.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611692670\fstmerge_var1_5818860488620267732
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611692670\fstmerge_base_4691391332646464667
@Test(groups = "long")
    public void sessionMemoryLeakTest() throws Exception {
        // Checking for JAVA-342

        // give the driver time to close other sessions in this class
        Thread.sleep(10);

        // create a new cluster object and ensure 0 sessions and connections
        int corePoolSize = 2;
        PoolingOptions poolingOptions = new PoolingOptions()
                .setCoreConnectionsPerHost(HostDistance.LOCAL, corePoolSize);
        Cluster cluster = Cluster.builder()
                .addContactPoints(CCMBridge.IP_PREFIX + '1')
                .withPoolingOptions(poolingOptions)
                .build();

        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 0);

        Session session = cluster.connect();
        assertEquals(cluster.manager.sessions.size(), 1);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);

        // ensure sessions.size() returns to 0 with only 1 active connection
        session.close();
        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

        // give the driver time to close sessions
        Thread.sleep(10);

        try {
            for (int i = 0; i < 10000; ++i) {
                // ensure 0 sessions with a single control connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

                // ensure a new session gets registered and control connections are established
                session = cluster.connect();
                assertEquals(cluster.manager.sessions.size(), 1);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);
                session.close();

                // give the driver time to close sessions
                Thread.sleep(10);

                // ensure sessions.size() always returns to 0 with only 1 active connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            }
        } finally {
            cluster.close();
        }
    }
=======
@Test(groups = "long")
    public void sessionMemoryLeakTest() throws Exception {
        // Checking for JAVA-342

        // give the driver time to close other sessions in this class
        Thread.sleep(10);

        // create a new cluster object and ensure 0 sessions and connections
        int corePoolSize = 2;
        PoolingOptions poolingOptions = new PoolingOptions()
                .setCoreConnectionsPerHost(HostDistance.LOCAL, corePoolSize);
        Cluster cluster = Cluster.builder()
                .addContactPointsWithPorts(Collections.singletonList(hostAddress))
                .withPoolingOptions(poolingOptions)
                .build();

        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 0);

        Session session = cluster.connect();
        assertEquals(cluster.manager.sessions.size(), 1);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);

        // ensure sessions.size() returns to 0 with only 1 active connection
        session.close();
        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

        // give the driver time to close sessions
        Thread.sleep(10);

        try {
            for (int i = 0; i < 10000; ++i) {
                // ensure 0 sessions with a single control connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

                // ensure a new session gets registered and control connections are established
                session = cluster.connect();
                assertEquals(cluster.manager.sessions.size(), 1);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);
                session.close();

                // give the driver time to close sessions
                Thread.sleep(10);

                // ensure sessions.size() always returns to 0 with only 1 active connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            }
        } finally {
            cluster.close();
        }
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611692670\fstmerge_var2_6402679508768905554

File path: C:\download\ssmerge\java-driver\revisions\rev_99e0d_a3130\rev_rev_left_99e0d-rev_right_a3130\driver-core\src\test\java\com\datastax\driver\core\SessionTest.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611693231\fstmerge_var1_4270719002460733740
@Test(groups = "short")
    public void connectionLeakTest() throws Exception {
        // Checking for JAVA-342

        // give the driver time to close other sessions in this class
        Thread.sleep(10);

        // create a new cluster object and ensure 0 sessions and connections
        Cluster cluster = Cluster.builder().addContactPoints(CCMBridge.IP_PREFIX + '1').build();

        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 0);

        // ensure sessions.size() returns with 1 control connection + core pool size.
        Session session = cluster.connect();
        assertEquals(cluster.manager.sessions.size(), 1);
        int coreConnections = TestUtils.numberOfLocalCoreConnections(cluster);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(),
                     1 + coreConnections);

        // ensure sessions.size() returns to 0 with only 1 active connection (the control connection)
        session.close();
        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

        try {
            Session thisSession;

            // ensure bootstrapping a node does not create additional connections
            cassandraCluster.bootstrapNode(2);
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

            // ensure a new session gets registered and core connections are established
            // there should be corePoolSize more connections to accommodate for the new host.
            thisSession = cluster.connect();
            assertEquals(cluster.manager.sessions.size(), 1);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(),
                         1 + coreConnections * 2);

            // ensure bootstrapping a node does not create additional connections that won't get cleaned up
            thisSession.close();
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

        } finally {
            // ensure we decommission node2 for the rest of the tests
            cassandraCluster.decommissionNode(2);

            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

            cluster.close();
        }
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611693231\fstmerge_base_1679297273169610687
@Test(groups = "short")
    public void connectionLeakTest() throws Exception {
        // Checking for JAVA-342

        // give the driver time to close other sessions in this class
        Thread.sleep(10);

        // create a new cluster object and ensure 0 sessions and connections
        Cluster cluster = Cluster.builder().addContactPoints(CCMBridge.IP_PREFIX + '1').build();

        int corePoolSize = cluster.getConfiguration()
                .getPoolingOptions()
                .getCoreConnectionsPerHost(HostDistance.LOCAL);

        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 0);

        // ensure sessions.size() returns with 1 control connection + core pool size.
        Session session = cluster.connect();
        assertEquals(cluster.manager.sessions.size(), 1);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);

        // ensure sessions.size() returns to 0 with only 1 active connection (the control connection)
        session.close();
        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

        try {
            Session thisSession;

            // ensure bootstrapping a node does not create additional connections
            cassandraCluster.bootstrapNode(2);
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

            // ensure a new session gets registered and core connections are established
            // there should be corePoolSize more connections to accommodate for the new host.
            thisSession = cluster.connect();
            assertEquals(cluster.manager.sessions.size(), 1);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + (corePoolSize * 2));

            // ensure bootstrapping a node does not create additional connections that won't get cleaned up
            thisSession.close();
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

        } finally {
            // ensure we decommission node2 for the rest of the tests
            cassandraCluster.decommissionNode(2);

            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

            cluster.close();
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611693231\fstmerge_var2_3754988594127715898

File path: C:\download\ssmerge\java-driver\revisions\rev_99e0d_a3130\rev_rev_left_99e0d-rev_right_a3130\driver-core\src\test\java\com\datastax\driver\core\SessionTest.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_a3130_e8b83\rev_a3130-e8b83.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_5a1bb-103c8.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611791891\fstmerge_var1_8234456461711389913
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611791891\fstmerge_base_1800433538119007053
private ArrayBackedRow(ColumnDefinitions metadata, Token.Factory tokenFactory, List<ByteBuffer> data) {
        this.metadata = metadata;
        this.tokenFactory = tokenFactory;
        this.data = data;
    }
=======
private ArrayBackedRow(ColumnDefinitions metadata, Token.Factory tokenFactory, List<ByteBuffer> data) {
        super(metadata);
        this.tokenFactory = tokenFactory;
        this.data = data;
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611791891\fstmerge_var2_2921670082035583850

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\ArrayBackedRow.java
Conflict type: ImplementList
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611795659\fstmerge_var1_4328417339722472452
implements SettableData<BoundStatement>, GettableData
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611795659\fstmerge_base_7567095777040111584
=======
implements GettableData
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611795659\fstmerge_var2_6997807895158695686

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: AddSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611795737\fstmerge_var1_7547748525707703436
final DataWrapper wrapper;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611795737\fstmerge_base_9090898537182087256
=======
private DataWrapper wrapper;
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611795737\fstmerge_var2_3412078446191777027

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812517\fstmerge_var1_510969180081005079
public boolean isNull(int i) {
        return wrapper.isNull(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812517\fstmerge_base_3025166022049594051
=======
@Override
    public boolean isNull(int i) {
        return wrapper.isNull(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812517\fstmerge_var2_5253287597527039984

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812611\fstmerge_var1_2459313559515363780
public boolean isNull(String name) {
        return wrapper.isNull(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812611\fstmerge_base_4835157033499354753
=======
@Override
    public boolean isNull(String name) {
        return wrapper.isNull(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812611\fstmerge_var2_8298507669291954796

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812696\fstmerge_var1_3840401493439497045
public boolean getBool(int i) {
        return wrapper.getBool(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812696\fstmerge_base_6351669662818751791
=======
@Override
    public boolean getBool(int i) {
        return wrapper.getBool(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812696\fstmerge_var2_177397517392865026

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812769\fstmerge_var1_2108172223776424798
public boolean getBool(String name) {
        return wrapper.getBool(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812769\fstmerge_base_3596192089335413200
=======
@Override
    public boolean getBool(String name) {
        return wrapper.getBool(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812769\fstmerge_var2_5500860627928989023

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812863\fstmerge_var1_3417457149910204197
public int getInt(int i) {
        return wrapper.getInt(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812863\fstmerge_base_8204302330042558660
=======
@Override
    public int getInt(int i) {
        return wrapper.getInt(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812863\fstmerge_var2_3654635265564287131

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812941\fstmerge_var1_1280007186567032008
public int getInt(String name) {
        return wrapper.getInt(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812941\fstmerge_base_2927610208736674647
=======
@Override
    public int getInt(String name) {
        return wrapper.getInt(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611812941\fstmerge_var2_6696787153653865576

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813019\fstmerge_var1_4529537690297444466
public long getLong(int i) {
        return wrapper.getLong(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813019\fstmerge_base_3910884298377086130
=======
@Override
    public long getLong(int i) {
        return wrapper.getLong(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813019\fstmerge_var2_6257056144348865114

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813097\fstmerge_var1_2879808309890202642
public long getLong(String name) {
        return wrapper.getLong(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813097\fstmerge_base_6606093843441483915
=======
@Override
    public long getLong(String name) {
        return wrapper.getLong(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813097\fstmerge_var2_8408994205449243164

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813160\fstmerge_var1_6995559783282408847
public Date getDate(int i) {
        return wrapper.getDate(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813160\fstmerge_base_7036778649137528900
=======
@Override
    public Date getDate(int i) {
        return wrapper.getDate(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813160\fstmerge_var2_961902202925295747

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813238\fstmerge_var1_6479215157510955137
public Date getDate(String name) {
        return wrapper.getDate(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813238\fstmerge_base_7407332838864609992
=======
@Override
    public Date getDate(String name) {
        return wrapper.getDate(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813238\fstmerge_var2_3917255234965132468

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813323\fstmerge_var1_4670522785972680271
public float getFloat(int i) {
        return wrapper.getFloat(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813323\fstmerge_base_7458184981556375296
=======
@Override
    public float getFloat(int i) {
        return wrapper.getFloat(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813323\fstmerge_var2_7090095177130572198

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813432\fstmerge_var1_1319175151328354615
public float getFloat(String name) {
        return wrapper.getFloat(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813432\fstmerge_base_9065300930799262279
=======
@Override
    public float getFloat(String name) {
        return wrapper.getFloat(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813432\fstmerge_var2_2045247002632495617

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813502\fstmerge_var1_5596440599522328791
public double getDouble(int i) {
        return wrapper.getDouble(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813502\fstmerge_base_1633082646605044028
=======
@Override
    public double getDouble(int i) {
        return wrapper.getDouble(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813502\fstmerge_var2_6281587124977804361

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813580\fstmerge_var1_5329110088907418548
public double getDouble(String name) {
        return wrapper.getDouble(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813580\fstmerge_base_5484379994656082130
=======
@Override
    public double getDouble(String name) {
        return wrapper.getDouble(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813580\fstmerge_var2_222028765170235807

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813659\fstmerge_var1_500137865436564460
public ByteBuffer getBytesUnsafe(int i) {
        return wrapper.getBytesUnsafe(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813659\fstmerge_base_2294620572320630696
=======
@Override
    public ByteBuffer getBytesUnsafe(int i) {
        return wrapper.getBytesUnsafe(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813659\fstmerge_var2_5529813231249548593

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813737\fstmerge_var1_5874702489439432218
public ByteBuffer getBytesUnsafe(String name) {
        return wrapper.getBytesUnsafe(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813737\fstmerge_base_9080255724359153299
=======
@Override
    public ByteBuffer getBytesUnsafe(String name) {
        return wrapper.getBytesUnsafe(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813737\fstmerge_var2_167761753732621102

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813816\fstmerge_var1_3041927191005932592
public ByteBuffer getBytes(int i) {
        return wrapper.getBytes(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813816\fstmerge_base_7600387608342194104
=======
@Override
    public ByteBuffer getBytes(int i) {
        return wrapper.getBytes(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813816\fstmerge_var2_3910760243423513379

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813906\fstmerge_var1_1014468923163371686
public ByteBuffer getBytes(String name) {
        return wrapper.getBytes(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813906\fstmerge_base_6978977673025407203
=======
@Override
    public ByteBuffer getBytes(String name) {
        return wrapper.getBytes(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813906\fstmerge_var2_4779380228700655545

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813985\fstmerge_var1_4447450163204788196
public String getString(int i) {
        return wrapper.getString(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813985\fstmerge_base_2671030470506639216
=======
@Override
    public String getString(int i) {
        return wrapper.getString(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611813985\fstmerge_var2_4184460119210380110

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814047\fstmerge_var1_6698275939497088198
public String getString(String name) {
        return wrapper.getString(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814047\fstmerge_base_607202203237039663
=======
@Override
    public String getString(String name) {
        return wrapper.getString(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814047\fstmerge_var2_5794869572139410485

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814125\fstmerge_var1_7650293244507733272
public BigInteger getVarint(int i) {
        return wrapper.getVarint(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814125\fstmerge_base_7231762179453799906
=======
@Override
    public BigInteger getVarint(int i) {
        return wrapper.getVarint(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814125\fstmerge_var2_7591397292874690026

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814207\fstmerge_var1_7029823277101058515
public BigInteger getVarint(String name) {
        return wrapper.getVarint(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814207\fstmerge_base_9022292941165571626
=======
@Override
    public BigInteger getVarint(String name) {
        return wrapper.getVarint(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814207\fstmerge_var2_8320844445485750789

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814285\fstmerge_var1_5525251679305045525
public BigDecimal getDecimal(int i) {
        return wrapper.getDecimal(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814285\fstmerge_base_4631478010053520754
=======
@Override
    public BigDecimal getDecimal(int i) {
        return wrapper.getDecimal(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814285\fstmerge_var2_8565598197069084765

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814379\fstmerge_var1_5194498379666081620
public BigDecimal getDecimal(String name) {
        return wrapper.getDecimal(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814379\fstmerge_base_7768134101275099861
=======
@Override
    public BigDecimal getDecimal(String name) {
        return wrapper.getDecimal(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814379\fstmerge_var2_477829402954447458

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814460\fstmerge_var1_7917197664854951091
public UUID getUUID(int i) {
        return wrapper.getUUID(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814460\fstmerge_base_1339980725423133317
=======
@Override
    public UUID getUUID(int i) {
        return wrapper.getUUID(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814460\fstmerge_var2_2303027882821954299

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814522\fstmerge_var1_3934460532989495983
public UUID getUUID(String name) {
        return wrapper.getUUID(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814522\fstmerge_base_1081166132010033801
=======
@Override
    public UUID getUUID(String name) {
        return wrapper.getUUID(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814522\fstmerge_var2_1952405930330120021

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814600\fstmerge_var1_8084217418781233766
public InetAddress getInet(int i) {
        return wrapper.getInet(i);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814600\fstmerge_base_3044826245197433994
=======
@Override
    public InetAddress getInet(int i) {
        return wrapper.getInet(i);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814600\fstmerge_var2_1741505790306027098

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814679\fstmerge_var1_640092409967213968
public InetAddress getInet(String name) {
        return wrapper.getInet(name);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814679\fstmerge_base_9144927261675387346
=======
@Override
    public InetAddress getInet(String name) {
        return wrapper.getInet(name);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814679\fstmerge_var2_8629228434970951287

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814757\fstmerge_var1_2371469027793661727
public <T> List<T> getList(int i, Class<T> elementsClass) {
        return wrapper.getList(i, elementsClass);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814757\fstmerge_base_8814350610367348081
=======
@Override
    public <T> List<T> getList(int i, Class<T> elementsClass) {
        return wrapper.getList(i, elementsClass);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814757\fstmerge_var2_1454949006145900334

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814835\fstmerge_var1_5652236699699085134
public <T> List<T> getList(String name, Class<T> elementsClass) {
        return wrapper.getList(name, elementsClass);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814835\fstmerge_base_6639192817245603346
=======
@Override
    public <T> List<T> getList(String name, Class<T> elementsClass) {
        return wrapper.getList(name, elementsClass);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814835\fstmerge_var2_5048314133111307740

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814913\fstmerge_var1_8519824828295005631
public <T> Set<T> getSet(int i, Class<T> elementsClass) {
        return wrapper.getSet(i, elementsClass);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814913\fstmerge_base_3814416929333512547
=======
@Override
    public <T> Set<T> getSet(int i, Class<T> elementsClass) {
        return wrapper.getSet(i, elementsClass);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814913\fstmerge_var2_7476985960279868431

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814991\fstmerge_var1_1464262502157708628
public <T> Set<T> getSet(String name, Class<T> elementsClass) {
        return wrapper.getSet(name, elementsClass);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814991\fstmerge_base_7803396149525629331
=======
@Override
    public <T> Set<T> getSet(String name, Class<T> elementsClass) {
        return wrapper.getSet(name, elementsClass);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611814991\fstmerge_var2_6913693012667354182

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815069\fstmerge_var1_970346740269015444
public <K, V> Map<K, V> getMap(int i, Class<K> keysClass, Class<V> valuesClass) {
        return wrapper.getMap(i, keysClass, valuesClass);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815069\fstmerge_base_6411082245402604696
=======
@Override
    public <K, V> Map<K, V> getMap(int i, Class<K> keysClass, Class<V> valuesClass) {
        return wrapper.getMap(i, keysClass, valuesClass);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815069\fstmerge_var2_1139455392843463630

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815138\fstmerge_var1_170911181995518532
public <K, V> Map<K, V> getMap(String name, Class<K> keysClass, Class<V> valuesClass) {
        return wrapper.getMap(name, keysClass, valuesClass);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815138\fstmerge_base_8083588809977428812
=======
@Override
    public <K, V> Map<K, V> getMap(String name, Class<K> keysClass, Class<V> valuesClass) {
        return wrapper.getMap(name, keysClass, valuesClass);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815138\fstmerge_var2_6744689995855863571

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: ExtendsList
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815216\fstmerge_var1_3397932665168066118
extends AbstractData<BoundStatement>
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815216\fstmerge_base_4230779279925059572
=======
extends AbstractGettableData
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611815216\fstmerge_var2_2801740994721370036

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\BoundStatement.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611832758\fstmerge_var1_7189121589700298389
public String format(Object value) {
        // We don't care about the protocol version for formatting
        return value == null ? null : codec(ProtocolVersion.NEWEST_SUPPORTED).format(value);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611832758\fstmerge_base_3358121960842253055
=======
public String format(Object value) {
        return value == null ? null : codec().format(value);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611832758\fstmerge_var2_3799777276845112037

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\main\java\com\datastax\driver\core\DataType.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
@Test(groups = "unit")
    public void serializeDeserializeTest() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611895586\fstmerge_var1_5021420062667594100
        for (ProtocolVersion v : ProtocolVersion.values())
            serializeDeserializeTest(v);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611895586\fstmerge_base_1087806010366534695

        for (DataType dt : DataType.allPrimitiveTypes())
        {
            if (exclude(dt))
                continue;

            Object value = TestUtils.getFixedValue(dt);
            assertEquals(dt.deserialize(dt.serialize(value)), value);
        }

        try {
            DataType.bigint().serialize(4);
            fail("This should not have worked");
        } catch (InvalidTypeException e) { /* That's what we want */ }

        try {
            ByteBuffer badValue = ByteBuffer.allocate(4);
            DataType.bigint().deserialize(badValue);
            fail("This should not have worked");
        } catch (InvalidTypeException e) { /* That's what we want */ }
=======

        for (DataType dt : DataType.allPrimitiveTypes()) {
            if (dt.getName() == DataType.Name.COUNTER)
                continue;

            Object value = TestUtils.getFixedValue(dt);
            assertEquals(dt.deserialize(dt.serialize(value)), value);
        }

        try {
            DataType.bigint().serialize(4);
            fail("This should not have worked");
        } catch (InvalidTypeException e) { /* That's what we want */ }

        try {
            ByteBuffer badValue = ByteBuffer.allocate(4);
            DataType.bigint().deserialize(badValue);
            fail("This should not have worked");
        } catch (InvalidTypeException e) { /* That's what we want */ }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611895586\fstmerge_var2_8968983599457167958
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\test\java\com\datastax\driver\core\DataTypeTest.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611896102\fstmerge_var1_2342920351364788662
static boolean exclude(DataType t) {
        return t.getName() == DataType.Name.COUNTER;
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611896102\fstmerge_base_6505210742064954113
private static boolean exclude(DataType t) {
        return t.getName() == DataType.Name.COUNTER;
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513611896102\fstmerge_var2_6546127772523875090

File path: C:\download\ssmerge\java-driver\revisions\rev_5a1bb_103c8\rev_rev_left_5a1bb-rev_right_103c8\driver-core\src\test\java\com\datastax\driver\core\DataTypeTest.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_103c8_1716b\rev_103c8-1716b.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_ed94a_7321c\rev_ed94a-7321c.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_6a061_c8d0c\rev_6a061-c8d0c.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_0404c_49019\rev_0404c-49019.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_06e11_41456\rev_06e11-41456.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_291d8_db7cc\rev_291d8-db7cc.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_c0b9c_62c27\rev_c0b9c-62c27.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_3c1b1_9d9c8\rev_3c1b1-9d9c8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_0715c_f6705\rev_0715c-f6705.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_42268_f00c8\rev_42268-f00c8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_7bd8d_75de2\rev_7bd8d-75de2.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_634ae_b9719\rev_634ae-b9719.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_95123_4e2a5\rev_95123-4e2a5.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_7af52_0c75a\rev_7af52-0c75a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_87e42_989a6\rev_87e42-989a6.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_6c201_1fe4b\rev_6c201-1fe4b.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b8189_817ff\rev_b8189-817ff.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_f861d_9639f\rev_f861d-9639f.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_a295b_b91d4\rev_a295b-b91d4.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_78051_7963a\rev_78051-7963a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_c38b9_87511\rev_c38b9-87511.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b0c30_3a602\rev_b0c30-3a602.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_b336e-74285.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612731001\fstmerge_var1_7820324401331664935
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612731001\fstmerge_base_1753585950817841111
private MultiPage(ColumnDefinitions metadata,
                          Token.Factory tokenFactory,
                          Queue<List<ByteBuffer>> rows,
                          ExecutionInfo info,
                          ByteBuffer pagingState,
                          SessionManager session,
                          Statement statement) {

            // Note: as of Cassandra 2.1.0, it turns out that the result of a CAS update is never paged, so
            // we could hard-code the result of wasApplied in this class to "true". However, we can not be sure
            // that this will never change, so apply the generic check by peeking at the first row.
            super(metadata, tokenFactory, rows.peek());
            this.currentPage = rows;
            this.infos.offer(info);

            this.fetchState = new FetchingState(pagingState, null);
            this.session = session;
            this.statement = statement;
        }
=======
private MultiPage(ColumnDefinitions metadata,
                          Token.Factory tokenFactory,
                          Queue<List<ByteBuffer>> rows,
                          ExecutionInfo info,
                          ByteBuffer pagingState,
                          SessionManager session,
                          Statement statement) {

            // Note: as of Cassandra 2.1.0, it turns out that the result of a CAS update is never paged, so
            // we could hard-code the result of wasApplied in this class to "true". However, we can not be sure
            // that this will never change, so apply the generic check by peeking at the first row.
            super(metadata, tokenFactory, rows.peek());
            this.currentPage = rows;
            this.infos.offer(info.withPagingState(pagingState).withStatement(statement));

            this.fetchState = new FetchingState(pagingState, null);
            this.session = session;
            this.statement = statement;
        }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612731001\fstmerge_var2_1831486845298516599

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\ArrayBackedResultSet.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
@Override
        public Configuration getConfiguration() {
            Policies policies = new Policies(
                loadBalancingPolicy == null ? Policies.defaultLoadBalancingPolicy() : loadBalancingPolicy,
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612786700\fstmerge_var1_3318643847845792736
                reconnectionPolicy == null ? Policies.defaultReconnectionPolicy() : reconnectionPolicy,
                retryPolicy == null ? Policies.defaultRetryPolicy() : retryPolicy,
                addressTranslater == null ? Policies.defaultAddressTranslater() : addressTranslater,
                timestampGenerator == null ? Policies.defaultTimestampGenerator() : timestampGenerator
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612786700\fstmerge_base_8924097607120879588
                reconnectionPolicy == null ? Policies.defaultReconnectionPolicy() : reconnectionPolicy,
                retryPolicy == null ? Policies.defaultRetryPolicy() : retryPolicy,
                addressTranslater == null ? Policies.defaultAddressTranslater() : addressTranslater
=======
                Objects.firstNonNull(reconnectionPolicy, Policies.defaultReconnectionPolicy()),
                Objects.firstNonNull(retryPolicy, Policies.defaultRetryPolicy()),
                Objects.firstNonNull(addressTranslater, Policies.defaultAddressTranslater()),
                Objects.firstNonNull(speculativeExecutionPolicy, Policies.defaultSpeculativeExecutionPolicy())
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612786700\fstmerge_var2_4113516140700578301
            );
            return new Configuration(policies,
                                     new ProtocolOptions(port, protocolVersion, maxSchemaAgreementWaitSeconds, sslOptions, authProvider).setCompression(compression),
                                     poolingOptions == null ? new PoolingOptions() : poolingOptions,
                                     socketOptions == null ? new SocketOptions() : socketOptions,
                                     metricsEnabled ? new MetricsOptions(jmxEnabled) : null,
                                     queryOptions == null ? new QueryOptions() : queryOptions,
                                     nettyOptions);
        }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Cluster.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612790813\fstmerge_var1_4938974957793244483
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612790813\fstmerge_base_236346987043623821
public void refreshSchemaAndSignal(final Connection connection, final DefaultResultSetFuture future, final ResultSet rs, final String keyspace, final String table) {
            if (logger.isDebugEnabled())
                logger.debug("Refreshing schema for {}{}", keyspace == null ? "" : keyspace, table == null ? "" : '.' + table);

            executor.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        // Before refreshing the schema, wait for schema agreement so
                        // that querying a table just after having created it don't fail.
                        if (!ControlConnection.waitForSchemaAgreement(connection, Cluster.Manager.this))
                            logger.warn("No schema agreement from live replicas after {} s. The schema may not be up to date on some nodes.", configuration.getProtocolOptions().getMaxSchemaAgreementWaitSeconds());
                        ControlConnection.refreshSchema(connection, keyspace, table, Cluster.Manager.this, false);
                    } catch (Exception e) {
                        logger.error("Error during schema refresh ({}). The schema from Cluster.getMetadata() might appear stale. Asynchronously submitting job to fix.", e.getMessage());
                        submitSchemaRefresh(keyspace, table);
                    } finally {
                        // Always sets the result
                        future.setResult(rs);
                    }
                }
            });
        }
=======
public void refreshSchemaAndSignal(final Connection connection, final DefaultResultSetFuture future, final ResultSet rs, final String keyspace, final String table) {
            if (logger.isDebugEnabled())
                logger.debug("Refreshing schema for {}{}", keyspace == null ? "" : keyspace, table == null ? "" : '.' + table);

            maybeRefreshSchemaAndSignal(connection, future, rs, keyspace, table);
        }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612790813\fstmerge_var2_2222310671550779479

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Cluster.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612792121\fstmerge_var1_5928184661097566906
private void onUp(final Host host, ListeningExecutorService poolCreationExecutor) throws InterruptedException, ExecutionException {
            logger.debug("Host {} is UP", host);

            if (isClosed())
                return;

            if (!connectionFactory.protocolVersion.isSupportedBy(host)) {
                logUnsupportedVersionProtocol(host, connectionFactory.protocolVersion);
                return;
            }

            boolean locked = host.notificationsLock.tryLock(NOTIF_LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS);
            if (!locked) {
                logger.warn("Could not acquire notifications lock within {} seconds, ignoring UP notification for {}", NOTIF_LOCK_TIMEOUT_SECONDS, host);
                return;
            }
            try {
                
                // We don't want to use the public Host.isUp() as this would make us skip the rest for suspected hosts
                if (host.state == Host.State.UP)
                return;

                // If there is a reconnection attempt scheduled for that node, cancel it
                Future<?> scheduledAttempt = host.reconnectionAttempt.getAndSet(null);
                if (scheduledAttempt != null) {
                    logger.debug("Cancelling reconnection attempt since node is UP");
                    scheduledAttempt.cancel(false);
                }

                try {
                    prepareAllQueries(host);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    // Don't propagate because we don't want to prevent other listener to run
                } catch (UnsupportedProtocolVersionException e) {
                    logUnsupportedVersionProtocol(host, e.unsupportedVersion);
                    return;
                } catch (ClusterNameMismatchException e) {
                    logClusterNameMismatch(host, e.expectedClusterName, e.actualClusterName);
                    return;
                }

                // Session#onUp() expects the load balancing policy to have been updated first, so that
                // Host distances are up to date. This mean the policy could return the node before the
                // new pool have been created. This is harmless if there is no prior pool since RequestHandler
                // will ignore the node, but we do want to make sure there is no prior pool so we don't
                // query from a pool we will shutdown right away.
                for (SessionManager s : sessions)
                    s.removePool(host);
                loadBalancingPolicy().onUp(host);
                controlConnection.onUp(host);

                logger.trace("Adding/renewing host pools for newly UP host {}", host);

                List<ListenableFuture<Boolean>> futures = new ArrayList<ListenableFuture<Boolean>>(sessions.size());
                for (SessionManager s : sessions)
                    futures.add(s.forceRenewPool(host, poolCreationExecutor));

                // Only mark the node up once all session have re-added their pool (if the load-balancing
                // policy says it should), so that Host.isUp() don't return true before we're reconnected
                // to the node.
                ListenableFuture<List<Boolean>> f = Futures.allAsList(futures);
                Futures.addCallback(f, new FutureCallback<List<Boolean>>() {
                    public void onSuccess(List<Boolean> poolCreationResults) {
                        // If any of the creation failed, they will have signaled a connection failure
                        // which will trigger a reconnection to the node. So don't bother marking UP.
                        if (Iterables.any(poolCreationResults, Predicates.equalTo(false))) {
                            logger.debug("Connection pool cannot be created, not marking {} UP", host);
                            return;
                        }

                        host.setUp();

                        for (Host.StateListener listener : listeners)
                            listener.onUp(host);
                    }

                    public void onFailure(Throwable t) {
                        // That future is not really supposed to throw unexpected exceptions
                        if (!(t instanceof InterruptedException))
                            logger.error("Unexpected error while marking node UP: while this shouldn't happen, this shouldn't be critical", t);
                    }
                });

                f.get();

                // Now, check if there isn't pools to create/remove following the addition.
                // We do that now only so that it's not called before we've set the node up.
                for (SessionManager s : sessions)
                    s.updateCreatedPools(blockingExecutor);

            } finally {
                host.notificationsLock.unlock();
            }
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612792121\fstmerge_base_5808309811254359211
private void onUp(final Host host, ListeningExecutorService poolCreationExecutor) throws InterruptedException, ExecutionException {
            logger.debug("Host {} is UP", host);

            if (isClosed())
                return;

            if (connectionFactory.protocolVersion == 2 && !supportsProtocolV2(host)) {
                logUnsupportedVersionProtocol(host);
                return;
            }

            boolean locked = host.notificationsLock.tryLock(NOTIF_LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS);
            if (!locked) {
                logger.warn("Could not acquire notifications lock within {} seconds, ignoring UP notification for {}", NOTIF_LOCK_TIMEOUT_SECONDS, host);
                return;
            }
            try {

                // We don't want to use the public Host.isUp() as this would make us skip the rest for suspected hosts
                if (host.state == Host.State.UP)
                    return;

                // If there is a reconnection attempt scheduled for that node, cancel it
                Future<?> scheduledAttempt = host.reconnectionAttempt.getAndSet(null);
                if (scheduledAttempt != null) {
                    logger.debug("Cancelling reconnection attempt since node is UP");
                    scheduledAttempt.cancel(false);
                }

                try {
                    prepareAllQueries(host);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    // Don't propagate because we don't want to prevent other listener to run
                } catch (UnsupportedProtocolVersionException e) {
                    logUnsupportedVersionProtocol(host);
                    return;
                } catch (ClusterNameMismatchException e) {
                    logClusterNameMismatch(host, e.expectedClusterName, e.actualClusterName);
                    return;
                }

                // Session#onUp() expects the load balancing policy to have been updated first, so that
                // Host distances are up to date. This mean the policy could return the node before the
                // new pool have been created. This is harmless if there is no prior pool since RequestHandler
                // will ignore the node, but we do want to make sure there is no prior pool so we don't
                // query from a pool we will shutdown right away.
                for (SessionManager s : sessions)
                    s.removePool(host);
                loadBalancingPolicy().onUp(host);
                controlConnection.onUp(host);

                logger.trace("Adding/renewing host pools for newly UP host {}", host);

                List<ListenableFuture<Boolean>> futures = new ArrayList<ListenableFuture<Boolean>>(sessions.size());
                for (SessionManager s : sessions)
                    futures.add(s.forceRenewPool(host, poolCreationExecutor));

                // Only mark the node up once all session have re-added their pool (if the load-balancing
                // policy says it should), so that Host.isUp() don't return true before we're reconnected
                // to the node.
                ListenableFuture<List<Boolean>> f = Futures.allAsList(futures);
                Futures.addCallback(f, new FutureCallback<List<Boolean>>() {
                    public void onSuccess(List<Boolean> poolCreationResults) {
                        // If any of the creation failed, they will have signaled a connection failure
                        // which will trigger a reconnection to the node. So don't bother marking UP.
                        if (Iterables.any(poolCreationResults, Predicates.equalTo(false))) {
                            logger.debug("Connection pool cannot be created, not marking {} UP", host);
                            return;
                        }

                        host.setUp();

                        for (Host.StateListener listener : listeners)
                            listener.onUp(host);
                    }

                    public void onFailure(Throwable t) {
                        // That future is not really supposed to throw unexpected exceptions
                        if (!(t instanceof InterruptedException))
                            logger.error("Unexpected error while marking node UP: while this shouldn't happen, this shouldn't be critical", t);
                    }
                });

                f.get();

                // Now, check if there isn't pools to create/remove following the addition.
                // We do that now only so that it's not called before we've set the node up.
                for (SessionManager s : sessions)
                    s.updateCreatedPools(blockingExecutor);

            } finally {
                host.notificationsLock.unlock();
            }
        }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612792121\fstmerge_var2_743430079868470382

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Cluster.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612792228\fstmerge_var1_981482954458017691
private void onAdd(final Host host) throws InterruptedException, ExecutionException {
            if (isClosed())
                return;

            logger.info("New Cassandra host {} added", host);

            if (!connectionFactory.protocolVersion.isSupportedBy(host)) {
                logUnsupportedVersionProtocol(host, connectionFactory.protocolVersion);
                return;
            }

            boolean locked = host.notificationsLock.tryLock(NOTIF_LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS);
            if (!locked) {
                logger.warn("Could not acquire notifications lock within {} seconds, ignoring ADD notification for {}", NOTIF_LOCK_TIMEOUT_SECONDS, host);
                return;
            }
            try {

                // Adds to the load balancing first and foremost, as doing so might change the decision
                // it will make for distance() on that node (not likely but we leave that possibility).
                // This does mean the policy may start returning that node for query plan, but as long
                // as no pools have been created (below) this will be ignored by RequestHandler so it's fine.
                loadBalancingPolicy().onAdd(host);

                // Next, if the host should be ignored, well, ignore it.
                if (loadBalancingPolicy().distance(host) == HostDistance.IGNORED) {
                    // We still mark the node UP though as it should be (and notifiy the listeners).
                    // We'll mark it down if we have  a notification anyway and we've documented that especially
                    // for IGNORED hosts, the isUp() method was a best effort guess
                    host.setUp();
                    for (Host.StateListener listener : listeners)
                        listener.onAdd(host);
                    return;
                }

                try {
                    prepareAllQueries(host);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    // Don't propagate because we don't want to prevent other listener to run
                } catch (UnsupportedProtocolVersionException e) {
                    logUnsupportedVersionProtocol(host, e.unsupportedVersion);
                    return;
                } catch (ClusterNameMismatchException e) {
                    logClusterNameMismatch(host, e.expectedClusterName, e.actualClusterName);
                    return;
                }

                controlConnection.onAdd(host);

                List<ListenableFuture<Boolean>> futures = new ArrayList<ListenableFuture<Boolean>>(sessions.size());
                for (SessionManager s : sessions)
                    futures.add(s.maybeAddPool(host, blockingExecutor));

                // Only mark the node up once all session have added their pool (if the load-balancing
                // policy says it should), so that Host.isUp() don't return true before we're reconnected
                // to the node.
                ListenableFuture<List<Boolean>> f = Futures.allAsList(futures);
                Futures.addCallback(f, new FutureCallback<List<Boolean>>() {
                    public void onSuccess(List<Boolean> poolCreationResults) {
                        // If any of the creation failed, they will have signaled a connection failure
                        // which will trigger a reconnection to the node. So don't bother marking UP.
                        if (Iterables.any(poolCreationResults, Predicates.equalTo(false))) {
                            logger.debug("Connection pool cannot be created, not marking {} UP", host);
                            return;
                        }

                        host.setUp();

                        for (Host.StateListener listener : listeners)
                            listener.onAdd(host);
                    }

                    public void onFailure(Throwable t) {
                        // That future is not really supposed to throw unexpected exceptions
                        if (!(t instanceof InterruptedException))
                            logger.error("Unexpected error while adding node: while this shouldn't happen, this shouldn't be critical", t);
                    }
                });

                f.get();

                // Now, check if there isn't pools to create/remove following the addition.
                // We do that now only so that it's not called before we've set the node up.
                for (SessionManager s : sessions)
                    s.updateCreatedPools(blockingExecutor);

            } finally {
                host.notificationsLock.unlock();
            }
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612792228\fstmerge_base_5664746283373135747
private void onAdd(final Host host) throws InterruptedException, ExecutionException {
            if (isClosed())
                return;

            logger.info("New Cassandra host {} added", host);

            if (connectionFactory.protocolVersion == 2 && !supportsProtocolV2(host)) {
                logUnsupportedVersionProtocol(host);
                return;
            }

            boolean locked = host.notificationsLock.tryLock(NOTIF_LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS);
            if (!locked) {
                logger.warn("Could not acquire notifications lock within {} seconds, ignoring ADD notification for {}", NOTIF_LOCK_TIMEOUT_SECONDS, host);
                return;
            }
            try {

                // Adds to the load balancing first and foremost, as doing so might change the decision
                // it will make for distance() on that node (not likely but we leave that possibility).
                // This does mean the policy may start returning that node for query plan, but as long
                // as no pools have been created (below) this will be ignored by RequestHandler so it's fine.
                loadBalancingPolicy().onAdd(host);

                // Next, if the host should be ignored, well, ignore it.
                if (loadBalancingPolicy().distance(host) == HostDistance.IGNORED) {
                    // We still mark the node UP though as it should be (and notifiy the listeners).
                    // We'll mark it down if we have  a notification anyway and we've documented that especially
                    // for IGNORED hosts, the isUp() method was a best effort guess
                    host.setUp();
                    for (Host.StateListener listener : listeners)
                        listener.onAdd(host);
                    return;
                }

                try {
                    prepareAllQueries(host);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    // Don't propagate because we don't want to prevent other listener to run
                } catch (UnsupportedProtocolVersionException e) {
                    logUnsupportedVersionProtocol(host);
                    return;
                } catch (ClusterNameMismatchException e) {
                    logClusterNameMismatch(host, e.expectedClusterName, e.actualClusterName);
                    return;
                }

                controlConnection.onAdd(host);

                List<ListenableFuture<Boolean>> futures = new ArrayList<ListenableFuture<Boolean>>(sessions.size());
                for (SessionManager s : sessions)
                    futures.add(s.maybeAddPool(host, blockingExecutor));

                // Only mark the node up once all session have added their pool (if the load-balancing
                // policy says it should), so that Host.isUp() don't return true before we're reconnected
                // to the node.
                ListenableFuture<List<Boolean>> f = Futures.allAsList(futures);
                Futures.addCallback(f, new FutureCallback<List<Boolean>>() {
                    public void onSuccess(List<Boolean> poolCreationResults) {
                        // If any of the creation failed, they will have signaled a connection failure
                        // which will trigger a reconnection to the node. So don't bother marking UP.
                        if (Iterables.any(poolCreationResults, Predicates.equalTo(false))) {
                            logger.debug("Connection pool cannot be created, not marking {} UP", host);
                            return;
                        }

                        host.setUp();

                        for (Host.StateListener listener : listeners)
                            listener.onAdd(host);
                    }

                    public void onFailure(Throwable t) {
                        // That future is not really supposed to throw unexpected exceptions
                        if (!(t instanceof InterruptedException))
                            logger.error("Unexpected error while adding node: while this shouldn't happen, this shouldn't be critical", t);
                    }
                });

                f.get();

                // Now, check if there isn't pools to create/remove following the addition.
                // We do that now only so that it's not called before we've set the node up.
                for (SessionManager s : sessions)
                    s.updateCreatedPools(blockingExecutor);

            } finally {
                host.notificationsLock.unlock();
            }
        }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612792228\fstmerge_var2_7133455281996502210

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Cluster.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612802717\fstmerge_var1_482358285342472973
protected Connection(String name, InetSocketAddress address, Factory factory) throws ConnectionException, InterruptedException, UnsupportedProtocolVersionException, ClusterNameMismatchException {
        this.address = address;
        this.factory = factory;
        this.dispatcher = new Dispatcher();
        this.name = name;

        try {
            ClientBootstrap bootstrap = factory.newBootstrap();
            ProtocolOptions protocolOptions = factory.configuration.getProtocolOptions();
            ProtocolVersion protocolVersion = factory.protocolVersion == null ? ProtocolVersion.NEWEST_SUPPORTED : factory.protocolVersion;
            bootstrap.setPipelineFactory(new PipelineFactory(this, protocolVersion, protocolOptions.getCompression().compressor, protocolOptions.getSSLOptions(),
                factory.configuration.getPoolingOptions().getHeartbeatIntervalSeconds(), factory.timer));

            ChannelFuture future = bootstrap.connect(address);

            writer.incrementAndGet();
            try {
                // Wait until the connection attempt succeeds or fails.
                this.channel = future.awaitUninterruptibly().getChannel();
                this.factory.allChannels.add(this.channel);
                if (!future.isSuccess()) {
                    if (logger.isDebugEnabled())
                        logger.debug(String.format("%s Error connecting to %s%s", this, address, extractMessage(future.getCause())));
                    throw defunct(new TransportException(address, "Cannot connect", future.getCause()));
                }
            } finally {
                writer.decrementAndGet();
            }

            logger.trace("{} Connection opened successfully", this);
            initializeTransport(protocolVersion, factory.manager.metadata.clusterName);
            logger.debug("{} Transport initialized and ready", this);
            isInitialized = true;

        } catch (ConnectionException e) {
            closeAsync().force();
            throw e;
        } catch (ClusterNameMismatchException e) {
            closeAsync().force();
            throw e;
        } catch (UnsupportedProtocolVersionException e) {
            closeAsync().force();
            throw e;
        } catch (InterruptedException e) {
            closeAsync().force();
            throw e;
        } catch (RuntimeException e) {
            closeAsync().force();
            throw e;
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612802717\fstmerge_base_4907979954005154390
protected Connection(String name, InetSocketAddress address, Factory factory) throws ConnectionException, InterruptedException, UnsupportedProtocolVersionException, ClusterNameMismatchException {
        this.address = address;
        this.factory = factory;
        this.name = name;

        try {
            ClientBootstrap bootstrap = factory.newBootstrap();
            ProtocolOptions protocolOptions = factory.configuration.getProtocolOptions();
            int protocolVersion = factory.protocolVersion == 1 ? 1 : 2;
            bootstrap.setPipelineFactory(new PipelineFactory(this, protocolVersion, protocolOptions.getCompression().compressor, protocolOptions.getSSLOptions(),
                factory.configuration.getPoolingOptions().getHeartbeatIntervalSeconds(), factory.timer));

            ChannelFuture future = bootstrap.connect(address);

            writer.incrementAndGet();
            try {
                // Wait until the connection attempt succeeds or fails.
                this.channel = future.awaitUninterruptibly().getChannel();
                this.factory.allChannels.add(this.channel);
                if (!future.isSuccess()) {
                    if (logger.isDebugEnabled())
                        logger.debug(String.format("%s Error connecting to %s%s", this, address, extractMessage(future.getCause())));
                    throw defunct(new TransportException(address, "Cannot connect", future.getCause()));
                }
            } finally {
                writer.decrementAndGet();
            }

            logger.trace("{} Connection opened successfully", this);
            initializeTransport(protocolVersion, factory.manager.metadata.clusterName);
            logger.debug("{} Transport initialized and ready", this);
            isInitialized = true;

        } catch (ConnectionException e) {
            closeAsync().force();
            throw e;
        } catch (ClusterNameMismatchException e) {
            closeAsync().force();
            throw e;
        } catch (UnsupportedProtocolVersionException e) {
            closeAsync().force();
            throw e;
        } catch (InterruptedException e) {
            closeAsync().force();
            throw e;
        } catch (RuntimeException e) {
            closeAsync().force();
            throw e;
        }
=======
Connection(String name, InetSocketAddress address, Factory factory) {
        this(name, address, factory, null);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612802717\fstmerge_var2_788148084770772044
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Connection.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807631\fstmerge_var1_1347362154929603478
private static final Message.ProtocolEncoder messageEncoderV1 = new Message.ProtocolEncoder(ProtocolVersion.V1);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807631\fstmerge_base_4080239801473399124
private static final Message.ProtocolEncoder messageEncoderV1 = new Message.ProtocolEncoder(1);
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807631\fstmerge_var2_8918389285838148524

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Connection.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807705\fstmerge_var1_3039072265094312927
private static final Message.ProtocolEncoder messageEncoderV2 = new Message.ProtocolEncoder(ProtocolVersion.V2);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807705\fstmerge_base_7593079691193692210
private static final Message.ProtocolEncoder messageEncoderV2 = new Message.ProtocolEncoder(2);
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807705\fstmerge_var2_806955430781162801

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Connection.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807777\fstmerge_var1_22266681492751238
private final ProtocolVersion protocolVersion;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807777\fstmerge_base_664855814464880437
private final int protocolVersion;
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807777\fstmerge_var2_5882882600886065762

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Connection.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807853\fstmerge_var1_6846629103360640725
@Override
        public ChannelPipeline getPipeline() throws Exception {
            ChannelPipeline pipeline = Channels.pipeline();

            if (sslOptions != null) {
                SSLEngine engine = sslOptions.context.createSSLEngine();
                engine.setUseClientMode(true);
                engine.setEnabledCipherSuites(sslOptions.cipherSuites);
                SslHandler handler = new SslHandler(engine);
                handler.setCloseOnSSLException(true);
                pipeline.addLast("ssl", handler);
            }

            //pipeline.addLast("debug", new LoggingHandler(InternalLogLevel.INFO));

            pipeline.addLast("frameDecoder", new Frame.Decoder());
            pipeline.addLast("frameEncoder", frameEncoder);

            if (compressor != null) {
                pipeline.addLast("frameDecompressor", new Frame.Decompressor(compressor));
                pipeline.addLast("frameCompressor", new Frame.Compressor(compressor));
            }

            pipeline.addLast("messageDecoder", messageDecoder);
            pipeline.addLast("messageEncoder", messageEncoderFor(protocolVersion));

            pipeline.addLast("idleStateHandler", idleStateHandler);

            pipeline.addLast("dispatcher", connection.dispatcher);

            return pipeline;
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807853\fstmerge_base_8143574280609781388
@Override
        public ChannelPipeline getPipeline() throws Exception {
            ChannelPipeline pipeline = Channels.pipeline();

            if (sslOptions != null) {
                SSLEngine engine = sslOptions.context.createSSLEngine();
                engine.setUseClientMode(true);
                engine.setEnabledCipherSuites(sslOptions.cipherSuites);
                SslHandler handler = new SslHandler(engine);
                handler.setCloseOnSSLException(true);
                pipeline.addLast("ssl", handler);
            }

            //pipeline.addLast("debug", new LoggingHandler(InternalLogLevel.INFO));

            pipeline.addLast("frameDecoder", new Frame.Decoder());
            pipeline.addLast("frameEncoder", frameEncoder);

            if (compressor != null) {
                pipeline.addLast("frameDecompressor", new Frame.Decompressor(compressor));
                pipeline.addLast("frameCompressor", new Frame.Compressor(compressor));
            }

            pipeline.addLast("messageDecoder", messageDecoder);
            pipeline.addLast("messageEncoder", protocolVersion == 1 ? messageEncoderV1 : messageEncoderV2);

            pipeline.addLast("idleStateHandler", idleStateHandler);

            pipeline.addLast("dispatcher", connection.dispatcher);

            return pipeline;
        }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612807853\fstmerge_var2_8448597567290078535

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Connection.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
static boolean waitForSchemaAgreement(Connection connection, Cluster.Manager cluster) throws ConnectionException, BusyConnectionException, ExecutionException, InterruptedException {

        long start = System.nanoTime();
        long elapsed = 0;
        int maxSchemaAgreementWaitSeconds = cluster.configuration.getProtocolOptions().getMaxSchemaAgreementWaitSeconds();
        while (elapsed < maxSchemaAgreementWaitSeconds * 1000) {

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612816135\fstmerge_var1_2409047547937319062
            DefaultResultSetFuture peersFuture = new DefaultResultSetFuture(null, cluster.protocolVersion(), new Requests.Query(SELECT_SCHEMA_PEERS));
            DefaultResultSetFuture localFuture = new DefaultResultSetFuture(null, cluster.protocolVersion(), new Requests.Query(SELECT_SCHEMA_LOCAL));
            connection.write(peersFuture);
            connection.write(localFuture);

            Set<UUID> versions = new HashSet<UUID>();

            Row localRow = localFuture.get().one();
            if (localRow != null && !localRow.isNull("schema_version"))
                versions.add(localRow.getUUID("schema_version"));

            for (Row row : peersFuture.get()) {

                InetSocketAddress addr = addressToUseForPeerHost(row, connection.address, cluster, true);
                if (addr == null || row.isNull("schema_version"))
                    continue;

                Host peer = cluster.metadata.getHost(addr);
                if (peer != null && peer.isUp())
                    versions.add(row.getUUID("schema_version"));
            }

            logger.debug("Checking for schema agreement: versions are {}", versions);

            if (versions.size() <= 1)
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612816135\fstmerge_base_8446815486431300480
            DefaultResultSetFuture peersFuture = new DefaultResultSetFuture(null, new Requests.Query(SELECT_SCHEMA_PEERS));
            DefaultResultSetFuture localFuture = new DefaultResultSetFuture(null, new Requests.Query(SELECT_SCHEMA_LOCAL));
            connection.write(peersFuture);
            connection.write(localFuture);

            Set<UUID> versions = new HashSet<UUID>();

            Row localRow = localFuture.get().one();
            if (localRow != null && !localRow.isNull("schema_version"))
                versions.add(localRow.getUUID("schema_version"));

            for (Row row : peersFuture.get()) {

                InetSocketAddress addr = addressToUseForPeerHost(row, connection.address, cluster, true);
                if (addr == null || row.isNull("schema_version"))
                    continue;

                Host peer = cluster.metadata.getHost(addr);
                if (peer != null && peer.isUp())
                    versions.add(row.getUUID("schema_version"));
            }

            logger.debug("Checking for schema agreement: versions are {}", versions);

            if (versions.size() <= 1)
=======
            if (checkSchemaAgreement(connection, cluster))
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612816135\fstmerge_var2_423706954777748328
                return true;

            // let's not flood the node too much
            Thread.sleep(200);

            elapsed = Cluster.timeSince(start, TimeUnit.MILLISECONDS);
        }

        return false;
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\ControlConnection.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612824474\fstmerge_var1_2385222177634764536
static DataType decode(ChannelBuffer buffer) {
        Name name = Name.fromProtocolId(buffer.readUnsignedShort());
        switch (name) {
            case CUSTOM:
                String className = CBUtil.readString(buffer);
                return CassandraTypeParser.isUserType(className) || CassandraTypeParser.isTupleType(className)
                     ? CassandraTypeParser.parseOne(className)
                     : custom(className);
            case LIST:
                return list(decode(buffer));
            case SET:
                return set(decode(buffer));
            case MAP:
                DataType keys = decode(buffer);
                DataType values = decode(buffer);
                return map(keys, values);
            case UDT:
                String keyspace = CBUtil.readString(buffer);
                String type = CBUtil.readString(buffer);
                int nFields = buffer.readShort() & 0xffff;
                List<UserType.Field> fields = new ArrayList<UserType.Field>(nFields);
                for (int i = 0; i < nFields; i++) {
                    String fieldName = CBUtil.readString(buffer);
                    DataType fieldType = decode(buffer);
                    fields.add(new UserType.Field(fieldName, fieldType));
                }
                return new UserType(keyspace, type, fields);
            case TUPLE:
                nFields = buffer.readShort() & 0xffff;
                List<DataType> types = new ArrayList<DataType>(nFields);
                for (int i = 0; i < nFields; i++) {
                    types.add(decode(buffer));
                }
                return new TupleType(types);
            default:
                return primitiveTypeMap.get(name);
        }
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612824474\fstmerge_base_7553299007141658015
static DataType decode(ChannelBuffer buffer) {
        Name name = Name.fromProtocolId(buffer.readUnsignedShort());
        switch (name) {
            case CUSTOM:
                return custom(CBUtil.readString(buffer));
            case LIST:
                return list(decode(buffer));
            case SET:
                return set(decode(buffer));
            case MAP:
                DataType keys = decode(buffer);
                DataType values = decode(buffer);
                return map(keys, values);
            default:
                return primitiveTypeMap.get(name);
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612824474\fstmerge_var2_3004813474222786009

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\DataType.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838228\fstmerge_var1_1769441619274891288
@Override protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
            int version = buffer.getByte(0);
            // version first bit is the "direction" of the frame (request or response)
            version = version & 0x7F;

            return version >= 3 ? decoderV3.decode(ctx, channel, buffer) : decoderV1.decode(ctx, channel, buffer);
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838228\fstmerge_base_5697222138642064994
@Override
        protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
            try {
                if (buffer.readableBytes() == 0)
                    return null;

                // Validate the opcode (this will throw if it's not a response)
                if (buffer.readableBytes() >= 4)
                    Message.Response.Type.fromOpcode(buffer.getByte(3));

                ChannelBuffer frame = (ChannelBuffer) super.decode(ctx, channel, buffer);
                if (frame == null) {
                    return null;
                }

                return Frame.create(frame);
            } catch (CorruptedFrameException e) {
                throw new DriverInternalError(e.getMessage());
            } catch (TooLongFrameException e) {
                throw new DriverInternalError(e.getMessage());
            }
        }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838228\fstmerge_var2_1924062409372057953

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Frame.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838308\fstmerge_var1_3007574883218056839
public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws IOException {
            assert msg instanceof Frame : "Expecting frame, got " + msg;

            Frame frame = (Frame)msg;
            ProtocolVersion protocolVersion = frame.header.version;

            ChannelBuffer header = ChannelBuffers.buffer(Header.lengthFor(protocolVersion));
            // We don't bother with the direction, we only send requests.
            header.writeByte(frame.header.version.toInt());
            header.writeByte(Header.Flag.serialize(frame.header.flags));
            writeStreamId(frame.header.streamId, header, protocolVersion);
            header.writeByte(frame.header.opcode);
            header.writeInt(frame.body.readableBytes());
            return ChannelBuffers.wrappedBuffer(header, frame.body);
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838308\fstmerge_base_8841006078650684668
public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws IOException {
            assert msg instanceof Frame : "Expecting frame, got " + msg;

            Frame frame = (Frame)msg;

            ChannelBuffer header = ChannelBuffers.buffer(Frame.Header.LENGTH);
            // We don't bother with the direction, we only send requests.
            header.writeByte(frame.header.version);
            header.writeByte(Header.Flag.serialize(frame.header.flags));
            header.writeByte(frame.header.streamId);
            header.writeByte(frame.header.opcode);
            header.writeInt(frame.body.readableBytes());
            return ChannelBuffers.wrappedBuffer(header, frame.body);
        }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838308\fstmerge_var2_3026419361633259043

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Frame.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838391\fstmerge_var1_6763562616340268452
private static Frame create(ChannelBuffer fullFrame) {
        assert fullFrame.readableBytes() >= 1 : String.format("Frame too short (%d bytes)", fullFrame.readableBytes());

        int versionBytes = fullFrame.readByte();
        // version first byte is the "direction" of the frame (request or response)
        ProtocolVersion version = ProtocolVersion.fromInt(versionBytes & 0x7F);
        int hdrLen = Header.lengthFor(version);
        assert fullFrame.readableBytes() >= (hdrLen-1) : String.format("Frame too short (%d bytes)", fullFrame.readableBytes());

        int flags = fullFrame.readByte();
        int streamId = readStreamid(fullFrame, version);
        int opcode = fullFrame.readByte();
        int length = fullFrame.readInt();
        assert length == fullFrame.readableBytes();

        Header header = new Header(version, flags, streamId, opcode);
        return new Frame(header, fullFrame);
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838391\fstmerge_base_1089772650236330096
private static Frame create(ChannelBuffer fullFrame) {
        assert fullFrame.readableBytes() >= Header.LENGTH : String.format("Frame too short (%d bytes)", fullFrame.readableBytes());

        int version = fullFrame.readByte();
        int flags = fullFrame.readByte();
        int streamId = fullFrame.readByte();
        int opcode = fullFrame.readByte();
        int length = fullFrame.readInt();
        assert length == fullFrame.readableBytes();

        // version first byte is the "direction" of the frame (request or response)
        version = version & 0x7F;

        Header header = new Header(version, flags, streamId, opcode);
        return new Frame(header, fullFrame);
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612838391\fstmerge_var2_2547369964166626384

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Frame.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851647\fstmerge_var1_2716663508223420916
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851647\fstmerge_base_6891654541581997470
final List<PooledConnection> connections;
=======
final List<Connection> connections;
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851647\fstmerge_var2_4728006404620550406

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851723\fstmerge_var1_2256341151421937680
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851723\fstmerge_base_7382752492588061534
private final Set<Connection> trash = new CopyOnWriteArraySet<Connection>();
=======
final Set<Connection> trash = new CopyOnWriteArraySet<Connection>();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851723\fstmerge_var2_7364465085890488329

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 2
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 2, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851799\fstmerge_var1_7412335214674168673
protected HostConnectionPool(Host host, HostDistance hostDistance, SessionManager manager) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851799\fstmerge_base_8819267555924341655
public HostConnectionPool(Host host, HostDistance hostDistance, SessionManager manager) throws ConnectionException, UnsupportedProtocolVersionException, ClusterNameMismatchException {
=======
public HostConnectionPool(final Host host, HostDistance hostDistance, final SessionManager manager){
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851799\fstmerge_var2_3472240146102322190
        assert hostDistance != HostDistance.IGNORED;
        this.host = host;
        this.hostDistance = hostDistance;
        this.manager = manager;
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851799\fstmerge_var1_7412335214674168673
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851799\fstmerge_base_8819267555924341655

        this.newConnectionTask = new Runnable() {
            @Override
            public void run() {
                addConnectionIfUnderMaximum();
                scheduledForCreation.decrementAndGet();
            }
        };

        // Create initial core connections
        List<PooledConnection> l = new ArrayList<PooledConnection>(options().getCoreConnectionsPerHost(hostDistance));
        try {
            for (int i = 0; i < options().getCoreConnectionsPerHost(hostDistance); i++)
                l.add(manager.connectionFactory().open(this));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            // If asked to interrupt, we can skip opening core connections, the pool will still work.
            // But we ignore otherwise cause I'm not sure we can do much better currently.
        } catch (ConnectionException e) {
            forceClose(l);
            throw e;
        } catch (UnsupportedProtocolVersionException e) {
            forceClose(l);
            throw e;
        } catch (ClusterNameMismatchException e) {
            forceClose(l);
            throw e;
        } catch (RuntimeException e) {
            forceClose(l);
            throw e;
        }
        this.connections = new CopyOnWriteArrayList<PooledConnection>(l);
        this.open = new AtomicInteger(connections.size());

        logger.trace("Created connection pool to host {}", host);
=======

        this.newConnectionTask = new Runnable() {
            @Override
            public void run() {
                addConnectionIfUnderMaximum();
                scheduledForCreation.decrementAndGet();
            }
        };

        this.connections = new CopyOnWriteArrayList<Connection>();
        this.open = new AtomicInteger();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851799\fstmerge_var2_3472240146102322190
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851888\fstmerge_var1_6969018176431700162
abstract PooledConnection borrowConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851888\fstmerge_base_7713559903685781522
public PooledConnection borrowConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException {
        if (isClosed())
            // Note: throwing a ConnectionException is probably fine in practice as it will trigger the creation of a new host.
            // That being said, maybe having a specific exception could be cleaner.
            throw new ConnectionException(host.getSocketAddress(), "Pool is shutdown");

        if (connections.isEmpty()) {
            for (int i = 0; i < options().getCoreConnectionsPerHost(hostDistance); i++) {
                // We don't respect MAX_SIMULTANEOUS_CREATION here because it's  only to
                // protect against creating connection in excess of core too quickly
                scheduledForCreation.incrementAndGet();
                manager.blockingExecutor().submit(newConnectionTask);
            }
            PooledConnection c = waitForConnection(timeout, unit);
            c.setKeyspace(manager.poolsState.keyspace);
            return c;
        }

        int minInFlight = Integer.MAX_VALUE;
        PooledConnection leastBusy = null;
        for (PooledConnection connection : connections) {
            int inFlight = connection.inFlight.get();
            if (inFlight < minInFlight) {
                minInFlight = inFlight;
                leastBusy = connection;
            }
        }

        if (minInFlight >= options().getMaxSimultaneousRequestsPerConnectionThreshold(hostDistance) && connections.size() < options().getMaxConnectionsPerHost(hostDistance))
            maybeSpawnNewConnection();

        if (leastBusy == null) {
            // We could have raced with a shutdown since the last check
            if (isClosed())
                throw new ConnectionException(host.getSocketAddress(), "Pool is shutdown");
            // This might maybe happen if the number of core connections per host is 0 and a connection was trashed between
            // the previous check to connections and now. But in that case, the line above will have trigger the creation of
            // a new connection, so just wait that connection and move on
            leastBusy = waitForConnection(timeout, unit);
        } else {
            while (true) {
                int inFlight = leastBusy.inFlight.get();

                if (inFlight >= leastBusy.maxAvailableStreams()) {
                    leastBusy = waitForConnection(timeout, unit);
                    break;
                }

                if (leastBusy.inFlight.compareAndSet(inFlight, inFlight + 1))
                    break;
            }
        }
        leastBusy.setKeyspace(manager.poolsState.keyspace);
        return leastBusy;
    }
=======
public Connection borrowConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException {
        if (phase == Phase.INITIALIZING)
            throw new ConnectionException(host.getSocketAddress(), "Pool is initializing.");

        if (phase != Phase.READY)
            // Note: throwing a ConnectionException is probably fine in practice as it will trigger the creation of a new host.
            // That being said, maybe having a specific exception could be cleaner.
            throw new ConnectionException(host.getSocketAddress(), "Pool is " + phase);

        if (connections.isEmpty()) {
            for (int i = 0; i < options().getCoreConnectionsPerHost(hostDistance); i++) {
                // We don't respect MAX_SIMULTANEOUS_CREATION here because it's  only to
                // protect against creating connection in excess of core too quickly
                scheduledForCreation.incrementAndGet();
                manager.blockingExecutor().submit(newConnectionTask);
            }
            Connection c = waitForConnection(timeout, unit);
            totalInFlight.incrementAndGet();
            c.setKeyspace(manager.poolsState.keyspace);
            return c;
        }

        int minInFlight = Integer.MAX_VALUE;
        Connection leastBusy = null;
        for (Connection connection : connections) {
            int inFlight = connection.inFlight.get();
            if (inFlight < minInFlight) {
                minInFlight = inFlight;
                leastBusy = connection;
            }
        }

        if (leastBusy == null) {
            // We could have raced with a shutdown since the last check
            if (isClosed())
                throw new ConnectionException(host.getSocketAddress(), "Pool is shutdown");
            // This might maybe happen if the number of core connections per host is 0 and a connection was trashed between
            // the previous check to connections and now. But in that case, the line above will have trigger the creation of
            // a new connection, so just wait that connection and move on
            leastBusy = waitForConnection(timeout, unit);
        } else {
            while (true) {
                int inFlight = leastBusy.inFlight.get();

                if (inFlight >= leastBusy.maxAvailableStreams()) {
                    leastBusy = waitForConnection(timeout, unit);
                    break;
                }

                if (leastBusy.inFlight.compareAndSet(inFlight, inFlight + 1))
                    break;
            }
        }

        int totalInFlightCount = totalInFlight.incrementAndGet();
        // update max atomically:
        while (true) {
            int oldMax = maxTotalInFlight.get();
            if (totalInFlightCount <= oldMax || maxTotalInFlight.compareAndSet(oldMax, totalInFlightCount))
                break;
        }

        int connectionCount = open.get() + scheduledForCreation.get();
        if (connectionCount < options().getMaxConnectionsPerHost(hostDistance)) {
            // Add a connection if we fill the first n-1 connections and almost fill the last one
            int currentCapacity = (connectionCount - 1) * StreamIdGenerator.MAX_STREAM_PER_CONNECTION
                + options().getMaxSimultaneousRequestsPerConnectionThreshold(hostDistance);
            if (totalInFlightCount > currentCapacity)
                maybeSpawnNewConnection();
        }

        leastBusy.setKeyspace(manager.poolsState.keyspace);
        return leastBusy;
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851888\fstmerge_var2_3190983375371907529

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851972\fstmerge_var1_6170058299546244115
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851972\fstmerge_base_1188516459578563964
private PooledConnection waitForConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException {
        if (timeout == 0)
            throw new TimeoutException();

        long start = System.nanoTime();
        long remaining = timeout;
        do {
            try {
                awaitAvailableConnection(remaining, unit);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                // If we're interrupted fine, check if there is a connection available but stop waiting otherwise
                timeout = 0; // this will make us stop the loop if we don't get a connection right away
            }

            if (isClosed())
                throw new ConnectionException(host.getSocketAddress(), "Pool is shutdown");

            int minInFlight = Integer.MAX_VALUE;
            PooledConnection leastBusy = null;
            for (PooledConnection connection : connections) {
                int inFlight = connection.inFlight.get();
                if (inFlight < minInFlight) {
                    minInFlight = inFlight;
                    leastBusy = connection;
                }
            }

            // If we race with shutdown, leastBusy could be null. In that case we just loop and we'll throw on the next
            // iteration anyway
            if (leastBusy != null) {
                while (true) {
                    int inFlight = leastBusy.inFlight.get();

                    if (inFlight >= leastBusy.maxAvailableStreams())
                        break;

                    if (leastBusy.inFlight.compareAndSet(inFlight, inFlight + 1))
                        return leastBusy;
                }
            }

            remaining = timeout - Cluster.timeSince(start, unit);
        } while (remaining > 0);

        throw new TimeoutException();
    }
=======
private Connection waitForConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException {
        if (timeout == 0)
            throw new TimeoutException();

        long start = System.nanoTime();
        long remaining = timeout;
        do {
            try {
                awaitAvailableConnection(remaining, unit);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                // If we're interrupted fine, check if there is a connection available but stop waiting otherwise
                timeout = 0; // this will make us stop the loop if we don't get a connection right away
            }

            if (isClosed())
                throw new ConnectionException(host.getSocketAddress(), "Pool is shutdown");

            int minInFlight = Integer.MAX_VALUE;
            Connection leastBusy = null;
            for (Connection connection : connections) {
                int inFlight = connection.inFlight.get();
                if (inFlight < minInFlight) {
                    minInFlight = inFlight;
                    leastBusy = connection;
                }
            }

            // If we race with shutdown, leastBusy could be null. In that case we just loop and we'll throw on the next
            // iteration anyway
            if (leastBusy != null) {
                while (true) {
                    int inFlight = leastBusy.inFlight.get();

                    if (inFlight >= leastBusy.maxAvailableStreams())
                        break;

                    if (leastBusy.inFlight.compareAndSet(inFlight, inFlight + 1))
                        return leastBusy;
                }
            }

            remaining = timeout - Cluster.timeSince(start, unit);
        } while (remaining > 0);

        throw new TimeoutException();
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612851972\fstmerge_var2_8423680580390855266

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852053\fstmerge_var1_6519313887224671740
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852053\fstmerge_base_6464862807643486655
private boolean addConnectionIfUnderMaximum() {

        // First, make sure we don't cross the allowed limit of open connections
        for(;;) {
            int opened = open.get();
            if (opened >= options().getMaxConnectionsPerHost(hostDistance))
                return false;

            if (open.compareAndSet(opened, opened + 1))
                break;
        }

        if (isClosed()) {
            open.decrementAndGet();
            return false;
        }

        // Now really open the connection
        try {
            connections.add(manager.connectionFactory().open(this));
            signalAvailableConnection();
            return true;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            // Skip the open but ignore otherwise
            open.decrementAndGet();
            return false;
        } catch (ConnectionException e) {
            open.decrementAndGet();
            logger.debug("Connection error to {} while creating additional connection", host);
            return false;
        } catch (AuthenticationException e) {
            // This shouldn't really happen in theory
            open.decrementAndGet();
            logger.error("Authentication error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (UnsupportedProtocolVersionException e) {
            // This shouldn't happen since we shouldn't have been able to connect in the first place
            open.decrementAndGet();
            logger.error("UnsupportedProtocolVersionException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (ClusterNameMismatchException e) {
            open.decrementAndGet();
            logger.error("ClusterNameMismatchException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        }
    }
=======
private boolean addConnectionIfUnderMaximum() {

        // First, make sure we don't cross the allowed limit of open connections
        for(;;) {
            int opened = open.get();
            if (opened >= options().getMaxConnectionsPerHost(hostDistance))
                return false;

            if (open.compareAndSet(opened, opened + 1))
                break;
        }

        if (phase != Phase.READY) {
            open.decrementAndGet();
            return false;
        }

        // Now really open the connection
        try {
            Connection newConnection = tryResurrectFromTrash();
            if (newConnection == null) {
                logger.debug("Creating new connection on busy pool to {}", host);
                newConnection = manager.connectionFactory().open(this);
            }
            connections.add(newConnection);

            newConnection.state.compareAndSet(RESURRECTING, OPEN); // no-op if it was already OPEN

            // We might have raced with pool shutdown since the last check; ensure the connection gets closed in case the pool did not do it.
            if (phase != Phase.READY && !newConnection.isClosed()) {
                close(newConnection);
                open.decrementAndGet();
                return false;
            }

            signalAvailableConnection();
            return true;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            // Skip the open but ignore otherwise
            open.decrementAndGet();
            return false;
        } catch (ConnectionException e) {
            open.decrementAndGet();
            logger.debug("Connection error to {} while creating additional connection", host);
            return false;
        } catch (AuthenticationException e) {
            // This shouldn't really happen in theory
            open.decrementAndGet();
            logger.error("Authentication error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (UnsupportedProtocolVersionException e) {
            // This shouldn't happen since we shouldn't have been able to connect in the first place
            open.decrementAndGet();
            logger.error("UnsupportedProtocolVersionException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (ClusterNameMismatchException e) {
            open.decrementAndGet();
            logger.error("ClusterNameMismatchException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        }
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852053\fstmerge_var2_4183898678208951502

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852153\fstmerge_var1_7935054706361180511
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852153\fstmerge_base_2156549440651348550
private void maybeSpawnNewConnection() {
        while (true) {
            int inCreation = scheduledForCreation.get();
            if (inCreation >= MAX_SIMULTANEOUS_CREATION)
                return;
            if (scheduledForCreation.compareAndSet(inCreation, inCreation + 1))
                break;
        }

        logger.debug("Creating new connection on busy pool to {}", host);
        manager.blockingExecutor().submit(newConnectionTask);
    }
=======
private void maybeSpawnNewConnection() {
        while (true) {
            int inCreation = scheduledForCreation.get();
            if (inCreation >= MAX_SIMULTANEOUS_CREATION)
                return;
            if (scheduledForCreation.compareAndSet(inCreation, inCreation + 1))
                break;
        }

        manager.blockingExecutor().submit(newConnectionTask);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852153\fstmerge_var2_3469711832469590193

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
public final CloseFuture closeAsync() {

        CloseFuture future = closeFuture.get();
        if (future != null)
            return future;

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852615\fstmerge_var1_3674927273446327502
        future = makeCloseFuture();
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852615\fstmerge_base_5529193252995989984
        // Wake up all threads that waits
        signalAllAvailableConnection();

        future = new CloseFuture.Forwarding(discardAvailableConnections());
=======
        phase = Phase.CLOSING;

        // Wake up all threads that wait
        signalAllAvailableConnection();

        future = new CloseFuture.Forwarding(discardAvailableConnections());
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612852615\fstmerge_var2_5817294954501873510

        return closeFuture.compareAndSet(null, future)
            ? future
            : closeFuture.get(); // We raced, it's ok, return the future that was actually set
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853068\fstmerge_var1_4599598199834387835
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853068\fstmerge_base_6356028850172467006
private List<CloseFuture> discardAvailableConnections() {
        // This can happen if creating the connections in the constructor fails
        if (connections == null)
            return Lists.newArrayList(CloseFuture.immediateFuture());

        List<CloseFuture> futures = new ArrayList<CloseFuture>(connections.size());
        for (final PooledConnection connection : connections) {
            CloseFuture future = connection.closeAsync();
            future.addListener(new Runnable() {
                public void run() {
                    if (connection.markForTrash.compareAndSet(false, true))
                        open.decrementAndGet();
                }
            }, MoreExecutors.sameThreadExecutor());
            futures.add(future);
        }
        return futures;
    }
=======
private List<CloseFuture> discardAvailableConnections() {
        // Note: if this gets called before initialization has completed, both connections and trash will be empty,
        // so this will return an empty list

        List<CloseFuture> futures = new ArrayList<CloseFuture>(connections.size() + trash.size());

        for (final Connection connection : connections) {
            CloseFuture future = connection.closeAsync();
            future.addListener(new Runnable() {
                public void run() {
                    if (connection.state.compareAndSet(OPEN, GONE))
                        open.decrementAndGet();
                }
            }, MoreExecutors.sameThreadExecutor());
            futures.add(future);
        }

        // Some connections in the trash might still be open if they hadn't reached their idle timeout
        for (Connection connection : trash)
            futures.add(connection.closeAsync());

        return futures;
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853068\fstmerge_var2_2128176277145384273

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853581\fstmerge_var1_7757249970356017048
abstract void returnConnection(PooledConnection connection);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853581\fstmerge_base_3280017671668212540
public void returnConnection(PooledConnection connection) {
        int inFlight = connection.inFlight.decrementAndGet();

        if (isClosed()) {
            close(connection);
            return;
        }

        if (connection.isDefunct()) {
            // As part of making it defunct, we have already replaced it or
            // closed the pool.
            return;
        }

        if (trash.contains(connection)) {
            if (inFlight == 0 && trash.remove(connection))
                close(connection);
        } else {
            if (connections.size() > options().getCoreConnectionsPerHost(hostDistance) && inFlight <= options().getMinSimultaneousRequestsPerConnectionThreshold(hostDistance)) {
                trashConnection(connection);
            } else if (connection.maxAvailableStreams() < MIN_AVAILABLE_STREAMS) {
                replaceConnection(connection);
            } else {
                signalAvailableConnection();
            }
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853581\fstmerge_var2_8038633120404204664

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853664\fstmerge_var1_2174564412494549549
abstract void replaceDefunctConnection(final PooledConnection connection);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853664\fstmerge_base_5835003441736734872
void replaceDefunctConnection(final PooledConnection connection) {
        if (connection.markForTrash.compareAndSet(false, true))
            open.decrementAndGet();
        connections.remove(connection);
        connection.closeAsync();
        manager.blockingExecutor().submit(new Runnable() {
            @Override
            public void run() {
                addConnectionIfUnderMaximum();
            }
        });
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612853664\fstmerge_var2_7652646569833923398

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612865018\fstmerge_var1_3037654712910458075
public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg) {
            assert msg instanceof Frame : "Expecting frame, got " + msg;

            Frame frame = (Frame)msg;
            boolean isTracing = frame.header.flags.contains(Frame.Header.Flag.TRACING);
            UUID tracingId = isTracing ? CBUtil.readUUID(frame.body) : null;

            Response response = Response.Type.fromOpcode(frame.header.opcode).decoder.decode(frame.body, frame.header.version);
            return response.setTracingId(tracingId).setStreamId(frame.header.streamId);
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612865018\fstmerge_base_2718688088426606056
public Object decode(ChannelHandlerContext ctx, Channel channel, Object msg) {
            assert msg instanceof Frame : "Expecting frame, got " + msg;

            Frame frame = (Frame)msg;
            boolean isTracing = frame.header.flags.contains(Frame.Header.Flag.TRACING);
            UUID tracingId = isTracing ? CBUtil.readUUID(frame.body) : null;

            Response response = Response.Type.fromOpcode(frame.header.opcode).decoder(frame.header.version).decode(frame.body);
            return response.setTracingId(tracingId).setStreamId(frame.header.streamId);
        }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612865018\fstmerge_var2_2410024541917800450

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Message.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612865100\fstmerge_var1_8777668047600239476
@SuppressWarnings("unchecked")
        public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) {
            assert msg instanceof Request : "Expecting request, got " + msg;

            Request request = (Request)msg;

            EnumSet<Frame.Header.Flag> flags = EnumSet.noneOf(Frame.Header.Flag.class);
            if (request.isTracingRequested())
                flags.add(Frame.Header.Flag.TRACING);

            Coder<Request> coder = (Coder<Request>)request.type.coder;
            ChannelBuffer body = ChannelBuffers.buffer(coder.encodedSize(request, protocolVersion));
            coder.encode(request, body, protocolVersion);

            return Frame.create(protocolVersion, request.type.opcode, request.getStreamId(), flags, body);
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612865100\fstmerge_base_978430132169345460
@SuppressWarnings("unchecked")
        public Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) {
            assert msg instanceof Request : "Expecting request, got " + msg;

            Request request = (Request)msg;

            EnumSet<Frame.Header.Flag> flags = EnumSet.noneOf(Frame.Header.Flag.class);
            if (request.isTracingRequested())
                flags.add(Frame.Header.Flag.TRACING);

            Coder<Request> coder = (Coder<Request>)request.type.coder(protocolVersion);
            ChannelBuffer body = ChannelBuffers.buffer(coder.encodedSize(request));
            coder.encode(request, body);

            return Frame.create(protocolVersion, request.type.opcode, request.getStreamId(), flags, body);
        }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612865100\fstmerge_var2_3911432863264989620

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Message.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
public Policies() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101728\fstmerge_var1_1241116376883917995
        this(defaultLoadBalancingPolicy(), defaultReconnectionPolicy(), defaultRetryPolicy(), defaultAddressTranslater(), defaultTimestampGenerator());
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101728\fstmerge_base_752288157086498278
        this(defaultLoadBalancingPolicy(), defaultReconnectionPolicy(), defaultRetryPolicy(), defaultAddressTranslater());
=======
        this(defaultLoadBalancingPolicy(), defaultReconnectionPolicy(), defaultRetryPolicy(),
            defaultAddressTranslater(), defaultSpeculativeExecutionPolicy());
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101728\fstmerge_var2_2280993771591778790
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\policies\Policies.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101817\fstmerge_var1_3718657121260671202
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy) {
        this(loadBalancingPolicy, reconnectionPolicy, retryPolicy, DEFAULT_ADDRESS_TRANSLATER, defaultTimestampGenerator());
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101817\fstmerge_base_3644780763124419656
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy) {
        this(loadBalancingPolicy, reconnectionPolicy, retryPolicy, DEFAULT_ADDRESS_TRANSLATER);
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101817\fstmerge_var2_6565261548323425135

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\policies\Policies.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101899\fstmerge_var1_1127418422893534126
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy,
                    AddressTranslater addressTranslater) {
        // NB: this constructor is provided for backward compatibility with 2.1.0
        this.loadBalancingPolicy = loadBalancingPolicy;
        this.reconnectionPolicy = reconnectionPolicy;
        this.retryPolicy = retryPolicy;
        this.addressTranslater = addressTranslater;
        this.timestampGenerator = defaultTimestampGenerator();
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101899\fstmerge_base_7059851662102228100
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy,
                    AddressTranslater addressTranslater) {
        this.loadBalancingPolicy = loadBalancingPolicy;
        this.reconnectionPolicy = reconnectionPolicy;
        this.retryPolicy = retryPolicy;
        this.addressTranslater = addressTranslater;
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613101899\fstmerge_var2_7600372936189550766

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\policies\Policies.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612880951\fstmerge_var1_2377474440715161493
public int getMinSimultaneousRequestsPerConnectionThreshold(HostDistance distance) {
        return minSimultaneousRequestsPerConnection[distance.ordinal()];
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612880951\fstmerge_base_2991954528908075784
public int getMinSimultaneousRequestsPerConnectionThreshold(HostDistance distance) {
        return minSimultaneousRequests[distance.ordinal()];
=======
@Deprecated
    public int getMinSimultaneousRequestsPerConnectionThreshold(HostDistance distance) {
        return 0;
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612880951\fstmerge_var2_7577224224528085129
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\PoolingOptions.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612881047\fstmerge_var1_5711269349446828463
public synchronized PoolingOptions setMinSimultaneousRequestsPerConnectionThreshold(HostDistance distance, int newMinSimultaneousRequests) {
        if (distance == HostDistance.IGNORED)
            throw new IllegalArgumentException("Cannot set min simultaneous requests per connection threshold for " + distance + " hosts");

        checkRequestsPerConnectionRange(newMinSimultaneousRequests, "Min simultaneous requests per connection", distance);
        checkRequestsPerConnectionOrder(newMinSimultaneousRequests, maxSimultaneousRequestsPerConnection[distance.ordinal()], distance);
        minSimultaneousRequestsPerConnection[distance.ordinal()] = newMinSimultaneousRequests;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612881047\fstmerge_base_3476536310119114918
public synchronized PoolingOptions setMinSimultaneousRequestsPerConnectionThreshold(HostDistance distance, int newMinSimultaneousRequests) {
        if (distance == HostDistance.IGNORED)
            throw new IllegalArgumentException("Cannot set min simultaneous requests per connection threshold for " + distance + " hosts");

        checkRequestsPerConnectionRange(newMinSimultaneousRequests, "Min simultaneous requests per connection", distance);
        checkRequestsPerConnectionOrder(newMinSimultaneousRequests, maxSimultaneousRequests[distance.ordinal()], distance);
        minSimultaneousRequests[distance.ordinal()] = newMinSimultaneousRequests;
=======
@Deprecated
    public synchronized PoolingOptions setMinSimultaneousRequestsPerConnectionThreshold(HostDistance distance, int newMinSimultaneousRequests) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612881047\fstmerge_var2_8316202392147120150
        return this;
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\PoolingOptions.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
public synchronized PoolingOptions setMaxSimultaneousRequestsPerConnectionThreshold(HostDistance distance, int newMaxSimultaneousRequests) {
        if (distance == HostDistance.IGNORED)
            throw new IllegalArgumentException("Cannot set max simultaneous requests per connection threshold for " + distance + " hosts");

        checkRequestsPerConnectionRange(newMaxSimultaneousRequests, "Max simultaneous requests per connection", distance);
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612881544\fstmerge_var1_5216052885996678219
        checkRequestsPerConnectionOrder(minSimultaneousRequestsPerConnection[distance.ordinal()], newMaxSimultaneousRequests, distance);
        maxSimultaneousRequestsPerConnection[distance.ordinal()] = newMaxSimultaneousRequests;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612881544\fstmerge_base_2251173441209475281
        checkRequestsPerConnectionOrder(minSimultaneousRequests[distance.ordinal()], newMaxSimultaneousRequests, distance);
        maxSimultaneousRequests[distance.ordinal()] = newMaxSimultaneousRequests;
=======
        maxSimultaneousRequests[distance.ordinal()] = newMaxSimultaneousRequests;
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612881544\fstmerge_var2_2670115867961744500
        return this;
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\PoolingOptions.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911559\fstmerge_var1_6390410913642191443
@Override
    public Message.Request request() {

        Message.Request request = callback.request();
        if (retryConsistencyLevel != null && retryConsistencyLevel != consistencyOf(request))
            request = manager.makeRequestMessage(statement, retryConsistencyLevel, serialConsistencyOf(request), pagingStateOf(request), defaultTimestampOf(request));
        return request;
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911559\fstmerge_base_7881523059381999046
@Override
    public Message.Request request() {

        Message.Request request = callback.request();
        if (retryConsistencyLevel != null && retryConsistencyLevel != consistencyOf(request))
            request = manager.makeRequestMessage(statement, retryConsistencyLevel, serialConsistencyOf(request), pagingStateOf(request));
        return request;
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911559\fstmerge_var2_6315497533855873885

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\RequestHandler.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911666\fstmerge_var1_4668713968520957373
private ConsistencyLevel consistencyOf(Message.Request request) {
        switch (request.type) {
            case QUERY:   return ((Requests.Query)request).options.consistency;
            case EXECUTE: return ((Requests.Execute)request).options.consistency;
            case BATCH:   return ((Requests.Batch)request).options.consistency;
            default:      return null;
        }
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911666\fstmerge_base_6413374660133998256
private ConsistencyLevel consistencyOf(Message.Request request) {
        switch (request.type) {
            case QUERY:   return ((Requests.Query)request).options.consistency;
            case EXECUTE: return ((Requests.Execute)request).options.consistency;
            case BATCH:   return ((Requests.Batch)request).consistency;
            default:      return null;
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911666\fstmerge_var2_7448299670750810215

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\RequestHandler.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911760\fstmerge_var1_6775134023085419933
private ConsistencyLevel serialConsistencyOf(Message.Request request) {
        switch (request.type) {
            case QUERY:   return ((Requests.Query)request).options.serialConsistency;
            case EXECUTE: return ((Requests.Execute)request).options.serialConsistency;
            case BATCH:   return ((Requests.Batch)request).options.serialConsistency;
            default:      return null;
        }
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911760\fstmerge_base_284554950899905974
private ConsistencyLevel serialConsistencyOf(Message.Request request) {
        switch (request.type) {
            case QUERY:   return ((Requests.Query)request).options.serialConsistency;
            case EXECUTE: return ((Requests.Execute)request).options.serialConsistency;
            default:      return null;
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612911760\fstmerge_var2_4249131593887598952

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\RequestHandler.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Coder<Startup> coder = new Message.Coder<Startup>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914735\fstmerge_var1_1597044931000128915
            public void encode(Startup msg, ChannelBuffer dest, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914735\fstmerge_base_7917379532727347237
            public void encode(Startup msg, ChannelBuffer dest) {
=======
            public void encode(Startup msg, ByteBuf dest) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914735\fstmerge_var2_956813034682979681
                CBUtil.writeStringMap(msg.options, dest);
            }

            public int encodedSize(Startup msg, ProtocolVersion version) {
                return CBUtil.sizeOfStringMap(msg.options);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Coder<Credentials> coder = new Message.Coder<Credentials>() {

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914851\fstmerge_var1_1702806470197820124
            public void encode(Credentials msg, ChannelBuffer dest, ProtocolVersion version) {
                assert version == ProtocolVersion.V1;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914851\fstmerge_base_4420299387298399514
            public void encode(Credentials msg, ChannelBuffer dest) {
=======
            public void encode(Credentials msg, ByteBuf dest) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914851\fstmerge_var2_7127062876975026826
                CBUtil.writeStringMap(msg.credentials, dest);
            }

            public int encodedSize(Credentials msg, ProtocolVersion version) {
                assert version == ProtocolVersion.V1;
                return CBUtil.sizeOfStringMap(msg.credentials);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Coder<Options> coder = new Message.Coder<Options>()
        {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914942\fstmerge_var1_7997347535143704166
            public void encode(Options msg, ChannelBuffer dest, ProtocolVersion version) {}
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914942\fstmerge_base_7416880826271021069
            public void encode(Options msg, ChannelBuffer dest) {}
=======
            public void encode(Options msg, ByteBuf dest) {}
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612914942\fstmerge_var2_5858560339118689758

            public int encodedSize(Options msg, ProtocolVersion version) {
                return 0;
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915038\fstmerge_var1_2821913379595571290
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915038\fstmerge_base_5896844759662608327
public static final Message.Coder<Query> coderV1 = new Message.Coder<Query>() {
            public void encode(Query msg, ChannelBuffer dest) {
                CBUtil.writeLongString(msg.query, dest);
                CBUtil.writeConsistencyLevel(msg.options.consistency, dest);
            }

            public int encodedSize(Query msg) {
                return CBUtil.sizeOfLongString(msg.query)
                     + CBUtil.sizeOfConsistencyLevel(msg.options.consistency);
            }
        };
=======
public static final Message.Coder<Query> coderV1 = new Message.Coder<Query>() {
            public void encode(Query msg, ByteBuf dest) {
                CBUtil.writeLongString(msg.query, dest);
                CBUtil.writeConsistencyLevel(msg.options.consistency, dest);
            }

            public int encodedSize(Query msg) {
                return CBUtil.sizeOfLongString(msg.query)
                     + CBUtil.sizeOfConsistencyLevel(msg.options.consistency);
            }
        };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915038\fstmerge_var2_4399455139955042022

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915121\fstmerge_var1_6962409462203246575
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915121\fstmerge_base_310704774547095158
public static final Message.Coder<Query> coderV2 = new Message.Coder<Query>() {
            public void encode(Query msg, ChannelBuffer dest) {
                CBUtil.writeLongString(msg.query, dest);
                msg.options.encode(dest);
            }

            public int encodedSize(Query msg) {
                return CBUtil.sizeOfLongString(msg.query)
                     + msg.options.encodedSize();
            }
        };
=======
public static final Message.Coder<Query> coderV2 = new Message.Coder<Query>() {
            public void encode(Query msg, ByteBuf dest) {
                CBUtil.writeLongString(msg.query, dest);
                msg.options.encode(dest);
            }

            public int encodedSize(Query msg) {
                return CBUtil.sizeOfLongString(msg.query)
                     + msg.options.encodedSize();
            }
        };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915121\fstmerge_var2_241528604849612561

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915207\fstmerge_var1_4620676847023569515
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915207\fstmerge_base_5829110194371815146
public static final Message.Coder<Execute> coderV1 = new Message.Coder<Execute>() {
            public void encode(Execute msg, ChannelBuffer dest) {
                CBUtil.writeBytes(msg.statementId.bytes, dest);
                CBUtil.writeValueList(msg.options.values, dest);
                CBUtil.writeConsistencyLevel(msg.options.consistency, dest);
            }

            public int encodedSize(Execute msg) {
                return CBUtil.sizeOfBytes(msg.statementId.bytes)
                     + CBUtil.sizeOfValueList(msg.options.values)
                     + CBUtil.sizeOfConsistencyLevel(msg.options.consistency);
            }
        };
=======
public static final Message.Coder<Execute> coderV1 = new Message.Coder<Execute>() {
            public void encode(Execute msg, ByteBuf dest) {
                CBUtil.writeBytes(msg.statementId.bytes, dest);
                CBUtil.writeValueList(msg.options.values, dest);
                CBUtil.writeConsistencyLevel(msg.options.consistency, dest);
            }

            public int encodedSize(Execute msg) {
                return CBUtil.sizeOfBytes(msg.statementId.bytes)
                     + CBUtil.sizeOfValueList(msg.options.values)
                     + CBUtil.sizeOfConsistencyLevel(msg.options.consistency);
            }
        };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915207\fstmerge_var2_181388128537723895

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915297\fstmerge_var1_3372651903562069441
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915297\fstmerge_base_1456364174194858666
public static final Message.Coder<Execute> coderV2 = new Message.Coder<Execute>() {
            public void encode(Execute msg, ChannelBuffer dest) {
                CBUtil.writeBytes(msg.statementId.bytes, dest);
                msg.options.encode(dest);
            }

            public int encodedSize(Execute msg) {
                return CBUtil.sizeOfBytes(msg.statementId.bytes)
                     + msg.options.encodedSize();
            }
        };
=======
public static final Message.Coder<Execute> coderV2 = new Message.Coder<Execute>() {
            public void encode(Execute msg, ByteBuf dest) {
                CBUtil.writeBytes(msg.statementId.bytes, dest);
                msg.options.encode(dest);
            }

            public int encodedSize(Execute msg) {
                return CBUtil.sizeOfBytes(msg.statementId.bytes)
                     + msg.options.encodedSize();
            }
        };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915297\fstmerge_var2_7945897525312629172

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Coder<Batch> coder = new Message.Coder<Batch>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915385\fstmerge_var1_1384963032462131869
            public void encode(Batch msg, ChannelBuffer dest, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915385\fstmerge_base_9083711798052051621
            public void encode(Batch msg, ChannelBuffer dest) {
=======
            public void encode(Batch msg, ByteBuf dest) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915385\fstmerge_var2_5527070418438733443
                int queries = msg.queryOrIdList.size();
                assert queries <= 0xFFFF;

                dest.writeByte(fromType(msg.type));
                dest.writeShort(queries);

                for (int i = 0; i < queries; i++) {
                    Object q = msg.queryOrIdList.get(i);
                    dest.writeByte((byte)(q instanceof String ? 0 : 1));
                    if (q instanceof String)
                        CBUtil.writeLongString((String)q, dest);
                    else
                        CBUtil.writeBytes(((MD5Digest)q).bytes, dest);

                    CBUtil.writeValueList(msg.values.get(i), dest);
                }

                msg.options.encode(dest, version);
            }

            public int encodedSize(Batch msg, ProtocolVersion version) {
                int size = 3; // type + nb queries
                for (int i = 0; i < msg.queryOrIdList.size(); i++) {
                    Object q = msg.queryOrIdList.get(i);
                    size += 1 + (q instanceof String
                        ? CBUtil.sizeOfLongString((String)q)
                        : CBUtil.sizeOfBytes(((MD5Digest)q).bytes));

                    size += CBUtil.sizeOfValueList(msg.values.get(i));
                }
                size += msg.options.encodedSize(version);
                return size;
            }

            private byte fromType(BatchStatement.Type type) {
                switch (type) {
                    case LOGGED:   return 0;
                    case UNLOGGED: return 1;
                    case COUNTER:  return 2;
                    default:       throw new AssertionError();
                }
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Coder<Prepare> coder = new Message.Coder<Prepare>() {

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915928\fstmerge_var1_873562707041239058
            public void encode(Prepare msg, ChannelBuffer dest, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915928\fstmerge_base_6724855503590169765
            public void encode(Prepare msg, ChannelBuffer dest) {
=======
            public void encode(Prepare msg, ByteBuf dest) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612915928\fstmerge_var2_5457504976334853766
                CBUtil.writeLongString(msg.query, dest);
            }

            public int encodedSize(Prepare msg, ProtocolVersion version) {
                return CBUtil.sizeOfLongString(msg.query);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Coder<Register> coder = new Message.Coder<Register>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612916017\fstmerge_var1_5709614842094651111
            public void encode(Register msg, ChannelBuffer dest, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612916017\fstmerge_base_6645456723645085107
            public void encode(Register msg, ChannelBuffer dest) {
=======
            public void encode(Register msg, ByteBuf dest) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612916017\fstmerge_var2_8353325672100756553
                dest.writeShort(msg.eventTypes.size());
                for (ProtocolEvent.Type type : msg.eventTypes)
                    CBUtil.writeEnumValue(type, dest);
            }

            public int encodedSize(Register msg, ProtocolVersion version) {
                int size = 2;
                for (ProtocolEvent.Type type : msg.eventTypes)
                    size += CBUtil.sizeOfEnumValue(type);
                return size;
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Coder<AuthResponse> coder = new Message.Coder<AuthResponse>() {

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612916104\fstmerge_var1_9199546078768082695
            public void encode(AuthResponse response, ChannelBuffer dest, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612916104\fstmerge_base_3044583634370774090
            public void encode(AuthResponse response, ChannelBuffer dest) {
=======
            public void encode(AuthResponse response, ByteBuf dest) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612916104\fstmerge_var2_583015725728673558
                CBUtil.writeValue(response.token, dest);
            }

            public int encodedSize(AuthResponse response, ProtocolVersion version) {
                return CBUtil.sizeOfValue(response.token);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Requests.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Error> decoder = new Message.Decoder<Error>() {
            @Override
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920269\fstmerge_var1_1033339040444368331
            public Error decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920269\fstmerge_base_980641420249587154
            public Error decode(ChannelBuffer body) {
=======
            public Error decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920269\fstmerge_var2_8053760500966533740
                ExceptionCode code = ExceptionCode.fromValue(body.readInt());
                String msg = CBUtil.readString(body);
                Object infos = null;
                switch (code) {
                    case UNAVAILABLE:
                        ConsistencyLevel clu = CBUtil.readConsistencyLevel(body);
                        int required = body.readInt();
                        int alive = body.readInt();
                        infos = new UnavailableException(clu, required, alive);
                        break;
                    case WRITE_TIMEOUT:
                    case READ_TIMEOUT:
                        ConsistencyLevel clt = CBUtil.readConsistencyLevel(body);
                        int received = body.readInt();
                        int blockFor = body.readInt();
                        if (code == ExceptionCode.WRITE_TIMEOUT) {
                            WriteType writeType = Enum.valueOf(WriteType.class, CBUtil.readString(body));
                            infos = new WriteTimeoutException(clt, writeType, received, blockFor);
                        } else {
                            byte dataPresent = body.readByte();
                            infos = new ReadTimeoutException(clt, received, blockFor, dataPresent != 0);
                        }
                        break;
                    case UNPREPARED:
                        infos = MD5Digest.wrap(CBUtil.readBytes(body));
                        break;
                    case ALREADY_EXISTS:
                        String ksName = CBUtil.readString(body);
                        String cfName = CBUtil.readString(body);
                        infos = new AlreadyExistsException(ksName, cfName);
                        break;
                }
                return new Error(version, code, msg, infos);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Ready> decoder = new Message.Decoder<Ready>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920865\fstmerge_var1_5391885870123076002
            public Ready decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920865\fstmerge_base_5961741078970597604
            public Ready decode(ChannelBuffer body) {
=======
            public Ready decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920865\fstmerge_var2_1836561527262700780
                // TODO: Would it be cool to return a singleton? Check we don't need to
                // set the streamId or something
                return new Ready();
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Authenticate> decoder = new Message.Decoder<Authenticate>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920997\fstmerge_var1_8733426851072967124
            public Authenticate decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920997\fstmerge_base_7650521340840605760
            public Authenticate decode(ChannelBuffer body) {
=======
            public Authenticate decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612920997\fstmerge_var2_1402043897077331909
                String authenticator = CBUtil.readString(body);
                return new Authenticate(authenticator);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Supported> decoder = new Message.Decoder<Supported>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921122\fstmerge_var1_1825912764417121846
            public Supported decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921122\fstmerge_base_3543816682037781394
            public Supported decode(ChannelBuffer body) {
=======
            public Supported decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921122\fstmerge_var2_7589849716893099673
                return new Supported(CBUtil.readStringToStringListMap(body));
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921235\fstmerge_var1_412050844153426072
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921235\fstmerge_base_6239532597191620579
public static final Message.Decoder<Result> decoderV1 = new Message.Decoder<Result>() {
            public Result decode(ChannelBuffer body) {
                Kind kind = Kind.fromId(body.readInt());
                return kind.subDecoderV1.decode(body);
            }
        };
=======
public static final Message.Decoder<Result> decoderV1 = new Message.Decoder<Result>() {
            public Result decode(ByteBuf body) {
                Kind kind = Kind.fromId(body.readInt());
                return kind.subDecoderV1.decode(body);
            }
        };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921235\fstmerge_var2_8230080107246258472

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921336\fstmerge_var1_8207495270741296614
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921336\fstmerge_base_6147741659942807714
public static final Message.Decoder<Result> decoderV2 = new Message.Decoder<Result>() {
            public Result decode(ChannelBuffer body) {
                Kind kind = Kind.fromId(body.readInt());
                return kind.subDecoderV2.decode(body);
            }
        };
=======
public static final Message.Decoder<Result> decoderV2 = new Message.Decoder<Result>() {
            public Result decode(ByteBuf body) {
                Kind kind = Kind.fromId(body.readInt());
                return kind.subDecoderV2.decode(body);
            }
        };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921336\fstmerge_var2_70565237103278350

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Result> subcodec = new Message.Decoder<Result>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921434\fstmerge_var1_2678929377182090369
                public Result decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921434\fstmerge_base_6718044390326564765
                public Result decode(ChannelBuffer body) {
=======
                public Result decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921434\fstmerge_var2_2286301356028386818
                    return new Void();
                }
            };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Result> subcodec = new Message.Decoder<Result>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921527\fstmerge_var1_268259342057810507
                public Result decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921527\fstmerge_base_1084613306577223667
                public Result decode(ChannelBuffer body) {
=======
                public Result decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921527\fstmerge_var2_8562881797382483725
                    return new SetKeyspace(CBUtil.readString(body));
                }
            };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Result> subcodec = new Message.Decoder<Result>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921615\fstmerge_var1_243170973702646422
                public Result decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921615\fstmerge_base_3561771694167848012
                public Result decode(ChannelBuffer body) {
=======
                public Result decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612921615\fstmerge_var2_2284436839290509572

                    Metadata metadata = Metadata.decode(body);

                    int rowCount = body.readInt();
                    int columnCount = metadata.columnCount;

                    Queue<List<ByteBuffer>> data = new ArrayDeque<List<ByteBuffer>>(rowCount);
                    for (int i = 0; i < rowCount; i++) {
                        List<ByteBuffer> row = new ArrayList<ByteBuffer>(columnCount);
                        for (int j = 0; j < columnCount; j++)
                            row.add(CBUtil.readValue(body));
                        data.add(row);
                    }

                    return new Rows(metadata, data);
                }
            };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922122\fstmerge_var1_9183184043716894023
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922122\fstmerge_base_6171151420852793357
public static final Message.Decoder<Result> subcodecV1 = new Message.Decoder<Result>() {
                public Result decode(ChannelBuffer body) {
                    MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
                    Rows.Metadata metadata = Rows.Metadata.decode(body);
                    return new Prepared(id, metadata, Rows.Metadata.EMPTY);
                }
            };
=======
public static final Message.Decoder<Result> subcodecV1 = new Message.Decoder<Result>() {
                public Result decode(ByteBuf body) {
                    MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
                    Rows.Metadata metadata = Rows.Metadata.decode(body);
                    return new Prepared(id, metadata, Rows.Metadata.EMPTY);
                }
            };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922122\fstmerge_var2_1095029149054486135

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922210\fstmerge_var1_3332210328265239827
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922210\fstmerge_base_7303281085520119408
public static final Message.Decoder<Result> subcodecV2 = new Message.Decoder<Result>() {
                public Result decode(ChannelBuffer body) {
                    MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
                    Rows.Metadata metadata = Rows.Metadata.decode(body);
                    Rows.Metadata resultMetadata = Rows.Metadata.decode(body);
                    return new Prepared(id, metadata, resultMetadata);
                }
            };
=======
public static final Message.Decoder<Result> subcodecV2 = new Message.Decoder<Result>() {
                public Result decode(ByteBuf body) {
                    MD5Digest id = MD5Digest.wrap(CBUtil.readBytes(body));
                    Rows.Metadata metadata = Rows.Metadata.decode(body);
                    Rows.Metadata resultMetadata = Rows.Metadata.decode(body);
                    return new Prepared(id, metadata, resultMetadata);
                }
            };
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922210\fstmerge_var2_662040649233480543

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Result> subcodec = new Message.Decoder<Result>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922306\fstmerge_var1_4017810960087132278
                public Result decode(ChannelBuffer body, ProtocolVersion version)
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922306\fstmerge_base_7781372167885989086
                public Result decode(ChannelBuffer body)
=======
                public Result decode(ByteBuf body)
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922306\fstmerge_var2_2235137744049832781
                {
                    // Note: the CREATE KEYSPACE/TABLE/TYPE SCHEMA_CHANGE response is different from the SCHEMA_CHANGE EVENT type
                    Change change;
                    Target target;
                    String keyspace, name;
                    switch (version) {
                        case V1:
                        case V2:
                            change = CBUtil.readEnumValue(Change.class, body);
                            keyspace = CBUtil.readString(body);
                            name = CBUtil.readString(body);
                            target = name.isEmpty() ? Target.KEYSPACE : Target.TABLE;
                            return new SchemaChange(change, target, keyspace, name);
                        case V3:
                            change = CBUtil.readEnumValue(Change.class, body);
                            target = CBUtil.readEnumValue(Target.class, body);
                            keyspace = CBUtil.readString(body);
                            name = (target == Target.KEYSPACE) ? "" : CBUtil.readString(body);
                            return new SchemaChange(change, target, keyspace, name);
                        default:
                            throw version.unsupported();
                    }
                }

                private Target maybeReadTarget(ChannelBuffer body, ProtocolVersion version) {
                    switch (version) {
                        case V1:
                        case V2:
                            return null;
                        case V3:
                            return CBUtil.readEnumValue(Target.class, body);
                        default:
                            throw version.unsupported();
                    }
                }
            };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<Event> decoder = new Message.Decoder<Event>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922924\fstmerge_var1_841127922531695028
            public Event decode(ChannelBuffer body, ProtocolVersion version) {
                return new Event(ProtocolEvent.deserialize(body, version));
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922924\fstmerge_base_9209517080176207202
            public Event decode(ChannelBuffer body) {
                return new Event(ProtocolEvent.deserialize(body));
=======
            public Event decode(ByteBuf body) {
                return new Event(ProtocolEvent.deserialize(body));
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612922924\fstmerge_var2_5175034924079172250
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<AuthChallenge> decoder = new Message.Decoder<AuthChallenge>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612923015\fstmerge_var1_8971602652225123428
            public AuthChallenge decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612923015\fstmerge_base_3770082967311506804
            public AuthChallenge decode(ChannelBuffer body) {
=======
            public AuthChallenge decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612923015\fstmerge_var2_68321761290536739
                ByteBuffer b = CBUtil.readValue(body);
                if (b == null)
                    return new AuthChallenge(null);

                byte[] token = new byte[b.remaining()];
                b.get(token);
                return new AuthChallenge(token);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
public static final Message.Decoder<AuthSuccess> decoder = new Message.Decoder<AuthSuccess>() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612923105\fstmerge_var1_8077521555042105929
            public AuthSuccess decode(ChannelBuffer body, ProtocolVersion version) {
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612923105\fstmerge_base_4101514751276386398
            public AuthSuccess decode(ChannelBuffer body) {
=======
            public AuthSuccess decode(ByteBuf body) {
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612923105\fstmerge_var2_1009403710915217454
                ByteBuffer b = CBUtil.readValue(body);
                if (b == null)
                    return new AuthSuccess(null);

                byte[] token = new byte[b.remaining()];
                b.get(token);
                return new AuthSuccess(token);
            }
        };

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\Responses.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612940029\fstmerge_var1_6475869762304436194
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612940029\fstmerge_base_3449426654338116631
Message.Request makeRequestMessage(Statement statement, ConsistencyLevel cl, ConsistencyLevel scl, ByteBuffer pagingState) {
        int protoVersion = cluster.manager.protocolVersion();
        int fetchSize = statement.getFetchSize();

        if (protoVersion == 1) {
            assert pagingState == null;
            // We don't let the user change the fetchSize globally if the proto v1 is used, so we just need to
            // check for the case of a per-statement override
            if (fetchSize <= 0)
                fetchSize = -1;
            else if (fetchSize != Integer.MAX_VALUE)
                throw new UnsupportedFeatureException("Paging is not supported");
        } else if (fetchSize <= 0) {
            fetchSize = configuration().getQueryOptions().getFetchSize();
        }

        if (fetchSize == Integer.MAX_VALUE)
            fetchSize = -1;

        if (statement instanceof RegularStatement) {
            RegularStatement rs = (RegularStatement)statement;

            // It saddens me that we special case for the query builder here, but for now this is simpler.
            // We could provide a general API in RegularStatement instead at some point but it's unclear what's
            // the cleanest way to do that is right now (and it's probably not really that useful anyway).
            if (protoVersion == 1 && rs instanceof com.datastax.driver.core.querybuilder.BuiltStatement)
                ((com.datastax.driver.core.querybuilder.BuiltStatement)rs).setForceNoValues(true);

            ByteBuffer[] rawValues = rs.getValues();

            if (protoVersion == 1 && rawValues != null)
                throw new UnsupportedFeatureException("Binary values are not supported");

            List<ByteBuffer> values = rawValues == null ? Collections.<ByteBuffer>emptyList() : Arrays.asList(rawValues);
            String qString = rs.getQueryString();
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, values, false, fetchSize, pagingState, scl);
            return new Requests.Query(qString, options);
        } else if (statement instanceof BoundStatement) {
            BoundStatement bs = (BoundStatement)statement;
            boolean skipMetadata = protoVersion != 1 && bs.statement.getPreparedId().resultSetMetadata != null;
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, Arrays.asList(bs.values), skipMetadata, fetchSize, pagingState, scl);
            return new Requests.Execute(bs.statement.getPreparedId().id, options);
        } else {
            assert statement instanceof BatchStatement : statement;
            assert pagingState == null;

            if (protoVersion == 1)
                throw new UnsupportedFeatureException("Protocol level batching is not supported");

            BatchStatement bs = (BatchStatement)statement;
            BatchStatement.IdAndValues idAndVals = bs.getIdAndValues();
            return new Requests.Batch(bs.batchType, idAndVals.ids, idAndVals.values, cl);
        }
    }
=======
Message.Request makeRequestMessage(Statement statement, ConsistencyLevel cl, ConsistencyLevel scl, ByteBuffer pagingState) {
        int protoVersion = cluster.manager.protocolVersion();
        int fetchSize = statement.getFetchSize();
        ByteBuffer usedPagingState = pagingState;

        if (protoVersion == 1) {
            assert pagingState == null;
            // We don't let the user change the fetchSize globally if the proto v1 is used, so we just need to
            // check for the case of a per-statement override
            if (fetchSize <= 0)
                fetchSize = -1;
            else if (fetchSize != Integer.MAX_VALUE)
                throw new UnsupportedFeatureException("Paging is not supported");
        } else if (fetchSize <= 0) {
            fetchSize = configuration().getQueryOptions().getFetchSize();
        }

        if (fetchSize == Integer.MAX_VALUE)
            fetchSize = -1;

        if (pagingState == null) {
            usedPagingState = statement.getPagingState();
        }

        if (statement instanceof StatementWrapper)
            statement = ((StatementWrapper)statement).getWrappedStatement();

        if (statement instanceof RegularStatement) {
            RegularStatement rs = (RegularStatement)statement;

            // It saddens me that we special case for the query builder here, but for now this is simpler.
            // We could provide a general API in RegularStatement instead at some point but it's unclear what's
            // the cleanest way to do that is right now (and it's probably not really that useful anyway).
            if (protoVersion == 1 && rs instanceof com.datastax.driver.core.querybuilder.BuiltStatement)
                ((com.datastax.driver.core.querybuilder.BuiltStatement)rs).setForceNoValues(true);

            ByteBuffer[] rawValues = rs.getValues();

            if (protoVersion == 1 && rawValues != null)
                throw new UnsupportedFeatureException("Binary values are not supported");

            List<ByteBuffer> values = rawValues == null ? Collections.<ByteBuffer>emptyList() : Arrays.asList(rawValues);
            String qString = rs.getQueryString();
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, values, false, fetchSize, usedPagingState, scl);
            return new Requests.Query(qString, options);
        } else if (statement instanceof BoundStatement) {
            BoundStatement bs = (BoundStatement)statement;
            if (!cluster.manager.preparedQueries.containsKey(bs.statement.getPreparedId().id)) {
                throw new InvalidQueryException(String.format("Tried to execute unknown prepared query : %s. "
                    + "You may have used a PreparedStatement that was created with another Cluster instance.", bs.statement.getPreparedId().id));
            }
            boolean skipMetadata = protoVersion != 1 && bs.statement.getPreparedId().resultSetMetadata != null;
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, Arrays.asList(bs.values), skipMetadata, fetchSize, usedPagingState, scl);
            return new Requests.Execute(bs.statement.getPreparedId().id, options);
        } else {
            assert statement instanceof BatchStatement : statement;
            assert pagingState == null;

            if (protoVersion == 1)
                throw new UnsupportedFeatureException("Protocol level batching is not supported");

            BatchStatement bs = (BatchStatement)statement;
            BatchStatement.IdAndValues idAndVals = bs.getIdAndValues();
            return new Requests.Batch(bs.batchType, idAndVals.ids, idAndVals.values, cl);
        }
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612940029\fstmerge_var2_3898266818798056984

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
private State(SessionManager session) {
            this.session = session;
            this.connectedHosts = ImmutableList.copyOf(session.pools.keySet());

            this.openConnections = new int[connectedHosts.size()];
            this.trashedConnections = new int[connectedHosts.size()];
            this.inFlightQueries = new int[connectedHosts.size()];

            int i = 0;
            for (Host h : connectedHosts) {
                HostConnectionPool p = session.pools.get(h);
                // It's possible we race and the host has been removed since the beginning of this
                // functions. In that case, the fact it's part of getConnectedHosts() but has no opened
                // connections will be slightly weird, but it's unlikely enough that we don't bother avoiding.
                if (p == null) {
                    openConnections[i] = 0;
                    trashedConnections[i] = 0;
                    inFlightQueries[i] = 0;
                    continue;
                }

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941056\fstmerge_var1_6031180489961964174
                openConnections[i] = p.opened();
                inFlightQueries[i] = p.inFlightQueriesCount();
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941056\fstmerge_base_2976909436311978041
                openConnections[i] = p.connections.size();
                for (Connection c : p.connections) {
                    inFlightQueries[i] += c.inFlight.get();
                }
=======
                openConnections[i] = p.connections.size();
                trashedConnections[i] = p.trash.size();
                inFlightQueries[i] = p.totalInFlight.get();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941056\fstmerge_var2_8269358570974697703
                i++;
            }
        }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941154\fstmerge_var1_6732885173958247795
ListenableFuture<Boolean> forceRenewPool(final Host host, ListeningExecutorService executor) {
        final HostDistance distance = cluster.manager.loadBalancingPolicy().distance(host);
        if (distance == HostDistance.IGNORED)
            return Futures.immediateFuture(true);

        // Creating a pool is somewhat long since it has to create the connection, so do it asynchronously.
        return executor.submit(new Callable<Boolean>() {
            public Boolean call() {
                while (true) {
                    try {
                        if (isClosing)
                            return true;

                        HostConnectionPool newPool = HostConnectionPool.newInstance(host, distance, SessionManager.this,
                                                                                    cluster.getConfiguration().getProtocolOptions().getProtocolVersionEnum());
                        HostConnectionPool previous = pools.put(host, newPool);
                        if (previous == null) {
                            logger.debug("Added connection pool for {}", host);
                        } else {
                            logger.debug("Renewed connection pool for {}", host);
                            previous.closeAsync();
                        }

                        // If we raced with a session shutdown, ensure that the pool will be closed.
                        if (isClosing)
                            newPool.closeAsync();

                        return true;
                    } catch (Exception e) {
                        logger.error("Error creating pool to " + host, e);
                        return false;
                    }
                }
            }
        });
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941154\fstmerge_base_4156334492051217243
ListenableFuture<Boolean> forceRenewPool(final Host host, ListeningExecutorService executor) {
        final HostDistance distance = cluster.manager.loadBalancingPolicy().distance(host);
        if (distance == HostDistance.IGNORED)
            return Futures.immediateFuture(true);

        // Creating a pool is somewhat long since it has to create the connection, so do it asynchronously.
        return executor.submit(new Callable<Boolean>() {
            public Boolean call() {
                while (true) {
                    try {
                        if (isClosing)
                            return true;

                        HostConnectionPool newPool = new HostConnectionPool(host, distance, SessionManager.this);
                        HostConnectionPool previous = pools.put(host, newPool);
                        if (previous == null) {
                            logger.debug("Added connection pool for {}", host);
                        } else {
                            logger.debug("Renewed connection pool for {}", host);
                            previous.closeAsync();
                        }

                        // If we raced with a session shutdown, ensure that the pool will be closed.
                        if (isClosing)
                            newPool.closeAsync();

                        return true;
                    } catch (Exception e) {
                        logger.error("Error creating pool to " + host, e);
                        return false;
                    }
                }
            }
        });
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941154\fstmerge_var2_3945637343295469032

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941263\fstmerge_var1_243400834715634090
private boolean replacePool(Host host, HostDistance distance, HostConnectionPool condition) throws ConnectionException, UnsupportedProtocolVersionException, ClusterNameMismatchException {
        if (isClosing)
            return true;

        Lock l = poolCreationLocks.get(host);
        l.lock();
        try {
            HostConnectionPool previous = pools.get(host);
            if (previous != condition)
                return false;

            HostConnectionPool newPool = HostConnectionPool.newInstance(host, distance, SessionManager.this,
                                                                        cluster.getConfiguration().getProtocolOptions().getProtocolVersionEnum());
            previous = pools.put(host, newPool);
            if (previous != null && !previous.isClosed()) {
                logger.warn("Replacing a pool that wasn't closed. Closing it now, but this was not expected.");
                previous.closeAsync();
            }

            // If we raced with a session shutdown, ensure that the pool will be closed.
            if (isClosing)
                newPool.closeAsync();

            return true;
        } finally {
            l.unlock();
        }
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941263\fstmerge_base_6581890409490644694
private boolean replacePool(Host host, HostDistance distance, HostConnectionPool condition) throws ConnectionException, UnsupportedProtocolVersionException, ClusterNameMismatchException {
        if (isClosing)
            return true;

        Lock l = poolCreationLocks.get(host);
        l.lock();
        try {
            HostConnectionPool previous = pools.get(host);
            if (previous != condition)
                return false;

            HostConnectionPool newPool = new HostConnectionPool(host, distance, this);
            previous = pools.put(host, newPool);
            if (previous != null && !previous.isClosed()) {
                logger.warn("Replacing a pool that wasn't closed. Closing it now, but this was not expected.");
                previous.closeAsync();
            }

            // If we raced with a session shutdown, ensure that the pool will be closed.
            if (isClosing)
                newPool.closeAsync();

            return true;
        } finally {
            l.unlock();
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941263\fstmerge_var2_1486027754439806542

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941354\fstmerge_var1_7732955432200822281
ListenableFuture<Boolean> maybeAddPool(final Host host, ListeningExecutorService executor) {
        final HostDistance distance = cluster.manager.loadBalancingPolicy().distance(host);
        if (distance == HostDistance.IGNORED)
            return Futures.immediateFuture(true);

        HostConnectionPool previous = pools.get(host);
        if (previous != null && !previous.isClosed())
            return Futures.immediateFuture(true);

        // Creating a pool is somewhat long since it has to create the connection, so do it asynchronously.
        return executor.submit(new Callable<Boolean>() {
            public Boolean call() {
                try {
                    while (true) {
                        HostConnectionPool previous = pools.get(host);
                        if (previous != null && !previous.isClosed())
                            return true;

                        if (replacePool(host, distance, previous)) {
                            logger.debug("Added connection pool for {}", host);
                            return true;
                        }
                    }
                } catch (UnsupportedProtocolVersionException e) {
                    cluster.manager.logUnsupportedVersionProtocol(host, e.unsupportedVersion);
                    cluster.manager.triggerOnDown(host, false);
                    return false;
                } catch (ClusterNameMismatchException e) {
                    cluster.manager.logClusterNameMismatch(host, e.expectedClusterName, e.actualClusterName);
                    cluster.manager.triggerOnDown(host, false);
                    return false;
                } catch (Exception e) {
                    logger.error("Error creating pool to " + host, e);
                    return false;
                }
            }
        });
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941354\fstmerge_base_8812799785174802912
ListenableFuture<Boolean> maybeAddPool(final Host host, ListeningExecutorService executor) {
        final HostDistance distance = cluster.manager.loadBalancingPolicy().distance(host);
        if (distance == HostDistance.IGNORED)
            return Futures.immediateFuture(true);

        HostConnectionPool previous = pools.get(host);
        if (previous != null && !previous.isClosed())
            return Futures.immediateFuture(true);

        // Creating a pool is somewhat long since it has to create the connection, so do it asynchronously.
        return executor.submit(new Callable<Boolean>() {
            public Boolean call() {
                try {
                    while (true) {
                        HostConnectionPool previous = pools.get(host);
                        if (previous != null && !previous.isClosed())
                            return true;

                        if (replacePool(host, distance, previous)) {
                            logger.debug("Added connection pool for {}", host);
                            return true;
                        }
                    }
                } catch (UnsupportedProtocolVersionException e) {
                    cluster.manager.logUnsupportedVersionProtocol(host);
                    cluster.manager.triggerOnDown(host, false);
                    return false;
                } catch (ClusterNameMismatchException e) {
                    cluster.manager.logClusterNameMismatch(host, e.expectedClusterName, e.actualClusterName);
                    cluster.manager.triggerOnDown(host, false);
                    return false;
                } catch (Exception e) {
                    logger.error("Error creating pool to " + host, e);
                    return false;
                }
            }
        });
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513612941354\fstmerge_var2_898392059009880366

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 12
Different Spacing: 5
Consecutive Lines: 3
Intersection: 2
Cause same signature: 
Possible renaming: 0
EditSameMCType: 12, 0, 0
Conflict body: 
@Test(groups = "short")
    public void connectionLeakTest() throws Exception {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
        CCMBridge ccm = null;
        Cluster cluster = null;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
        // Checking for JAVA-342
        CCMBridge ccmBridge;
        ccmBridge = CCMBridge.create("test", 1);
=======
        // Checking for JAVA-342
        CCMBridge ccmBridge;
        ccmBridge = CCMBridge.create("test", 1);
        Cluster cluster = null;
        SocketChannelMonitor channelMonitor = new SocketChannelMonitor();
        channelMonitor.reportAtFixedInterval(1, TimeUnit.SECONDS);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
        try {
            ccm = CCMBridge.create("test", 1);

            // create a new cluster object and ensure 0 sessions and connections
            cluster = Cluster.builder().addContactPoints(CCMBridge.IP_PREFIX + '1').build();

||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
        // give the driver time to close other sessions in this class
        //Thread.sleep(10);

        // create a new cluster object and ensure 0 sessions and connections
        Cluster cluster = Cluster.builder().addContactPoints(CCMBridge.IP_PREFIX + '1').build();

        int corePoolSize = cluster.getConfiguration()
                .getPoolingOptions()
                .getCoreConnectionsPerHost(HostDistance.LOCAL);
=======
        List<InetSocketAddress> nodes = Lists.newArrayList(
                new InetSocketAddress(CCMBridge.IP_PREFIX + '1', 9042),
                new InetSocketAddress(CCMBridge.IP_PREFIX + '2', 9042));
        try {
            // create a new cluster object and ensure 0 sessions and connections
            cluster = Cluster.builder()
                    .addContactPointsWithPorts(Collections.singletonList(
                            new InetSocketAddress(CCMBridge.IP_PREFIX + '1', 9042)))
                    .withNettyOptions(channelMonitor.nettyOptions()).build();
            cluster.init();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int)cluster.getMetrics().getOpenConnections().getValue(), 0);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 0);
=======
            int corePoolSize = cluster.getConfiguration()
                    .getPoolingOptions()
                    .getCoreConnectionsPerHost(HostDistance.LOCAL);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            // ensure sessions.size() returns with 1 control connection + core pool size.
            Session session = cluster.connect();
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
        // ensure sessions.size() returns with 1 control connection + core pool size.
        Session session = cluster.connect();
        assertEquals(cluster.manager.sessions.size(), 1);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);
=======
            assertEquals(cluster.manager.sessions.size(), 0);
            // Should be 1 control connection after initialization.
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            assertEquals(channelMonitor.openChannels(nodes).size(), 1);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            // Special check for protocol version 3, number of connections should be 1.
            int corePoolSize = TestUtils.numberOfLocalCoreConnections(cluster);

            assertEquals(cluster.manager.sessions.size(), 1);
            assertEquals((int)cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);

            // ensure sessions.size() returns to 0 with only 1 active connection (the control connection)
            session.close();
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int)cluster.getMetrics().getOpenConnections().getValue(), 1);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
        // ensure sessions.size() returns to 0 with only 1 active connection (the control connection)
        session.close();
        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
=======
            // ensure sessions.size() returns with 1 control connection + core pool size.
            Session session = cluster.connect();
            assertEquals(cluster.manager.sessions.size(), 1);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);
            assertEquals(channelMonitor.openChannels(nodes).size(), 1 + corePoolSize);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            Session thisSession;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
        try {
            Session thisSession;
=======
            // ensure sessions.size() returns to 0 with only 1 active connection (the control connection)
            session.close();
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            assertEquals(channelMonitor.openChannels(nodes).size(), 1);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

            // ensure bootstrapping a node does not create additional connections
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038

            ccm.bootstrapNode(2);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593


            ccmBridge.bootstrapNode(2);
=======
            ccmBridge.bootstrapNode(2);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762
            assertEquals(cluster.manager.sessions.size(), 0);
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            assertEquals((int)cluster.getMetrics().getOpenConnections().getValue(), 1);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
=======
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            assertEquals(channelMonitor.openChannels(nodes).size(), 1);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

            // ensure a new session gets registered and core connections are established
            // there should be corePoolSize more connections to accommodate for the new host.
            Session thisSession = cluster.connect();
            assertEquals(cluster.manager.sessions.size(), 1);

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            assertEquals((int)cluster.getMetrics().getOpenConnections().getValue(), 1 + (corePoolSize * 2));
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + (corePoolSize * 2));
=======
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + (corePoolSize * 2));
            assertEquals(channelMonitor.openChannels(nodes).size(), 1 + (corePoolSize * 2));
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762

            // ensure bootstrapping a node does not create additional connections that won't get cleaned up
            thisSession.close();

            assertEquals(cluster.manager.sessions.size(), 0);
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038

            assertEquals((int)cluster.getMetrics().getOpenConnections().getValue(), 1);

||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593

            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);


=======
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            assertEquals(channelMonitor.openChannels(nodes).size(), 1);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762
        } finally {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            if (cluster != null)
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593
            // ensure we decommission node2 for the rest of the tests

            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

            if(cluster != null){
=======
            if(cluster != null){
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762
                cluster.close();
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var1_1894906492724086038
            if (ccm != null)
                ccm.remove();
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_base_2452869818191772593

            }

            if (ccmBridge != null) {
                ccmBridge.remove();
            }


=======
            }
            if (ccmBridge != null) {
                ccmBridge.remove();
            }
            // Ensure no channels remain open.
            channelMonitor.stop();
            channelMonitor.report();
            assertEquals(channelMonitor.openChannels(nodes).size(), 0);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613232035\fstmerge_var2_6025570272114886762
        }
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\test\java\com\datastax\driver\core\SessionLeakTest.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613234598\fstmerge_var1_3760371402739496553
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613234598\fstmerge_base_6687951840169808658
@Test(groups = "long")
    public void sessionMemoryLeakTest() throws Exception {
        // Checking for JAVA-342

        // give the driver time to close other sessions in this class
        Thread.sleep(10);

        // create a new cluster object and ensure 0 sessions and connections
        int corePoolSize = 2;
        PoolingOptions poolingOptions = new PoolingOptions()
                .setCoreConnectionsPerHost(HostDistance.LOCAL, corePoolSize);
        Cluster cluster = Cluster.builder()
                .addContactPointsWithPorts(Collections.singletonList(hostAddress))
                .withPoolingOptions(poolingOptions)
                .build();

        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 0);

        Session session = cluster.connect();
        assertEquals(cluster.manager.sessions.size(), 1);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);

        // ensure sessions.size() returns to 0 with only 1 active connection
        session.close();
        assertEquals(cluster.manager.sessions.size(), 0);
        assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

        // give the driver time to close sessions
        Thread.sleep(10);

        try {
            for (int i = 0; i < 10000; ++i) {
                // ensure 0 sessions with a single control connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);

                // ensure a new session gets registered and control connections are established
                session = cluster.connect();
                assertEquals(cluster.manager.sessions.size(), 1);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);
                session.close();

                // give the driver time to close sessions
                Thread.sleep(10);

                // ensure sessions.size() always returns to 0 with only 1 active connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            }
        } finally {
            cluster.close();
        }
    }
=======
@Test(groups = "long")
    public void sessionMemoryLeakTest() throws Exception {
        // Checking for JAVA-342

        // give the driver time to close other sessions in this class
        Thread.sleep(10);

        // create a new cluster object and ensure 0 sessions and connections
        int corePoolSize = 2;
        SocketChannelMonitor channelMonitor = new SocketChannelMonitor();
        channelMonitor.reportAtFixedInterval(1, TimeUnit.SECONDS);
        PoolingOptions poolingOptions = new PoolingOptions()
                .setCoreConnectionsPerHost(HostDistance.LOCAL, corePoolSize);
        Collection<InetSocketAddress> contactPoints = Collections.singletonList(hostAddress);
        Cluster cluster = Cluster.builder()
                .addContactPointsWithPorts(contactPoints)
                .withPoolingOptions(poolingOptions)
                .withNettyOptions(channelMonitor.nettyOptions())
                .build();

        try {
            cluster.init();

            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            assertEquals(channelMonitor.openChannels(contactPoints).size(), 1);

            Session session = cluster.connect();
            assertEquals(cluster.manager.sessions.size(), 1);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);
            assertEquals(channelMonitor.openChannels(contactPoints).size(), 1 + corePoolSize);

            // ensure sessions.size() returns to 0 with only 1 active connection
            session.close();
            assertEquals(cluster.manager.sessions.size(), 0);
            assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
            assertEquals(channelMonitor.openChannels(contactPoints).size(), 1);

            // give the driver time to close sessions
            Thread.sleep(10);

            for (int i = 0; i < 10000; ++i) {
                // ensure 0 sessions with a single control connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
                assertEquals(channelMonitor.openChannels(contactPoints).size(), 1);

                // ensure a new session gets registered and control connections are established
                session = cluster.connect();
                assertEquals(cluster.manager.sessions.size(), 1);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1 + corePoolSize);
                assertEquals(channelMonitor.openChannels(contactPoints).size(), 1 + corePoolSize);
                session.close();

                // give the driver time to close sessions
                Thread.sleep(10);

                // ensure sessions.size() always returns to 0 with only 1 active connection
                assertEquals(cluster.manager.sessions.size(), 0);
                assertEquals((int) cluster.getMetrics().getOpenConnections().getValue(), 1);
                assertEquals(channelMonitor.openChannels(contactPoints).size(), 1);
            }
        } finally {
            cluster.close();
            // Ensure no channels remain open.
            channelMonitor.stop();
            channelMonitor.report();
            assertEquals(channelMonitor.openChannels(contactPoints).size(), 0);
        }
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613234598\fstmerge_var2_4076514335181361368

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\test\java\com\datastax\driver\core\SessionTest.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: noPattern
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613258989\fstmerge_var1_5410447194603067278
public static int numberOfLocalCoreConnections(Cluster cluster) {
        Configuration configuration = cluster.getConfiguration();
        ProtocolVersion protocolVersion = configuration.getProtocolOptions().getProtocolVersionEnum();
        return (protocolVersion.compareTo(ProtocolVersion.V3) < 0)
            ? configuration.getPoolingOptions().getCoreConnectionsPerHost(HostDistance.LOCAL)
            : 1;
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613258989\fstmerge_base_2162544754848418489
=======
public static int numberOfLocalCoreConnections(Cluster cluster) {
        Configuration configuration = cluster.getConfiguration();
        return configuration.getPoolingOptions().getCoreConnectionsPerHost(HostDistance.LOCAL);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613258989\fstmerge_var2_4954834541887015432

File path: C:\download\ssmerge\java-driver\revisions\rev_b336e_74285\rev_rev_left_b336e-rev_right_74285\driver-core\src\test\java\com\datastax\driver\core\TestUtils.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_4eb30_d5ed5\rev_4eb30-d5ed5.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_74285_82693\rev_74285-82693.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b4a74_ab4cf\rev_b4a74-ab4cf.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_93a2e_d5f9a\rev_93a2e-d5f9a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_19f1f_8b3d9\rev_19f1f-8b3d9.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_d41a0_12f88\rev_d41a0-12f88.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_af402_c3ea6\rev_af402-c3ea6.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_3ffa8_3f1d5\rev_3ffa8-3f1d5.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613816267\fstmerge_var1_825937268404637003
@Override
    public Object getObject(String name) {
        return getObject(getIndexOf(name));
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613816267\fstmerge_base_1861025291776754177
public Object getObject(String name) {
        return getValue(metadata.getFirstIdx(name));
=======
public Object getObject(String name) {
        return getObject(metadata.getFirstIdx(name));
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613816267\fstmerge_var2_5004106861778940030
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_3ffa8_3f1d5\rev_rev_left_3ffa8-rev_right_3f1d5\driver-core\src\main\java\com\datastax\driver\core\AbstractGettableData.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613886949\fstmerge_var1_3764126796137957519
protected final AtomicReference<Phase> phase = new AtomicReference<Phase>(Phase.INITIALIZING);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613886949\fstmerge_base_5131846445624562956
private volatile Phase phase = Phase.INITIALIZING;
=======
private final AtomicReference<Phase> phase = new AtomicReference<Phase>(Phase.INITIALIZING);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613886949\fstmerge_var2_4246935501625961092

File path: C:\download\ssmerge\java-driver\revisions\rev_3ffa8_3f1d5\rev_rev_left_3ffa8-rev_right_3f1d5\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887386\fstmerge_var1_22794306353515384
abstract ListenableFuture<Void> initAsync(Connection reusedConnection);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887386\fstmerge_base_1635255864257810589
public ListenableFuture<Void> initAsync(Connection reusedConnection) {
        // Create initial core connections
        int capacity = options().getCoreConnectionsPerHost(hostDistance);
        final List<Connection> connections = Lists.newArrayListWithCapacity(capacity);
        final List<ListenableFuture<Void>> connectionFutures = Lists.newArrayListWithCapacity(capacity);
        for (int i = 0; i < capacity; i++) {
            Connection connection;
            ListenableFuture<Void> connectionFuture;
            // reuse the existing connection only once
            if (reusedConnection != null && reusedConnection.setPool(this)) {
                connection = reusedConnection;
                connectionFuture = MoreFutures.VOID_SUCCESS;
            } else {
                connection = manager.connectionFactory().newConnection(this);
                connectionFuture = connection.initAsync();
            }
            reusedConnection = null;
            connections.add(connection);
            connectionFutures.add(connectionFuture);
        }

        Executor initExecutor = manager.cluster.manager.configuration.getPoolingOptions().getInitializationExecutor();

        ListenableFuture<List<Void>> allConnectionsFuture = Futures.allAsList(connectionFutures);

        final SettableFuture<Void> initFuture = SettableFuture.create();
        Futures.addCallback(allConnectionsFuture, new FutureCallback<List<Void>>() {
            @Override
            public void onSuccess(List<Void> l) {
                HostConnectionPool.this.connections.addAll(connections);
                open.set(l.size());
                if (isClosed()) {
                    initFuture.setException(new ConnectionException(host.getSocketAddress(), "Pool was closed during initialization"));
                    // we're not sure if closeAsync() saw the connections, so ensure they get closed
                    forceClose(connections);
                } else {
                    logger.trace("Created connection pool to host {}", host);
                    phase = Phase.READY;
                    initFuture.set(null);
                }
            }

            @Override
            public void onFailure(Throwable t) {
                phase = Phase.INIT_FAILED;
                forceClose(connections);
                initFuture.setException(t);
            }
        }, initExecutor);
        return initFuture;
    }
=======
public ListenableFuture<Void> initAsync(Connection reusedConnection) {
        // Create initial core connections
        int capacity = options().getCoreConnectionsPerHost(hostDistance);
        final List<Connection> connections = Lists.newArrayListWithCapacity(capacity);
        final List<ListenableFuture<Void>> connectionFutures = Lists.newArrayListWithCapacity(capacity);
        for (int i = 0; i < capacity; i++) {
            Connection connection;
            ListenableFuture<Void> connectionFuture;
            // reuse the existing connection only once
            if (reusedConnection != null && reusedConnection.setPool(this)) {
                connection = reusedConnection;
                connectionFuture = MoreFutures.VOID_SUCCESS;
            } else {
                connection = manager.connectionFactory().newConnection(this);
                connectionFuture = connection.initAsync();
            }
            reusedConnection = null;
            connections.add(connection);
            connectionFutures.add(connectionFuture);
        }

        Executor initExecutor = manager.cluster.manager.configuration.getPoolingOptions().getInitializationExecutor();

        ListenableFuture<List<Void>> allConnectionsFuture = Futures.allAsList(connectionFutures);

        final SettableFuture<Void> initFuture = SettableFuture.create();
        Futures.addCallback(allConnectionsFuture, new FutureCallback<List<Void>>() {
            @Override
            public void onSuccess(List<Void> l) {
                HostConnectionPool.this.connections.addAll(connections);
                open.set(l.size());
                if (isClosed()) {
                    initFuture.setException(new ConnectionException(host.getSocketAddress(), "Pool was closed during initialization"));
                    // we're not sure if closeAsync() saw the connections, so ensure they get closed
                    forceClose(connections);
                } else {
                    logger.trace("Created connection pool to host {}", host);
                    phase.compareAndSet(Phase.INITIALIZING, Phase.READY);
                    initFuture.set(null);
                }
            }

            @Override
            public void onFailure(Throwable t) {
                phase.compareAndSet(Phase.INITIALIZING, Phase.INIT_FAILED);
                forceClose(connections);
                initFuture.setException(t);
            }
        }, initExecutor);
        return initFuture;
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887386\fstmerge_var2_5794360194004407593

File path: C:\download\ssmerge\java-driver\revisions\rev_3ffa8_3f1d5\rev_rev_left_3ffa8-rev_right_3f1d5\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887466\fstmerge_var1_8718582779845633737
abstract Connection borrowConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887466\fstmerge_base_2037142442362924404
public Connection borrowConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException {
        if (phase == Phase.INITIALIZING)
            throw new ConnectionException(host.getSocketAddress(), "Pool is initializing.");

        if (phase != Phase.READY)
            // Note: throwing a ConnectionException is probably fine in practice as it will trigger the creation of a new host.
            // That being said, maybe having a specific exception could be cleaner.
            throw new ConnectionException(host.getSocketAddress(), "Pool is " + phase);

        if (connections.isEmpty()) {
            for (int i = 0; i < options().getCoreConnectionsPerHost(hostDistance); i++) {
                // We don't respect MAX_SIMULTANEOUS_CREATION here because it's  only to
                // protect against creating connection in excess of core too quickly
                scheduledForCreation.incrementAndGet();
                manager.blockingExecutor().submit(newConnectionTask);
            }
            Connection c = waitForConnection(timeout, unit);
            totalInFlight.incrementAndGet();
            c.setKeyspace(manager.poolsState.keyspace);
            return c;
        }

        int minInFlight = Integer.MAX_VALUE;
        Connection leastBusy = null;
        for (Connection connection : connections) {
            int inFlight = connection.inFlight.get();
            if (inFlight < minInFlight) {
                minInFlight = inFlight;
                leastBusy = connection;
            }
        }

        if (leastBusy == null) {
            // We could have raced with a shutdown since the last check
            if (isClosed())
                throw new ConnectionException(host.getSocketAddress(), "Pool is shutdown");
            // This might maybe happen if the number of core connections per host is 0 and a connection was trashed between
            // the previous check to connections and now. But in that case, the line above will have trigger the creation of
            // a new connection, so just wait that connection and move on
            leastBusy = waitForConnection(timeout, unit);
        } else {
            while (true) {
                int inFlight = leastBusy.inFlight.get();

                if (inFlight >= leastBusy.maxAvailableStreams()) {
                    leastBusy = waitForConnection(timeout, unit);
                    break;
                }

                if (leastBusy.inFlight.compareAndSet(inFlight, inFlight + 1))
                    break;
            }
        }

        int totalInFlightCount = totalInFlight.incrementAndGet();
        // update max atomically:
        while (true) {
            int oldMax = maxTotalInFlight.get();
            if (totalInFlightCount <= oldMax || maxTotalInFlight.compareAndSet(oldMax, totalInFlightCount))
                break;
        }

        int connectionCount = open.get() + scheduledForCreation.get();
        if (connectionCount < options().getMaxConnectionsPerHost(hostDistance)) {
            // Add a connection if we fill the first n-1 connections and almost fill the last one
            int currentCapacity = (connectionCount - 1) * StreamIdGenerator.MAX_STREAM_PER_CONNECTION
                + options().getMaxSimultaneousRequestsPerConnectionThreshold(hostDistance);
            if (totalInFlightCount > currentCapacity)
                maybeSpawnNewConnection();
        }

        leastBusy.setKeyspace(manager.poolsState.keyspace);
        return leastBusy;
    }
=======
public Connection borrowConnection(long timeout, TimeUnit unit) throws ConnectionException, TimeoutException {
        Phase phase = this.phase.get();
        if (phase != Phase.READY)
            // Note: throwing a ConnectionException is probably fine in practice as it will trigger the creation of a new host.
            // That being said, maybe having a specific exception could be cleaner.
            throw new ConnectionException(host.getSocketAddress(), "Pool is " + phase);

        if (connections.isEmpty()) {
            for (int i = 0; i < options().getCoreConnectionsPerHost(hostDistance); i++) {
                // We don't respect MAX_SIMULTANEOUS_CREATION here because it's  only to
                // protect against creating connection in excess of core too quickly
                scheduledForCreation.incrementAndGet();
                manager.blockingExecutor().submit(newConnectionTask);
            }
            Connection c = waitForConnection(timeout, unit);
            totalInFlight.incrementAndGet();
            c.setKeyspace(manager.poolsState.keyspace);
            return c;
        }

        int minInFlight = Integer.MAX_VALUE;
        Connection leastBusy = null;
        for (Connection connection : connections) {
            int inFlight = connection.inFlight.get();
            if (inFlight < minInFlight) {
                minInFlight = inFlight;
                leastBusy = connection;
            }
        }

        if (leastBusy == null) {
            // We could have raced with a shutdown since the last check
            if (isClosed())
                throw new ConnectionException(host.getSocketAddress(), "Pool is shutdown");
            // This might maybe happen if the number of core connections per host is 0 and a connection was trashed between
            // the previous check to connections and now. But in that case, the line above will have trigger the creation of
            // a new connection, so just wait that connection and move on
            leastBusy = waitForConnection(timeout, unit);
        } else {
            while (true) {
                int inFlight = leastBusy.inFlight.get();

                if (inFlight >= leastBusy.maxAvailableStreams()) {
                    leastBusy = waitForConnection(timeout, unit);
                    break;
                }

                if (leastBusy.inFlight.compareAndSet(inFlight, inFlight + 1))
                    break;
            }
        }

        int totalInFlightCount = totalInFlight.incrementAndGet();
        // update max atomically:
        while (true) {
            int oldMax = maxTotalInFlight.get();
            if (totalInFlightCount <= oldMax || maxTotalInFlight.compareAndSet(oldMax, totalInFlightCount))
                break;
        }

        int connectionCount = open.get() + scheduledForCreation.get();
        if (connectionCount < options().getMaxConnectionsPerHost(hostDistance)) {
            // Add a connection if we fill the first n-1 connections and almost fill the last one
            int currentCapacity = (connectionCount - 1) * StreamIdGenerator.MAX_STREAM_PER_CONNECTION
                + options().getMaxSimultaneousRequestsPerConnectionThreshold(hostDistance);
            if (totalInFlightCount > currentCapacity)
                maybeSpawnNewConnection();
        }

        leastBusy.setKeyspace(manager.poolsState.keyspace);
        return leastBusy;
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887466\fstmerge_var2_6681416130172234353

File path: C:\download\ssmerge\java-driver\revisions\rev_3ffa8_3f1d5\rev_rev_left_3ffa8-rev_right_3f1d5\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887957\fstmerge_var1_990661403082280003
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887957\fstmerge_base_279807388488013412
private boolean addConnectionIfUnderMaximum() {

        // First, make sure we don't cross the allowed limit of open connections
        for(;;) {
            int opened = open.get();
            if (opened >= options().getMaxConnectionsPerHost(hostDistance))
                return false;

            if (open.compareAndSet(opened, opened + 1))
                break;
        }

        if (phase != Phase.READY) {
            open.decrementAndGet();
            return false;
        }

        // Now really open the connection
        try {
            Connection newConnection = tryResurrectFromTrash();
            if (newConnection == null) {
                logger.debug("Creating new connection on busy pool to {}", host);
                newConnection = manager.connectionFactory().open(this);
            }
            connections.add(newConnection);

            newConnection.state.compareAndSet(RESURRECTING, OPEN); // no-op if it was already OPEN

            // We might have raced with pool shutdown since the last check; ensure the connection gets closed in case the pool did not do it.
            if (phase != Phase.READY && !newConnection.isClosed()) {
                close(newConnection);
                open.decrementAndGet();
                return false;
            }

            signalAvailableConnection();
            return true;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            // Skip the open but ignore otherwise
            open.decrementAndGet();
            return false;
        } catch (ConnectionException e) {
            open.decrementAndGet();
            logger.debug("Connection error to {} while creating additional connection", host);
            return false;
        } catch (AuthenticationException e) {
            // This shouldn't really happen in theory
            open.decrementAndGet();
            logger.error("Authentication error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (UnsupportedProtocolVersionException e) {
            // This shouldn't happen since we shouldn't have been able to connect in the first place
            open.decrementAndGet();
            logger.error("UnsupportedProtocolVersionException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (ClusterNameMismatchException e) {
            open.decrementAndGet();
            logger.error("ClusterNameMismatchException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        }
    }
=======
private boolean addConnectionIfUnderMaximum() {

        // First, make sure we don't cross the allowed limit of open connections
        for(;;) {
            int opened = open.get();
            if (opened >= options().getMaxConnectionsPerHost(hostDistance))
                return false;

            if (open.compareAndSet(opened, opened + 1))
                break;
        }

        if (phase.get() != Phase.READY) {
            open.decrementAndGet();
            return false;
        }

        // Now really open the connection
        try {
            Connection newConnection = tryResurrectFromTrash();
            if (newConnection == null) {
                logger.debug("Creating new connection on busy pool to {}", host);
                newConnection = manager.connectionFactory().open(this);
            }
            connections.add(newConnection);

            newConnection.state.compareAndSet(RESURRECTING, OPEN); // no-op if it was already OPEN

            // We might have raced with pool shutdown since the last check; ensure the connection gets closed in case the pool did not do it.
            if (isClosed() && !newConnection.isClosed()) {
                close(newConnection);
                open.decrementAndGet();
                return false;
            }

            signalAvailableConnection();
            return true;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            // Skip the open but ignore otherwise
            open.decrementAndGet();
            return false;
        } catch (ConnectionException e) {
            open.decrementAndGet();
            logger.debug("Connection error to {} while creating additional connection", host);
            return false;
        } catch (AuthenticationException e) {
            // This shouldn't really happen in theory
            open.decrementAndGet();
            logger.error("Authentication error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (UnsupportedProtocolVersionException e) {
            // This shouldn't happen since we shouldn't have been able to connect in the first place
            open.decrementAndGet();
            logger.error("UnsupportedProtocolVersionException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        } catch (ClusterNameMismatchException e) {
            open.decrementAndGet();
            logger.error("ClusterNameMismatchException error while creating additional connection (error is: {})", e.getMessage());
            return false;
        }
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513613887957\fstmerge_var2_5953765423959475581

File path: C:\download\ssmerge\java-driver\revisions\rev_3ffa8_3f1d5\rev_rev_left_3ffa8-rev_right_3f1d5\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_e94df_05dca\rev_e94df-05dca.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_d6cf7_dd9c5\rev_d6cf7-dd9c5.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_21ab5_e94df\rev_21ab5-e94df.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_38890_25347\rev_38890-25347.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_ae70b_ab408\rev_ae70b-ab408.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b1d81_11c3a\rev_b1d81-11c3a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_279ba_bcdf5\rev_279ba-bcdf5.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_aa26d_4380b\rev_aa26d-4380b.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_c1f93_2ef7a\rev_c1f93-2ef7a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_dff88_215b8\rev_dff88-215b8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_cf8ee_c2ad7\rev_cf8ee-c2ad7.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b10c7_c45e8\rev_b10c7-c45e8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_18f6f_b78db\rev_18f6f-b78db.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b4a6e_23eb0\rev_b4a6e-23eb0.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_8f957_d7efc\rev_8f957-d7efc.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_2590e_2e811\rev_2590e-2e811.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_2e811_7386c\rev_2e811-7386c.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_04752_f70ef\rev_04752-f70ef.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_f70ef_8e4f2\rev_f70ef-8e4f2.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_2e877_216a9\rev_2e877-216a9.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_37db9_13cd2\rev_37db9-13cd2.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_2824e_c57a3\rev_2824e-c57a3.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_bec78_0bef8\rev_bec78-0bef8.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
Message.Request makeRequestMessage(Statement statement, ByteBuffer pagingState) {
        // We need the protocol version, which is only available once the cluster has initialized. Initialize the session to ensure this is the case.
        // init() locks, so avoid if we know we don't need it.
        if (!isInit)
            init();
        ProtocolVersion version = cluster.manager.protocolVersion();

        ConsistencyLevel consistency = statement.getConsistencyLevel();
        if (consistency == null)
            consistency = configuration().getQueryOptions().getConsistencyLevel();

        ConsistencyLevel serialConsistency = statement.getSerialConsistencyLevel();
        if (version.compareTo(ProtocolVersion.V3) < 0 && statement instanceof BatchStatement) {
            if (serialConsistency != null)
                throw new UnsupportedFeatureException(version, "Serial consistency on batch statements is not supported");
        } else if (serialConsistency == null)
            serialConsistency = configuration().getQueryOptions().getSerialConsistencyLevel();

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513615999121\fstmerge_var1_5776736741024099248
        long defaultTimestamp = Long.MIN_VALUE;
        if (cluster.manager.protocolVersion().compareTo(ProtocolVersion.V3) >= 0) {
            defaultTimestamp = statement.getDefaultTimestamp();
            if (defaultTimestamp == Long.MIN_VALUE)
                defaultTimestamp = cluster.getConfiguration().getPolicies().getTimestampGenerator().next();
        }

        return makeRequestMessage(statement, consistency, serialConsistency, pagingState, defaultTimestamp);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513615999121\fstmerge_base_8591843433194958208
        return makeRequestMessage(statement, consistency, serialConsistency, pagingState);
=======
        Message.Request request = makeRequestMessage(statement, consistency, serialConsistency, pagingState);
        if (statement.isTracing())
            request.setTracingRequested();

        return request;
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513615999121\fstmerge_var2_177378346931873948
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_bec78_0bef8\rev_rev_left_bec78-rev_right_0bef8\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_602ad_048be\rev_602ad-048be.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_0bef8_b322c\rev_0bef8-b322c.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_bc4be_d1915\rev_bc4be-d1915.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_568d6_0a700\rev_568d6-0a700.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_fe658_e0a1b\rev_fe658-e0a1b.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_2d611_c017b\rev_2d611-c017b.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_c017b_f19c8\rev_c017b-f19c8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_3a060_9259b\rev_3a060-9259b.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_9259b_00f9d\rev_9259b-00f9d.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_9bc2c_b6757\rev_9bc2c-b6757.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b6757_2ed25\rev_b6757-2ed25.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_9469e_1729f\rev_9469e-1729f.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_1729f_aa9d9\rev_1729f-aa9d9.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_afcb4_3d055\rev_afcb4-3d055.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_e4007_d49b8\rev_e4007-d49b8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_05397_29486\rev_05397-29486.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617273785\fstmerge_var1_5302953529426844801
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617273785\fstmerge_base_7893168029760667224
@Override
    StringBuilder buildQueryString(List<ByteBuffer> variables) {
        StringBuilder builder = new StringBuilder();

        builder.append("DELETE");
        if (columnNames != null)
            Utils.joinAndAppendNames(builder.append(" "), ",", columnNames);

        builder.append(" FROM ");
        if (keyspace != null)
            Utils.appendName(keyspace, builder).append('.');
        Utils.appendName(table, builder);
        if (!usings.usings.isEmpty()) {
            builder.append(" USING ");
            Utils.joinAndAppend(builder, " AND ", usings.usings, variables);
        }

        if (!where.clauses.isEmpty()) {
            builder.append(" WHERE ");
            Utils.joinAndAppend(builder, " AND ", where.clauses, variables);
        }

        if (ifExists) {
            builder.append(" IF EXISTS ");
        }

        if (!conditions.conditions.isEmpty()) {
            builder.append(" IF ");
            Utils.joinAndAppend(builder, " AND ", conditions.conditions, variables);
        }

        return builder;
    }
=======
@Override
    StringBuilder buildQueryString(List<ByteBuffer> variables) {
        StringBuilder builder = new StringBuilder();

        builder.append("DELETE");
        if (!columns.isEmpty())
            Utils.joinAndAppend(builder.append(" "), ",", columns, variables);

        builder.append(" FROM ");
        if (keyspace != null)
            Utils.appendName(keyspace, builder).append('.');
        Utils.appendName(table, builder);
        if (!usings.usings.isEmpty()) {
            builder.append(" USING ");
            Utils.joinAndAppend(builder, " AND ", usings.usings, variables);
        }

        if (!where.clauses.isEmpty()) {
            builder.append(" WHERE ");
            Utils.joinAndAppend(builder, " AND ", where.clauses, variables);
        }

        if (ifExists) {
            builder.append(" IF EXISTS ");
        }

        if (!conditions.conditions.isEmpty()) {
            builder.append(" IF ");
            Utils.joinAndAppend(builder, " AND ", conditions.conditions, variables);
        }

        return builder;
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617273785\fstmerge_var2_5481101367628487889

File path: C:\download\ssmerge\java-driver\revisions\rev_05397_29486\rev_rev_left_05397-rev_right_29486\driver-core\src\main\java\com\datastax\driver\core\querybuilder\Delete.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617273868\fstmerge_var1_1803694388099509378
@Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            appendTo(sb, new ArrayList<Object>());
            return sb.toString();
        }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617273868\fstmerge_base_8481152411934556173
=======
@Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            appendTo(sb, new ArrayList<ByteBuffer>());
            return sb.toString();
        }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617273868\fstmerge_var2_7482773544786058157

File path: C:\download\ssmerge\java-driver\revisions\rev_05397_29486\rev_rev_left_05397-rev_right_29486\driver-core\src\main\java\com\datastax\driver\core\querybuilder\Delete.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617277118\fstmerge_var1_8798436366974189365
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617277118\fstmerge_base_7812352036926653028
static ByteBuffer serializeValue(Object value) {
        if (value == QueryBuilder.bindMarker() || value instanceof FCall || value instanceof CName)
            return null;

        // We also don't serialize fixed size number types. The reason is that if we do it, we will
        // force a particular size (4 bytes for ints, ...) and for the query builder, we don't want
        // users to have to bother with that.
        if (value instanceof Number && !(value instanceof BigInteger || value instanceof BigDecimal))
            return null;

        try {
            return DataType.serializeValue(value);
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
=======
static ByteBuffer serializeValue(Object value) {
        if (value == QueryBuilder.bindMarker() || value instanceof FCall || value instanceof CName)
            return null;

        if (value instanceof RawString)
            return null;

        // We also don't serialize fixed size number types. The reason is that if we do it, we will
        // force a particular size (4 bytes for ints, ...) and for the query builder, we don't want
        // users to have to bother with that.
        if (value instanceof Number && !(value instanceof BigInteger || value instanceof BigDecimal))
            return null;

        try {
            return DataType.serializeValue(value);
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617277118\fstmerge_var2_9178153136827354800

File path: C:\download\ssmerge\java-driver\revisions\rev_05397_29486\rev_rev_left_05397-rev_right_29486\driver-core\src\main\java\com\datastax\driver\core\querybuilder\Utils.java
Conflict type: SameSignatureCM
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: smallMethod
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617309906\fstmerge_var1_5342625958520697297
@Test(groups = "unit")
    public void should_not_serialize_raw_query_values() {
        RegularStatement select = select().from("test").where(gt("i", raw("1")));
        assertThat(select.getQueryString()).doesNotContain("?");
        assertThat(select.getValues(ProtocolVersion.V3)).isNull();
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617309906\fstmerge_base_3226857176655990378
=======
@Test(groups = "unit")
    public void should_not_serialize_raw_query_values() {
        RegularStatement select = select().from("test").where(gt("i", raw("1")));
        assertThat(select.getQueryString()).doesNotContain("?");
        assertThat(select.getValues()).isNull();
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617309906\fstmerge_var2_8234870788038472593

File path: C:\download\ssmerge\java-driver\revisions\rev_05397_29486\rev_rev_left_05397-rev_right_29486\driver-core\src\test\java\com\datastax\driver\core\querybuilder\QueryBuilderTest.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_29486_8946a\rev_29486-8946a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_9bc2b_8d711\rev_9bc2b-8d711.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b25bb_77d5e\rev_b25bb-77d5e.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_74991_dbba4\rev_74991-dbba4.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
@Override
        public Message.Request request() {
            if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency())
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617503648\fstmerge_var1_5234854873904977150
                return manager.makeRequestMessage(statement, retryConsistencyLevel, request.serialConsistency(), request.pagingState(), request.defaultTimestamp());
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617503648\fstmerge_base_5644358914400657343
                return manager.makeRequestMessage(statement, retryConsistencyLevel, request.consistency(), request.pagingState());
=======
                return request.copy(retryConsistencyLevel);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617503648\fstmerge_var2_9193882124290675379
            else
                return request;
        }

File path: C:\download\ssmerge\java-driver\revisions\rev_74991_dbba4\rev_rev_left_74991-rev_right_dbba4\driver-core\src\main\java\com\datastax\driver\core\RequestHandler.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
Message.Request makeRequestMessage(Statement statement, ByteBuffer pagingState) {
        // We need the protocol version, which is only available once the cluster has initialized. Initialize the session to ensure this is the case.
        // init() locks, so avoid if we know we don't need it.
        if (!isInit)
            init();
        ProtocolVersion version = cluster.manager.protocolVersion();

        ConsistencyLevel consistency = statement.getConsistencyLevel();
        if (consistency == null)
            consistency = configuration().getQueryOptions().getConsistencyLevel();

        ConsistencyLevel serialConsistency = statement.getSerialConsistencyLevel();
        if (version.compareTo(ProtocolVersion.V3) < 0 && statement instanceof BatchStatement) {
            if (serialConsistency != null)
                throw new UnsupportedFeatureException(version, "Serial consistency on batch statements is not supported");
        } else if (serialConsistency == null)
            serialConsistency = configuration().getQueryOptions().getSerialConsistencyLevel();

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617509593\fstmerge_var1_2990569265144583684
        long defaultTimestamp = Long.MIN_VALUE;
        if (cluster.manager.protocolVersion().compareTo(ProtocolVersion.V3) >= 0) {
            defaultTimestamp = statement.getDefaultTimestamp();
            if (defaultTimestamp == Long.MIN_VALUE)
                defaultTimestamp = cluster.getConfiguration().getPolicies().getTimestampGenerator().next();
        }

        Message.Request request = makeRequestMessage(statement, consistency, serialConsistency, pagingState, defaultTimestamp);
        if (statement.isTracing())
            request.setTracingRequested();
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617509593\fstmerge_base_3473551528219639962
        Message.Request request = makeRequestMessage(statement, consistency, serialConsistency, pagingState);
        if (statement.isTracing())
            request.setTracingRequested();
=======
        int protoVersion = cluster.manager.protocolVersion();
        int fetchSize = statement.getFetchSize();
        ByteBuffer usedPagingState = pagingState;
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513617509593\fstmerge_var2_1501544272407936571

        if (protoVersion == 1) {
            assert pagingState == null;
            // We don't let the user change the fetchSize globally if the proto v1 is used, so we just need to
            // check for the case of a per-statement override
            if (fetchSize <= 0)
                fetchSize = -1;
            else if (fetchSize != Integer.MAX_VALUE)
                throw new UnsupportedFeatureException("Paging is not supported");
        } else if (fetchSize <= 0) {
            fetchSize = configuration().getQueryOptions().getFetchSize();
        }

        if (fetchSize == Integer.MAX_VALUE)
            fetchSize = -1;

        if (pagingState == null) {
            usedPagingState = statement.getPagingState();
        }

        if (statement instanceof StatementWrapper)
            statement = ((StatementWrapper)statement).getWrappedStatement();

        if (statement instanceof RegularStatement) {
            RegularStatement rs = (RegularStatement)statement;

            // It saddens me that we special case for the query builder here, but for now this is simpler.
            // We could provide a general API in RegularStatement instead at some point but it's unclear what's
            // the cleanest way to do that is right now (and it's probably not really that useful anyway).
            if (protoVersion == 1 && rs instanceof com.datastax.driver.core.querybuilder.BuiltStatement)
                ((com.datastax.driver.core.querybuilder.BuiltStatement)rs).setForceNoValues(true);

            ByteBuffer[] rawValues = rs.getValues();

            if (protoVersion == 1 && rawValues != null)
                throw new UnsupportedFeatureException("Binary values are not supported");

            List<ByteBuffer> values = rawValues == null ? Collections.<ByteBuffer>emptyList() : Arrays.asList(rawValues);
            String qString = rs.getQueryString();
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(consistency, values, false, fetchSize, usedPagingState, serialConsistency);
            return new Requests.Query(qString, options, statement.isTracing());
        } else if (statement instanceof BoundStatement) {
            BoundStatement bs = (BoundStatement)statement;
            if (!cluster.manager.preparedQueries.containsKey(bs.statement.getPreparedId().id)) {
                throw new InvalidQueryException(String.format("Tried to execute unknown prepared query : %s. "
                    + "You may have used a PreparedStatement that was created with another Cluster instance.", bs.statement.getPreparedId().id));
            }
            boolean skipMetadata = protoVersion != 1 && bs.statement.getPreparedId().resultSetMetadata != null;
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(consistency, Arrays.asList(bs.values), skipMetadata, fetchSize, usedPagingState, serialConsistency);
            return new Requests.Execute(bs.statement.getPreparedId().id, options, statement.isTracing());
        } else {
            assert statement instanceof BatchStatement : statement;
            assert pagingState == null;

            if (protoVersion == 1)
                throw new UnsupportedFeatureException("Protocol level batching is not supported");

            BatchStatement bs = (BatchStatement)statement;
            BatchStatement.IdAndValues idAndVals = bs.getIdAndValues();
            return new Requests.Batch(bs.batchType, idAndVals.ids, idAndVals.values, consistency, statement.isTracing());
        }
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_74991_dbba4\rev_rev_left_74991-rev_right_dbba4\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_8f153_9e5f9\rev_8f153-9e5f9.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_a6009_19a4a\rev_a6009-19a4a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_a48c3_3a9d1\rev_a48c3-3a9d1.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_91cf5_8c3b8\rev_91cf5-8c3b8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_a890f_d6f30\rev_a890f-d6f30.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_15bc4_95d32\rev_15bc4-95d32.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_dc2e9_9f7b7\rev_dc2e9-9f7b7.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_95d32_82e3b\rev_95d32-82e3b.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_54846_866a3\rev_54846-866a3.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
@Test(groups = "short", dataProvider = "NettyOptionsTest")
    public void should_invoke_netty_options_hooks(int hosts, int coreConnections) throws Exception {
        //given
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618748721\fstmerge_var1_1914257074451401391
        CCMBridge ccm = CCMBridge.create("test", hosts);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618748721\fstmerge_base_6149751113860684523
        int expectedNumberOfCalls = coreConnections * hosts + 1;
        CCMBridge ccm = CCMBridge.createWithCustomVersion("test", hosts, "2.0.10");
=======
        int expectedNumberOfCalls = coreConnections * hosts + 1;
        CCMBridge ccm = CCMBridge.builder("test").withNodes(hosts).withCassandraVersion("2.0.10").build();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618748721\fstmerge_var2_3142208110649472066
        Cluster cluster = null;
        try {
            NettyOptions nettyOptions = mock(NettyOptions.class, CALLS_REAL_METHODS.get());
            EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
            when(nettyOptions.eventLoopGroup(any(ThreadFactory.class))).thenReturn(eventLoopGroup);
            final ChannelHandler handler = mock(ChannelHandler.class);
            doAnswer(new Answer() {
                @Override
                public Object answer(InvocationOnMock invocation) throws Throwable {
                    SocketChannel channel = (SocketChannel) invocation.getArguments()[0];
                    channel.pipeline().addLast("test-handler", handler);
                    return null;
                }
            }).when(nettyOptions).afterChannelInitialized(any(SocketChannel.class));
            cluster = Cluster.builder()
                .addContactPoint(ipOfNode(1))
                .withPoolingOptions(new PoolingOptions()
                    .setConnectionsPerHost(HostDistance.LOCAL, coreConnections, coreConnections)
                )
                .withNettyOptions(nettyOptions)
                .build();
            // when
            cluster.connect();// force session creation to populate pools

            int expectedNumberOfCalls = TestUtils.numberOfLocalCoreConnections(cluster) * hosts + 1;
            // If the driver supports a more recent protocol version than C*, the negotiation at startup
            // will open 1 extra connection.
            if (!ProtocolVersion.NEWEST_SUPPORTED.isSupportedBy(TestUtils.findHost(cluster, 1)))
                expectedNumberOfCalls += 1;

            cluster.close();
            // then
            ArgumentCaptor<EventLoopGroup> captor = ArgumentCaptor.forClass(EventLoopGroup.class);
            verify(nettyOptions, times(1)).eventLoopGroup(any(ThreadFactory.class));
            verify(nettyOptions, times(1)).channelClass();
            // per-connection hooks will be called coreConnections * hosts + 1 times:
            // the extra call is for the control connection
            verify(nettyOptions, times(expectedNumberOfCalls)).afterBootstrapInitialized(any(Bootstrap.class));
            verify(nettyOptions, times(expectedNumberOfCalls)).afterChannelInitialized(any(SocketChannel.class));
            verify(handler, times(expectedNumberOfCalls)).handlerAdded(any(ChannelHandlerContext.class));
            verify(handler, times(expectedNumberOfCalls)).handlerRemoved(any(ChannelHandlerContext.class));
            verify(nettyOptions, times(1)).onClusterClose(captor.capture());
            assertThat(captor.getValue()).isSameAs(eventLoopGroup);
        } finally {
            if (cluster != null)
                cluster.close();
            ccm.remove();
        }
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_54846_866a3\rev_rev_left_54846-rev_right_866a3\driver-core\src\test\java\com\datastax\driver\core\NettyOptionsTest.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_1380d_4b8a3\rev_1380d-4b8a3.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_1c466-a1d47.revisions
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
@Override
        public Configuration getConfiguration() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885364\fstmerge_var1_6692593424210788442
            Policies policies = new Policies(
                loadBalancingPolicy == null ? Policies.defaultLoadBalancingPolicy() : loadBalancingPolicy,
                Objects.firstNonNull(reconnectionPolicy, Policies.defaultReconnectionPolicy()),
                Objects.firstNonNull(retryPolicy, Policies.defaultRetryPolicy()),
                Objects.firstNonNull(addressTranslator, Policies.defaultAddressTranslator()),
                Objects.firstNonNull(timestampGenerator, Policies.defaultTimestampGenerator()),
                Objects.firstNonNull(speculativeExecutionPolicy, Policies.defaultSpeculativeExecutionPolicy())
            );
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885364\fstmerge_base_3612912766561167493
            Policies policies = new Policies(
                loadBalancingPolicy == null ? Policies.defaultLoadBalancingPolicy() : loadBalancingPolicy,
                Objects.firstNonNull(reconnectionPolicy, Policies.defaultReconnectionPolicy()),
                Objects.firstNonNull(retryPolicy, Policies.defaultRetryPolicy()),
                Objects.firstNonNull(addressTranslater, Policies.defaultAddressTranslater()),
                Objects.firstNonNull(timestampGenerator, Policies.defaultTimestampGenerator()),
                Objects.firstNonNull(speculativeExecutionPolicy, Policies.defaultSpeculativeExecutionPolicy())
            );
=======
            Policies policies = Policies.builder()
                .withLoadBalancingPolicy(loadBalancingPolicy)
                .withReconnectionPolicy(reconnectionPolicy)
                .withRetryPolicy(retryPolicy)
                .withAddressTranslater(addressTranslater)
                .withTimestampGenerator(timestampGenerator)
                .withSpeculativeExecutionPolicy(speculativeExecutionPolicy)
                .build();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885364\fstmerge_var2_7178756488225779963
            return new Configuration(policies,
                                     new ProtocolOptions(port, protocolVersion, maxSchemaAgreementWaitSeconds, sslOptions, authProvider).setCompression(compression),
                                     poolingOptions == null ? new PoolingOptions() : poolingOptions,
                                     socketOptions == null ? new SocketOptions() : socketOptions,
                                     metricsEnabled ? new MetricsOptions(jmxEnabled) : null,
                                     queryOptions == null ? new QueryOptions() : queryOptions,
                                     nettyOptions);
        }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\Cluster.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
synchronized void init() {
            checkNotClosed(this);
            if (isInit)
                return;
            isInit = true;

            logger.debug("Starting new cluster with contact points " + contactPoints);

            this.configuration.register(this);

            this.executorQueue = new LinkedBlockingQueue<Runnable>();
            this.executor = makeExecutor(NON_BLOCKING_EXECUTOR_SIZE, "worker", executorQueue);
            this.blockingExecutorQueue = new LinkedBlockingQueue<Runnable>();
            this.blockingExecutor = makeExecutor(2, "blocking-task-worker", blockingExecutorQueue);
            this.reconnectionExecutor = new ScheduledThreadPoolExecutor(2, threadFactory("reconnection"));
            // scheduledTasksExecutor is used to process C* notifications. So having it mono-threaded ensures notifications are
            // applied in the order received.
            this.scheduledTasksExecutor = new ScheduledThreadPoolExecutor(1, threadFactory("scheduled-task-worker"));

            this.reaper = new ConnectionReaper(this);
            this.metadata = new Metadata(this);
            this.connectionFactory = new Connection.Factory(this, configuration);
            this.controlConnection = new ControlConnection(this);
            this.metrics = configuration.getMetricsOptions() == null ? null : new Metrics(this);
            this.preparedQueries = new MapMaker().weakValues().makeMap();

            this.scheduledTasksExecutor.scheduleWithFixedDelay(new CleanupIdleConnectionsTask(), 10, 10, TimeUnit.SECONDS);


            for (InetSocketAddress address : contactPoints) {
                // We don't want to signal -- call onAdd() -- because nothing is ready
                // yet (loadbalancing policy, control connection, ...). All we want is
                // create the Host object so we can initialize the control connection.
                metadata.add(address);
            }

            // At this stage, metadata.allHosts() only contains the contact points, that's what we want to pass to LBP.init().
            // But the control connection will initialize first and discover more hosts, so make a copy.
            Set<Host> contactPointHosts = Sets.newHashSet(metadata.allHosts());

            try {
                try {
                    controlConnection.connect();
                } catch (UnsupportedProtocolVersionException e) {
                    logger.debug("Cannot connect with protocol {}, trying {}", e.unsupportedVersion, e.serverVersion);

                    connectionFactory.protocolVersion = e.serverVersion;
                    try {
                        controlConnection.connect();
                    } catch (UnsupportedProtocolVersionException e1) {
                        throw new DriverInternalError("Cannot connect to node with its own version, this makes no sense", e);
                    }
                }

                // The control connection can mark hosts down if it failed to connect to them, separate them
                Set<Host> downContactPointHosts = Sets.newHashSet();
                for (Host host : contactPointHosts)
                    if (host.state == Host.State.DOWN)
                        downContactPointHosts.add(host);
                contactPointHosts.removeAll(downContactPointHosts);

                // Now that the control connection is ready, we have all the information we need about the nodes (datacenter,
                // rack...) to initialize the load balancing policy
                loadBalancingPolicy().init(Cluster.this, contactPointHosts);
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885459\fstmerge_var1_6373809001130383303

                speculativeExecutionPolicy().init(Cluster.this);
                configuration.getPolicies().getRetryPolicy().init(Cluster.this);
                reconnectionPolicy().init(Cluster.this);
                configuration.getPolicies().getAddressTranslator().init(Cluster.this);
                for (LatencyTracker tracker : trackers)
                    tracker.onRegister(Cluster.this);
                for (Host.StateListener listener : listeners)
                    listener.onRegister(Cluster.this);

||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885459\fstmerge_base_3118029399963191982
=======
                speculativeRetryPolicy().init(Cluster.this);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885459\fstmerge_var2_479062142788244157
                for (Host host : downContactPointHosts) {
                    loadBalancingPolicy().onDown(host);
                    for (Host.StateListener listener : listeners)
                        listener.onDown(host);
                }

                configuration.getPoolingOptions().setProtocolVersion(protocolVersion());

                for (Host host : metadata.allHosts()) {
                    // If the host is down at this stage, it's a contact point that the control connection failed to reach.
                    // Reconnection attempts are already scheduled, and the LBP and listeners have been notified above.
                    if (host.state == Host.State.DOWN) continue;

                    // Otherwise, we want to do the equivalent of onAdd(). But since we know for sure that no sessions or prepared
                    // statements exist at this point, we can skip some of the steps (plus this avoids scheduling concurrent pool
                    // creations if a session is created right after this method returns).
                    logger.info("New Cassandra host {} added", host);

                    if (!connectionFactory.protocolVersion.isSupportedBy(host)) {
                        logUnsupportedVersionProtocol(host, connectionFactory.protocolVersion);
                        return;
                    }
                    
                    if (!contactPointHosts.contains(host))
                        loadBalancingPolicy().onAdd(host);

                    host.setUp();

                    for (Host.StateListener listener : listeners)
                        listener.onAdd(host);
                }
                isFullyInit = true;
            } catch (NoHostAvailableException e) {
                close();
                throw e;
            }
        }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\Cluster.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
private CloseFuture close() {

            CloseFuture future = closeFuture.get();
            if (future != null)
                return future;

            if (isInit) {
                logger.debug("Shutting down");

                // If we're shutting down, there is no point in waiting on scheduled reconnections, nor on notifications
                // delivery or blocking tasks so we use shutdownNow
                shutdownNow(reconnectionExecutor);
                shutdownNow(scheduledTasksExecutor);
                shutdownNow(blockingExecutor);

                // but for the worker executor, we want to let submitted tasks finish unless the shutdown is forced.
                executor.shutdown();

                // We also close the metrics
                if (metrics != null)
                    metrics.shutdown();

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885977\fstmerge_var1_1612004906842937451
                loadBalancingPolicy().close();
                speculativeExecutionPolicy().close();
                configuration.getPolicies().getRetryPolicy().close();
                reconnectionPolicy().close();
                configuration.getPolicies().getAddressTranslator().close();
                for (LatencyTracker tracker : trackers)
                    tracker.onUnregister(Cluster.this);
                for (Host.StateListener listener : listeners)
                    listener.onUnregister(Cluster.this);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885977\fstmerge_base_5777205087114932852
                // And the load balancing policy
                LoadBalancingPolicy loadBalancingPolicy = loadBalancingPolicy();
                if (loadBalancingPolicy instanceof CloseableLoadBalancingPolicy)
                    ((CloseableLoadBalancingPolicy)loadBalancingPolicy).close();

                AddressTranslater translater = configuration.getPolicies().getAddressTranslater();
                if (translater instanceof CloseableAddressTranslater)
                    ((CloseableAddressTranslater)translater).close();
=======
                // And the load balancing policy
                LoadBalancingPolicy loadBalancingPolicy = loadBalancingPolicy();
                if (loadBalancingPolicy instanceof CloseableLoadBalancingPolicy)
                    ((CloseableLoadBalancingPolicy)loadBalancingPolicy).close();

                speculativeRetryPolicy().close();

                AddressTranslater translater = configuration.getPolicies().getAddressTranslater();
                if (translater instanceof CloseableAddressTranslater)
                    ((CloseableAddressTranslater)translater).close();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618885977\fstmerge_var2_9138595890700852929

                // Then we shutdown all connections
                List<CloseFuture> futures = new ArrayList<CloseFuture>(sessions.size() + 1);
                futures.add(controlConnection.closeAsync());
                for (Session session : sessions)
                    futures.add(session.closeAsync());

                future = new ClusterCloseFuture(futures);
                // The rest will happen asynchronously, when all connections are successfully closed
            } else {
                future = CloseFuture.immediateFuture();
            }

            return closeFuture.compareAndSet(null, future)
                ? future
                : closeFuture.get(); // We raced, it's ok, return the future that was actually set
        }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\Cluster.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618920981\fstmerge_var1_7540071418259283321
static HostConnectionPool newInstance(Host host, HostDistance hostDistance, SessionManager manager, ProtocolVersion version) {
        switch (version) {
            case V1:
            case V2:
                return new DynamicConnectionPool(host, hostDistance, manager);
            case V3:
            case V4:
                return new SingleConnectionPool(host, hostDistance, manager);
            default:
                throw version.unsupported();
        }
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618920981\fstmerge_base_4935097431278989949
static HostConnectionPool newInstance(Host host, HostDistance hostDistance, SessionManager manager, ProtocolVersion version) {
        switch (version) {
            case V1:
            case V2:
                return new DynamicConnectionPool(host, hostDistance, manager);
            case V3:
                return new SingleConnectionPool(host, hostDistance, manager);
            default:
                throw version.unsupported();
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618920981\fstmerge_var2_3433171278090857415

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\HostConnectionPool.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619022240\fstmerge_var1_3929878799851148120
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619022240\fstmerge_base_8072145722800421973
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy,
                    AddressTranslater addressTranslater,
                    TimestampGenerator timestampGenerator,
                    SpeculativeExecutionPolicy speculativeExecutionPolicy) {
        this.loadBalancingPolicy = loadBalancingPolicy;
        this.reconnectionPolicy = reconnectionPolicy;
        this.retryPolicy = retryPolicy;
        this.addressTranslater = addressTranslater;
        this.timestampGenerator = timestampGenerator;
        this.speculativeExecutionPolicy = speculativeExecutionPolicy;
    }
=======
@Deprecated
    /*
     * This constructor should be private and called only by the builder.
     * If a new field gets added, add it to this constructor and make it private, then expose the current signature as a deprecated method
     * (see end of class).
     */
    public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy,
                    AddressTranslater addressTranslater,
                    TimestampGenerator timestampGenerator,
                    SpeculativeExecutionPolicy speculativeExecutionPolicy) {
        this.loadBalancingPolicy = loadBalancingPolicy;
        this.reconnectionPolicy = reconnectionPolicy;
        this.retryPolicy = retryPolicy;
        this.addressTranslater = addressTranslater;
        this.timestampGenerator = timestampGenerator;
        this.speculativeExecutionPolicy = speculativeExecutionPolicy;
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619022240\fstmerge_var2_8192139841946726904

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\policies\Policies.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619023210\fstmerge_var1_4334824669955482721
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy,
                    SpeculativeExecutionPolicy speculativeExecutionPolicy) {
        this(loadBalancingPolicy, reconnectionPolicy, retryPolicy, DEFAULT_ADDRESS_TRANSLATOR, speculativeExecutionPolicy);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619023210\fstmerge_base_5582719190476054270
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy,
                    SpeculativeExecutionPolicy speculativeExecutionPolicy) {
        this(loadBalancingPolicy, reconnectionPolicy, retryPolicy, DEFAULT_ADDRESS_TRANSLATER, speculativeExecutionPolicy);
=======
public Policies(LoadBalancingPolicy loadBalancingPolicy, ReconnectionPolicy reconnectionPolicy, RetryPolicy retryPolicy, SpeculativeExecutionPolicy speculativeExecutionPolicy) {
        this(loadBalancingPolicy, reconnectionPolicy, retryPolicy, defaultAddressTranslater(), defaultTimestampGenerator(), speculativeExecutionPolicy);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619023210\fstmerge_var2_3410472797241407375
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\policies\Policies.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619023314\fstmerge_var1_5588681539685813895
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619023314\fstmerge_base_4554768139370461500
public Policies(LoadBalancingPolicy loadBalancingPolicy,
                    ReconnectionPolicy reconnectionPolicy,
                    RetryPolicy retryPolicy,
                    AddressTranslater addressTranslater,
                    SpeculativeExecutionPolicy speculativeExecutionPolicy) {
        // NB: this constructor is provided for backward compatibility with 2.1.0
        this.loadBalancingPolicy = loadBalancingPolicy;
        this.reconnectionPolicy = reconnectionPolicy;
        this.retryPolicy = retryPolicy;
        this.addressTranslater = addressTranslater;
        this.speculativeExecutionPolicy = speculativeExecutionPolicy;
        this.timestampGenerator = defaultTimestampGenerator();
    }
=======
public Policies(LoadBalancingPolicy loadBalancingPolicy, ReconnectionPolicy reconnectionPolicy, RetryPolicy retryPolicy, AddressTranslater addressTranslater, SpeculativeExecutionPolicy speculativeExecutionPolicy) {
        this(loadBalancingPolicy, reconnectionPolicy, retryPolicy, addressTranslater, defaultTimestampGenerator(), speculativeExecutionPolicy);
    }
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619023314\fstmerge_var2_1833777839450794893

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\policies\Policies.java
Conflict type: EditSameFd
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 0, 0, 0
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618937747\fstmerge_var1_7322032494656940260
public static ProtocolVersion NEWEST_SUPPORTED = V4;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618937747\fstmerge_base_4375840246059208938
public static ProtocolVersion NEWEST_SUPPORTED = V3;
=======
public static final ProtocolVersion NEWEST_SUPPORTED = V3;
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618937747\fstmerge_var2_4526168892165592942

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\ProtocolVersion.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
ListenableFuture<Boolean> forceRenewPool(final Host host, Connection reusedConnection) {
        final HostDistance distance = cluster.manager.loadBalancingPolicy().distance(host);
        if (distance == HostDistance.IGNORED)
            return Futures.immediateFuture(true);

        if (isClosing)
            return Futures.immediateFuture(false);

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618965115\fstmerge_var1_6307432970052469701
        final HostConnectionPool newPool = HostConnectionPool.newInstance(host, distance, SessionManager.this,
            cluster.getConfiguration().getProtocolOptions().getProtocolVersion());
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618965115\fstmerge_base_8190236996011959631
        final HostConnectionPool newPool = HostConnectionPool.newInstance(host, distance, SessionManager.this,
            cluster.getConfiguration().getProtocolOptions().getProtocolVersionEnum());
=======
        final HostConnectionPool newPool = new HostConnectionPool(host, distance, this);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618965115\fstmerge_var2_1938986586745665157
        ListenableFuture<Void> poolInitFuture = newPool.initAsync(reusedConnection);

        final SettableFuture<Boolean> future = SettableFuture.create();

        Futures.addCallback(poolInitFuture, new FutureCallback<Void>() {
            @Override
            public void onSuccess(Void result) {
                HostConnectionPool previous = pools.put(host, newPool);
                if (previous == null) {
                    logger.debug("Added connection pool for {}", host);
                } else {
                    logger.debug("Renewed connection pool for {}", host);
                    previous.closeAsync();
                }

                // If we raced with a session shutdown, ensure that the pool will be closed.
                if (isClosing) {
                    newPool.closeAsync();
                    pools.remove(host);
                    future.set(false);
                } else {
                    future.set(true);
                }
            }

            @Override
            public void onFailure(Throwable t) {
                logger.error("Error creating pool to " + host, t);
                future.set(false);
            }
        });

        return future;
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
private ListenableFuture<Void> replacePool(final Host host, HostDistance distance, HostConnectionPool previous, Connection reusedConnection) {
        if (isClosing)
            return MoreFutures.VOID_SUCCESS;

<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618965220\fstmerge_var1_7708281336060863423
        final HostConnectionPool newPool = HostConnectionPool.newInstance(host, distance, this,
            cluster.getConfiguration().getProtocolOptions().getProtocolVersion());
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618965220\fstmerge_base_4671615727719921796
        final HostConnectionPool newPool = HostConnectionPool.newInstance(host, distance, this,
            cluster.getConfiguration().getProtocolOptions().getProtocolVersionEnum());
=======
        final HostConnectionPool newPool = new HostConnectionPool(host, distance, this);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618965220\fstmerge_var2_1068020353436254056
        if (previous == null) {
            if (pools.putIfAbsent(host, newPool) != null) {
                return null;
            }
        } else {
            if (!pools.replace(host, previous, newPool)) {
                return null;
            }
            if (!previous.isClosed()) {
                logger.warn("Replacing a pool that wasn't closed. Closing it now, but this was not expected.");
                previous.closeAsync();
            }
        }

        ListenableFuture<Void> poolInitFuture = newPool.initAsync(reusedConnection);

        Futures.addCallback(poolInitFuture, new FutureCallback<Void>() {
            @Override
            public void onSuccess(Void result) {
                // If we raced with a session shutdown, ensure that the pool will be closed.
                if (isClosing) {
                    newPool.closeAsync();
                    pools.remove(host);
                }
            }

            @Override
            public void onFailure(Throwable t) {
                pools.remove(host);
            }
        });
        return poolInitFuture;
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 1
EditSameMCType: 0, 0, 1
Conflict body: 
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618966719\fstmerge_var1_2377846685669912775
Message.Request makeRequestMessage(Statement statement, ConsistencyLevel cl, ConsistencyLevel scl, ByteBuffer pagingState, long defaultTimestamp) {
        ProtocolVersion protoVersion = cluster.manager.protocolVersion();
        int fetchSize = statement.getFetchSize();
        ByteBuffer usedPagingState = pagingState;

        if (protoVersion == ProtocolVersion.V1) {
            assert pagingState == null;
            // We don't let the user change the fetchSize globally if the proto v1 is used, so we just need to
            // check for the case of a per-statement override
            if (fetchSize <= 0)
                fetchSize = -1;
            else if (fetchSize != Integer.MAX_VALUE)
                throw new UnsupportedFeatureException(protoVersion, "Paging is not supported");
        } else if (fetchSize <= 0) {
            fetchSize = configuration().getQueryOptions().getFetchSize();
        }

        if (fetchSize == Integer.MAX_VALUE)
            fetchSize = -1;

        if (pagingState == null) {
            usedPagingState = statement.getPagingState();
        }

        if (statement instanceof StatementWrapper)
            statement = ((StatementWrapper)statement).getWrappedStatement();

        Message.Request request;
        if (statement instanceof RegularStatement) {
            RegularStatement rs = (RegularStatement)statement;

            // It saddens me that we special case for the query builder here, but for now this is simpler.
            // We could provide a general API in RegularStatement instead at some point but it's unclear what's
            // the cleanest way to do that is right now (and it's probably not really that useful anyway).
            if (protoVersion == ProtocolVersion.V1 && rs instanceof com.datastax.driver.core.querybuilder.BuiltStatement)
                ((com.datastax.driver.core.querybuilder.BuiltStatement)rs).setForceNoValues(true);

            ByteBuffer[] rawValues = rs.getValues(protoVersion);

            if (protoVersion == ProtocolVersion.V1 && rawValues != null)
                throw new UnsupportedFeatureException(protoVersion, "Binary values are not supported");

            List<ByteBuffer> values = rawValues == null ? Collections.<ByteBuffer>emptyList() : Arrays.asList(rawValues);
            String qString = rs.getQueryString();
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, values, false,
                                                                                      fetchSize, usedPagingState, scl, defaultTimestamp);
            request = new Requests.Query(qString, options);
        } else if (statement instanceof BoundStatement) {
            BoundStatement bs = (BoundStatement)statement;
            if (!cluster.manager.preparedQueries.containsKey(bs.statement.getPreparedId().id)) {
                throw new InvalidQueryException(String.format("Tried to execute unknown prepared query : %s. "
                    + "You may have used a PreparedStatement that was created with another Cluster instance.", bs.statement.getPreparedId().id));
            }
            if(protoVersion.compareTo(ProtocolVersion.V4) < 0)
                bs.ensureAllSet();
            boolean skipMetadata = protoVersion != ProtocolVersion.V1 && bs.statement.getPreparedId().resultSetMetadata != null;
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, Arrays.asList(bs.wrapper.values), skipMetadata,
                                                                                      fetchSize, usedPagingState, scl, defaultTimestamp);
            request = new Requests.Execute(bs.statement.getPreparedId().id, options);
        } else {
            assert statement instanceof BatchStatement : statement;
            assert pagingState == null;

            if (protoVersion == ProtocolVersion.V1)
                throw new UnsupportedFeatureException(protoVersion, "Protocol level batching is not supported");

            BatchStatement bs = (BatchStatement)statement;
            if(protoVersion.compareTo(ProtocolVersion.V4) < 0)
                bs.ensureAllSet();
            BatchStatement.IdAndValues idAndVals = bs.getIdAndValues(protoVersion);
            Requests.BatchProtocolOptions options = new Requests.BatchProtocolOptions(cl, scl, defaultTimestamp);
            request = new Requests.Batch(bs.batchType, idAndVals.ids, idAndVals.values, options);
        }

        request.setCustomPayload(statement.getOutgoingPayload());
        return request;
    }
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618966719\fstmerge_base_1337181292930940729
Message.Request makeRequestMessage(Statement statement, ConsistencyLevel cl, ConsistencyLevel scl, ByteBuffer pagingState, long defaultTimestamp) {
        ProtocolVersion protoVersion = cluster.manager.protocolVersion();
        int fetchSize = statement.getFetchSize();
        ByteBuffer usedPagingState = pagingState;

        if (protoVersion == ProtocolVersion.V1) {
            assert pagingState == null;
            // We don't let the user change the fetchSize globally if the proto v1 is used, so we just need to
            // check for the case of a per-statement override
            if (fetchSize <= 0)
                fetchSize = -1;
            else if (fetchSize != Integer.MAX_VALUE)
                throw new UnsupportedFeatureException(protoVersion, "Paging is not supported");
        } else if (fetchSize <= 0) {
            fetchSize = configuration().getQueryOptions().getFetchSize();
        }

        if (fetchSize == Integer.MAX_VALUE)
            fetchSize = -1;

        if (pagingState == null) {
            usedPagingState = statement.getPagingState();
        }

        if (statement instanceof StatementWrapper)
            statement = ((StatementWrapper)statement).getWrappedStatement();

        if (statement instanceof RegularStatement) {
            RegularStatement rs = (RegularStatement)statement;

            // It saddens me that we special case for the query builder here, but for now this is simpler.
            // We could provide a general API in RegularStatement instead at some point but it's unclear what's
            // the cleanest way to do that is right now (and it's probably not really that useful anyway).
            if (protoVersion == ProtocolVersion.V1 && rs instanceof com.datastax.driver.core.querybuilder.BuiltStatement)
                ((com.datastax.driver.core.querybuilder.BuiltStatement)rs).setForceNoValues(true);

            ByteBuffer[] rawValues = rs.getValues(protoVersion);

            if (protoVersion == ProtocolVersion.V1 && rawValues != null)
                throw new UnsupportedFeatureException(protoVersion, "Binary values are not supported");

            List<ByteBuffer> values = rawValues == null ? Collections.<ByteBuffer>emptyList() : Arrays.asList(rawValues);
            String qString = rs.getQueryString();
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, values, false,
                                                                                      fetchSize, usedPagingState, scl, defaultTimestamp);
            return new Requests.Query(qString, options);
        } else if (statement instanceof BoundStatement) {
            BoundStatement bs = (BoundStatement)statement;
            if (!cluster.manager.preparedQueries.containsKey(bs.statement.getPreparedId().id)) {
                throw new InvalidQueryException(String.format("Tried to execute unknown prepared query : %s. "
                    + "You may have used a PreparedStatement that was created with another Cluster instance.", bs.statement.getPreparedId().id));
            }
            bs.ensureAllSet();
            boolean skipMetadata = protoVersion != ProtocolVersion.V1 && bs.statement.getPreparedId().resultSetMetadata != null;
            Requests.QueryProtocolOptions options = new Requests.QueryProtocolOptions(cl, Arrays.asList(bs.wrapper.values), skipMetadata,
                                                                                      fetchSize, usedPagingState, scl, defaultTimestamp);
            return new Requests.Execute(bs.statement.getPreparedId().id, options);
        } else {
            assert statement instanceof BatchStatement : statement;
            assert pagingState == null;

            if (protoVersion == ProtocolVersion.V1)
                throw new UnsupportedFeatureException(protoVersion, "Protocol level batching is not supported");

            BatchStatement bs = (BatchStatement)statement;
            bs.ensureAllSet();
            BatchStatement.IdAndValues idAndVals = bs.getIdAndValues(protoVersion);
            Requests.BatchProtocolOptions options = new Requests.BatchProtocolOptions(cl, scl, defaultTimestamp);
            return new Requests.Batch(bs.batchType, idAndVals.ids, idAndVals.values, options);
        }
    }
=======
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513618966719\fstmerge_var2_2896002942094474617

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\main\java\com\datastax\driver\core\SessionManager.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
public void bootstrapNodeWithPorts(int n, int thriftPort, int storagePort, int binaryPort, int jmxPort, int remoteDebugPort) {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619084556\fstmerge_var1_4500817464253648802
        bootstrapNodeWithPorts(n, thriftPort, storagePort, binaryPort, jmxPort, remoteDebugPort, null);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619084556\fstmerge_base_7151321229706164177
        String thriftItf = IP_PREFIX + n + ":" + thriftPort;
        String storageItf = IP_PREFIX + n + ":" + storagePort;
        String binaryItf = IP_PREFIX + n + ":" + binaryPort;
        String remoteLogItf = IP_PREFIX + n + ":" + remoteDebugPort;
        execute("ccm add node%d -i %s%d -b -t %s -l %s --binary-itf %s -j %d -r %s -s",
            n, IP_PREFIX, n, thriftItf, storageItf, binaryItf, jmxPort, remoteLogItf);
        execute("ccm node%d start --wait-other-notice --wait-for-binary-proto", n);
=======
        String thriftItf = IP_PREFIX + n + ":" + thriftPort;
        String storageItf = IP_PREFIX + n + ":" + storagePort;
        String binaryItf = IP_PREFIX + n + ":" + binaryPort;
        String remoteLogItf = IP_PREFIX + n + ":" + remoteDebugPort;
        execute(CCM_COMMAND + " add node%d -i %s%d -b -t %s -l %s --binary-itf %s -j %d -r %s -s",
            n, IP_PREFIX, n, thriftItf, storageItf, binaryItf, jmxPort, remoteLogItf);
        execute(CCM_COMMAND + " node%d start --wait-other-notice --wait-for-binary-proto", n);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619084556\fstmerge_var2_198027205531182725
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\test\java\com\datastax\driver\core\CCMBridge.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 1
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
private void maybeInitCluster(){
            if (!clusterInitialized){
                try {
                    //launch ccm cluster
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619086239\fstmerge_var1_2100187298384273001
                    ccmBridge = CCMBridge.create("test-class");
                    // Only enable user defined functions if protocol version is >= 4.
                    if(TestUtils.getDesiredProtocolVersion().compareTo(ProtocolVersion.V4) >= 0)
                        ccmBridge.updateConfig("enable_user_defined_functions", "true");
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619086239\fstmerge_base_4175018106349876374
                    ccmBridge = CCMBridge.create("test-class");
=======
                    ccmBridge = CCMBridge.builder("test-class").withoutNodes().notStarted().build();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619086239\fstmerge_var2_7473010833166801594

                    ports = new int[5];
                    for (int i = 0; i < 5; i++) {
                        ports[i] = TestUtils.findAvailablePort(11000 + i);
                    }

                    ccmBridge.bootstrapNodeWithPorts(1, ports[0], ports[1], ports[2], ports[3], ports[4], JVM_ARGS);
                    ksNumber = new AtomicLong(0);
                    erroredOut = false;
                    hostAddress = new InetSocketAddress(InetAddress.getByName(IP_PREFIX + 1), ports[2]);

                    Runtime r = Runtime.getRuntime();
                    r.addShutdownHook(new TerminationHook());
                    clusterInitialized = true;

                } catch (UnknownHostException e) {
                    throw new RuntimeException(e);
                }
            }

        }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\test\java\com\datastax\driver\core\CCMBridge.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
@BeforeClass(groups = "short")
    public void setup() {
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619173107\fstmerge_var1_6096368767269311692
        ccm = CCMBridge.create("schemaChangesTest");
        // Only enable user defined functions if protocol version is >= 4.
        if(TestUtils.getDesiredProtocolVersion().compareTo(ProtocolVersion.V4) >= 0)
            ccm.updateConfig("enable_user_defined_functions", "true");
        ccm.bootstrapNode(1);
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619173107\fstmerge_base_8492031539810020143
        ccm = CCMBridge.create("schemaChangesTest", 1);
=======
        ccm = CCMBridge.builder("schemaChangesTest").withNodes(1).build();
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619173107\fstmerge_var2_4145343228077243176

        cluster = Cluster.builder().addContactPoint(CCMBridge.ipOfNode(1)).build();
        cluster2 = Cluster.builder().addContactPoint(CCMBridge.ipOfNode(1)).build();

        metadatas = Lists.newArrayList(cluster.getMetadata(), cluster2.getMetadata());

        session = cluster.connect();
        session.execute(String.format(CREATE_KEYSPACE, "lowercase"));
        session.execute(String.format(CREATE_KEYSPACE, "\"CaseSensitive\""));
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\test\java\com\datastax\driver\core\SchemaChangesTest.java
Conflict type: EditSameMC
Number of Conflicts: 1
Different Spacing: 0
Consecutive Lines: 0
Intersection: 0
Cause same signature: 
Possible renaming: 0
EditSameMCType: 1, 0, 0
Conflict body: 
public static int numberOfLocalCoreConnections(Cluster cluster) {
        Configuration configuration = cluster.getConfiguration();
<<<<<<< C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619199504\fstmerge_var1_3758087703190435561
        ProtocolVersion protocolVersion = configuration.getProtocolOptions().getProtocolVersion();
        return (protocolVersion.compareTo(ProtocolVersion.V3) < 0)
            ? configuration.getPoolingOptions().getCoreConnectionsPerHost(HostDistance.LOCAL)
            : 1;
||||||| C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619199504\fstmerge_base_8943431030795765551
        ProtocolVersion protocolVersion = configuration.getProtocolOptions().getProtocolVersionEnum();
        return (protocolVersion.compareTo(ProtocolVersion.V3) < 0)
            ? configuration.getPoolingOptions().getCoreConnectionsPerHost(HostDistance.LOCAL)
            : 1;
=======
        return configuration.getPoolingOptions().getCoreConnectionsPerHost(HostDistance.LOCAL);
>>>>>>> C:\Users\155 X-MX\Documents\dev\second_study\conflictsAnalyzer\fstmerge_tmp1513619199504\fstmerge_var2_8086035862320184020
    }

File path: C:\download\ssmerge\java-driver\revisions\rev_1c466_a1d47\rev_rev_left_1c466-rev_right_a1d47\driver-core\src\test\java\com\datastax\driver\core\TestUtils.java

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_fdf66_13484\rev_fdf66-13484.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_ce7db_fa5db\rev_ce7db-fa5db.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_c1d8d_0e538\rev_c1d8d-0e538.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_b52bd_610c8\rev_b52bd-610c8.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_72822_1306a\rev_72822-1306a.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_f4f8c_78a90\rev_f4f8c-78a90.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_98069_4f1b6\rev_98069-4f1b6.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_67813_f63b3\rev_67813-f63b3.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_9635f_bb916\rev_9635f-bb916.revisions

==================================================================================================================
Revision: C:\download\ssmerge\java-driver\revisions\rev_1381d_b63fb\rev_1381d-b63fb.revisions

=========================================================
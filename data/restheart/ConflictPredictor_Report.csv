#MS_XXX_MS#
Merge scenario: rev_b31d2-9d265
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1bdee-360d6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_66e11-0c0c9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a8b7b-01d40
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\document\PutDocumentHandler.java
Different Spacing: false
Left editions: [100, 103]
Right editions: [111]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
        DBObject content = context.getContent();

        if (content == null) {
            content = new BasicDBObject();
        }

        // cannot PUT an array
        if (content instanceof BasicDBList) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, "data cannot be an array");
            return;
        }

// LEFT //        Object id = context.getDocumentId();

        if (content.get("_id") == null) {
// LEFT //            content.put("_id", id);
        } else if (!content.get("_id").equals(id)) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, "_id in content body is different than id in URL");
            return;
        }

        ObjectId etag = RequestHelper.getWriteEtag(exchange);
        
// RIGHT //        int httpCode = this.documentDAO.upsertDocument(
                context.getDBName(),
                context.getCollectionName(),
                context.getDocumentId(),
                content,
                etag,
                false);

        // send the warnings if any (and in case no_content change the return code to ok
        if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
            sendWarnings(httpCode, exchange, context);
        } else {
            exchange.setResponseCode(httpCode);
        }

        exchange.endExchange();
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START startServer({FormalParametersInternal})//private static void startServer() {
        if (RESTHEART_VERSION != null )
            LOGGER.info("RESTHeart version {}", RESTHEART_VERSION);

        String mongoHosts = configuration.getMongoServers().stream()
                .map(s -> s.get(Configuration.MONGO_HOST_KEY) + ":" + s.get(Configuration.MONGO_PORT_KEY) + " ")
                .reduce("", String::concat);

        LOGGER.info("initializing mongodb connection pool to {}", mongoHosts);

        try {
            MongoDBClientSingleton.init(configuration);

            LOGGER.info("mongodb connection pool initialized");

            new PropsFixer().fixAllMissingProps();
        } catch (Throwable t) {
            LOGGER.error("error connecting to mongodb. exiting..", t);
            stopServer();
            System.exit(-1);
        }

        try {
            startCoreSystem();
        } catch (Throwable t) {
            LOGGER.error("error starting RESTHeart. exiting..", t);
            stopServer();
            System.exit(-2);
        }

        Runtime.getRuntime().addShutdownHook(new Thread() {
            @Override
            public void run() {
                stopServer();
            }
        });

        LOGGER.info("RESTHeart started **********************************************");
// END startServer({FormalParametersInternal})//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [688]
Right editions: [655, 677]
Merged body: 
// START getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager, final AccessManager accessManager) {
// RIGHT //        PipedHttpHandler coreHandlerChain
                = new DbPropsInjectorHandler(
                        new CollectionPropsInjectorHandler(
                                new BodyInjectorHandler(
                                        new MetadataEnforcerHandler(
                                                new RequestDispacherHandler()
                                        )
                                )
                        )
                );

        PathHandler paths = path();

        configuration.getMongoMounts().stream().forEach(m -> {
            String url = (String) m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
            String db = (String) m.get(Configuration.MONGO_MOUNT_WHAT_KEY);

            paths.addPrefixPath(url,
                    new AuthTokenInjecterHandler(
                            new CORSHandler(
                                    new RequestContextInjectorHandler(url, db,
                                            new OptionsHandler(
// RIGHT //                                                    new SecurityHandler(coreHandlerChain, identityManager, accessManager))))));

            LOGGER.info("url {} bound to mongodb resource {}", url, db);
        });

        pipeStaticResourcesHandlers(configuration, paths, identityManager, accessManager);

        pipeApplicationLogicHandlers(configuration, paths, identityManager, accessManager);
        
        // pipe the auth tokens invalidation handler
        
// LEFT //        paths.addPrefixPath("/_authtokens", new SecurityHandler(new AuthTokenHandler(), identityManager, accessManager));

        return new GracefulShutdownHandler(
                new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),
                        new AllowedMethodsHandler(
                                new BlockingHandler(
                                        new GzipEncodingHandler(
                                                new ErrorHandler(
                                                        new HttpContinueAcceptingHandler(paths)
                                                ), configuration.isForceGzipEncoding()
                                        )
                                ), // allowed methods
                                HttpString.tryFromString(RequestContext.METHOD.GET.name()),
                                HttpString.tryFromString(RequestContext.METHOD.POST.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PUT.name()),
                                HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),
                                HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name())
                        )
                )
        );
// END getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [564, 565, 566, 567]
Right editions: []
Merged body: 
// START startCoreSystem({FormalParametersInternal})//private static void startCoreSystem() {
        if (configuration == null) {
            LOGGER.error("no configuration found. exiting..");
            stopServer();
            System.exit(-1);
        }

        if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
            LOGGER.error("no listener specified. exiting..");
            stopServer();
            System.exit(-1);
        }

        IdentityManager identityManager = null;

        if (configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no identity manager specified. authentication disabled.");
            identityManager = null;

        } else {
            try {
                Object idm = Class.forName(configuration.getIdmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getIdmArgs());
                identityManager = (IdentityManager) idm;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring idm implementation {}", configuration.getIdmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }

        AccessManager accessManager = null;

        if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
            LOGGER.warn("***** no access manager specified. authenticated users can do anything.");
            accessManager = null;
        } else if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no access manager specified. users can do anything.");
            accessManager = null;

        } else {
            try {
                Object am = Class.forName(configuration.getAmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getAmArgs());
                accessManager = (AccessManager) am;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring acess manager implementation {}", configuration.getAmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }
// LEFT //        
// LEFT //        if (configuration.isAuthTokenEnabled()) {
// LEFT //            LOGGER.info("token based authentication enabled with token TTL {} minutes", configuration.getAuthTokenTtl());
// LEFT //        }

        SSLContext sslContext = null;

        try {
            KeyManagerFactory kmf;
            KeyStore ks;

            if (getConf().isUseEmbeddedKeystore()) {
                char[] storepass = "restheart".toCharArray();
                char[] keypass = "restheart".toCharArray();

                String storename = "rakeystore.jks";

                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");
                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);

                kmf.init(ks, keypass);

                sslContext.init(kmf.getKeyManagers(), null, null);
            } else {
                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {
                    ks.load(fis, configuration.getKeystorePassword().toCharArray());

                    kmf.init(ks, configuration.getCertPassword().toCharArray());
                    sslContext.init(kmf.getKeyManagers(), null, null);
                }
            }
        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {
            LOGGER.error("couldn't start RESTHeart, error with specified keystore. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (FileNotFoundException ex) {
            LOGGER.error("couldn't start RESTHeart, keystore file not found. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (IOException ex) {
            LOGGER.error("couldn't start RESTHeart, error reading the keystore file. exiting..", ex);
            stopServer();
            System.exit(-1);
        }

        Builder builder = Undertow.builder();

        if (configuration.isHttpsListener()) {
            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);
            LOGGER.info("https listener bound at {}:{}", configuration.getHttpsHost(), configuration.getHttpsPort());
        }

        if (configuration.isHttpListener()) {
            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());
            LOGGER.info("http listener bound at {}:{}", configuration.getHttpHost(), configuration.getHttpPort());
        }

        if (configuration.isAjpListener()) {
            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());
            LOGGER.info("ajp listener bound at {}:{}", configuration.getAjpHost(), configuration.getAjpPort());
        }

        LocalCachesSingleton.init(configuration);

        if (configuration.isLocalCacheEnabled()) {
            LOGGER.info("local cache enabled");
        } else {
            LOGGER.info("local cache not enabled");
        }

        hanldersPipe = getHandlersPipe(identityManager, accessManager);

        builder
                .setIoThreads(configuration.getIoThreads())
                .setWorkerThreads(configuration.getWorkerThreads())
                .setDirectBuffers(configuration.isDirectBuffers())
                .setBufferSize(configuration.getBufferSize())
                .setBuffersPerRegion(configuration.getBuffersPerRegion())
                .setHandler(hanldersPipe);

        builder.build().start();
// END startCoreSystem({FormalParametersInternal})//    }
Edition adds call: 0
#HAS_***REFERENCE_#

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\document\PatchDocumentHandler.java
Different Spacing: false
Left editions: [92, 95]
Right editions: [80, 81, 87, 88, 97, 98]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
        DBObject content = context.getContent();

        // cannot PATCH with no data
        if (content == null) {
// RIGHT //            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE,
// RIGHT //                    "data is empty");
            return;
        }

        // cannot PATCH an array
        if (content instanceof BasicDBList) {
// RIGHT //            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE,
// RIGHT //                    "data cannot be an array");
            return;
        }

// LEFT //        Object id = context.getDocumentId();

        if (content.get("_id") == null) {
// LEFT //            content.put("_id", id);
        } else if (!content.get("_id").equals(id)) {
// RIGHT //            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, 
// RIGHT //                    "_id in json data cannot be different than id in URL");
            return;
        }

        ObjectId etag = RequestHelper.getWriteEtag(exchange);

        if (etag == null) {
            ResponseHelper.endExchange(exchange, HttpStatus.SC_CONFLICT);
            return;
        }

        int httpCode = documentDAO.upsertDocument(
                context.getDBName(),
                context.getCollectionName(),
                context.getDocumentId(),
                content,
                etag,
                true);

        // send the warnings if any (and in case no_content change the return code to ok
        if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
            sendWarnings(httpCode, exchange, context);
        } else {
            exchange.setResponseCode(httpCode);
        }

        exchange.endExchange();
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\database\DBRepresentationFactory.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START addLinkTemplatesAndCuries(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext-Representation-Representation-String-String)//private void addLinkTemplatesAndCuries(final HttpServerExchange exchange, final RequestContext context, final Representation rep, final String requestPath) {
        // link templates and curies
        if (context.isParentAccessible()) {
            // this can happen due to mongo-mounts mapped URL
            rep.addLink(new Link("rh:root", URLUtils.getParentPath(requestPath)));
        }
        rep.addLink(new Link("rh:paging", requestPath + "/{?page}{&pagesize}", true));
        rep.addLink(new Link("rh", "curies", Configuration.RESTHEART_ONLINE_DOC_URL + "/#api-db-{rel}", false), true);
// END addLinkTemplatesAndCuries(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext-Representation-Representation-String-String)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\database\DBRepresentationFactory.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START embeddedCollections(List<DBObject>-List<DBObject>-String-String-Representation-Representation)//private void embeddedCollections(
            final List<DBObject> embeddedData, 
            final String requestPath, 
            final Representation rep) {
        embeddedData.stream().forEach((d) -> {
            Object _id = d.get("_id");

            if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
                Representation nrep = new Representation(requestPath + "/" + _id.toString());

                nrep.addProperty("_type", RequestContext.TYPE.COLLECTION.name());

                if (d.get("_etag") != null && d.get("_etag") instanceof ObjectId) {
                    d.put("_etag", ((ObjectId) d.get("_etag")).toString()); // represent the etag as a string
                }
                nrep.addProperties(d);

                rep.addRepresentation("rh:coll", nrep);
            } else {
                logger.error("document missing string _id field", d);
            }
        });
// END embeddedCollections(List<DBObject>-List<DBObject>-String-String-Representation-Representation)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\injectors\RequestContextInjectorHandler.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
        RequestContext rcontext = new RequestContext(exchange, whereUri, whatUri);

        Deque<String> __pagesize = exchange.getQueryParameters().get(PAGESIZE_QPARAM_KEY);

        int page = 1; // default page
        int pagesize = 100; // default pagesize

        if (__pagesize != null && !(__pagesize.isEmpty())) {
            try {
                pagesize = Integer.parseInt(__pagesize.getFirst());
            } catch (NumberFormatException ex) {
                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                        "illegal pagesize paramenter, it is not a number", ex);
                return;
            }
        }

        if (pagesize < 1 || pagesize > 1000) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                    "illegal page parameter, pagesize must be >= 0 and <= 1000");
            return;
        } else {
            rcontext.setPagesize(pagesize);
        }

        Deque<String> __page = exchange.getQueryParameters().get(PAGE_QPARAM_KEY);

        if (__page != null && !(__page.isEmpty())) {
            try {
                page = Integer.parseInt(__page.getFirst());
            } catch (NumberFormatException ex) {
                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                        "illegal page paramenter, it is not a number", ex);
                return;
            }
        }

        if (page < 1) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                    "illegal page paramenter, it is < 1");
            return;
        } else {
            rcontext.setPage(page);
        }

        Deque<String> __count = exchange.getQueryParameters().get("count");

        if (__count != null) {
            rcontext.setCount(true);
        }
        // get and check sort_by parameter
        Deque<String> sort_by = exchange.getQueryParameters().get("sort_by");

        if (sort_by != null) {
            if (sort_by.stream().anyMatch(s -> s == null || s.isEmpty())) {
                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                        "illegal sort_by paramenter");
                return;
            }

            rcontext.setSortBy(exchange.getQueryParameters().get(SORT_BY_QPARAM_KEY));
        }

        // get and check filter parameter
        Deque<String> filters = exchange.getQueryParameters().get(FILTER_QPARAM_KEY);

        if (filters != null) {
            if (filters.stream().anyMatch(f -> {
                if (f == null || f.isEmpty()) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                            "illegal filter paramenter (empty)");
                    return true;
                }

                try {
                    JSON.parse(f);
                } catch (Throwable t) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                            "illegal filter paramenter: " + f, t);
                    return true;
                }

                return false;
            })) {
                return; // an error occurred
            }

            rcontext.setFilter(exchange.getQueryParameters().get(FILTER_QPARAM_KEY));
        }

        // get and check eager parameter
        Deque<String> __eager = exchange.getQueryParameters().get(EAGER_CURSOR_ALLOCATION_POLICY_QPARAM_KEY);

        // default value
        EAGER_CURSOR_ALLOCATION_POLICY eager = EAGER_CURSOR_ALLOCATION_POLICY.LINEAR;

        if (__eager != null && !__eager.isEmpty()) {
            String _eager = __eager.getFirst();

            if (_eager != null && !_eager.isEmpty()) {
                try {
                    eager = EAGER_CURSOR_ALLOCATION_POLICY.valueOf(_eager.trim().toUpperCase());
                } catch (IllegalArgumentException iae) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST, "illegal eager paramenter (must be LINEAR, RANDOM or NONE)");
                    return;
                }
            }
        }

        rcontext.setCursorAllocationPolicy(eager);

        // get and check the doc id type parameter
        Deque<String> __docIdType = exchange.getQueryParameters().get(DOC_ID_TYPE_KEY);

        // default value
        URLUtils.DOC_ID_TYPE docIdType = URLUtils.DOC_ID_TYPE.STRING_OBJECTID;

        if (__docIdType != null && !__docIdType.isEmpty()) {
            String _docIdType = __docIdType.getFirst();

            if (_docIdType != null && !_docIdType.isEmpty()) {
                try {
                    docIdType = URLUtils.DOC_ID_TYPE.valueOf(_docIdType.trim().toUpperCase());
                } catch (IllegalArgumentException iae) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST, "illegal " + DOC_ID_TYPE_KEY + " paramenter (must be STRING_OBJECTID, INT, LONG, FLOAT, DOUBLE, STRING or OBJECTID)");
                    return;
                }
            }
        }

        rcontext.setDocIdType(docIdType);
        
        // get and check the document id
        
        String _docId = rcontext.getDocumentIdRaw();
        
        try {
            rcontext.setDocumentId(URLUtils.getId(_docId, docIdType));
        } catch(IllegalDocumentIdException idide) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST, "wrong document id format. it is not a valid " + docIdType.name());
            return;
        }

        // get the autodetect objectid parameter
        Deque<String> __autodetectObjectId = exchange.getQueryParameters().get(DETECT_OBJECTIDS_KEY);

        // default value
        boolean detectObjectIds = true;

        if (__autodetectObjectId != null && !__autodetectObjectId.isEmpty()) {
            String _autodetectObjectId = __autodetectObjectId.getFirst();

            if (_autodetectObjectId != null && !_autodetectObjectId.isEmpty()) {
                detectObjectIds = "true".equalsIgnoreCase(_autodetectObjectId);
            }
        }

        rcontext.setDetectObjectIds(detectObjectIds);
        
        next.handleRequest(exchange, rcontext);
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: []
Right editions: [116]
Merged body: 
// START getCollection(String-String-String-String)//// RIGHT //DBCollection getCollection(String dbName, String collName) {
        return client.getDB(dbName).getCollection(collName);
// END getCollection(String-String-String-String)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [473, 475, 478, 483]
Right editions: [471]
Merged body: 
// START deleteCollection(String-String-String-String-ObjectId-ObjectId)//// RIGHT //int deleteCollection(String dbName, String collName, ObjectId etag) {
        DBCollection coll = getCollection(dbName, collName);
// LEFT //        DBCollection propsColl = getCollection(dbName, "_properties");

// LEFT //        BasicDBObject checkEtag = new BasicDBObject("_id", "_properties.".concat(collName));
        checkEtag.append("_etag", etag);

// LEFT //        DBObject exists = propsColl.findOne(checkEtag, fieldsToReturn);

        if (exists == null) {
            return HttpStatus.SC_PRECONDITION_FAILED;
        } else {
// LEFT //            propsColl.remove(new BasicDBObject("_id", "_properties.".concat(collName)));
            coll.drop();
            return HttpStatus.SC_NO_CONTENT;
        }
// END deleteCollection(String-String-String-String-ObjectId-ObjectId)//    }
Edition adds call: 1
#HAS_***REFERENCE_#

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [215]
Right editions: [191]
Merged body: 
// START getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//// RIGHT //DBCursor getCollectionDBCursor(DBCollection coll, Deque<String> sortBy, Deque<String> filters) throws JSONParseException {
        // apply sort_by
        DBObject sort = new BasicDBObject();

        if (sortBy == null || sortBy.isEmpty()) {
            sort.put("_created_on", -1);
        } else {
            sortBy.stream().forEach((s) -> {

                String _s = s.trim(); // the + sign is decoded into a space, in case remove it

                _s = _s.replaceAll("_lastupdated_on", "_etag"); // _lastupdated is not stored and actually generated from @etag

                if (_s.startsWith("-")) {
                    sort.put(_s.substring(1), -1);
                } else if (_s.startsWith("+")) {
                    sort.put(_s.substring(1), 1);
                } else {
                    sort.put(_s, 1);
                }
            });
        }

        // apply filter
// LEFT //        final BasicDBObject query = new BasicDBObject();

        if (filters != null) {
            filters.stream().forEach((String f) -> {
                BSONObject filterQuery = (BSONObject) JSON.parse(f);

                query.putAll(filterQuery);  // this can throw JSONParseException for invalid filter parameters
            });
        }

        return coll.find(query).sort(sort);
// END getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [386, 397, 400, 418, 424, 432, 439, 445, 452, 454]
Right editions: [383, 384]
Merged body: 
// START upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//// RIGHT //int upsertCollection(String dbName, String collName, DBObject content, ObjectId etag, boolean updating, boolean patching) {
// RIGHT //        DB db = client.getDB(dbName);

// LEFT //        DBCollection propsColl = db.getCollection("_properties");

        if (patching && !updating) {
            return HttpStatus.SC_NOT_FOUND;
        }

        if (updating) {
            if (etag == null) {
                return HttpStatus.SC_CONFLICT;
            }

// LEFT //            BasicDBObject idAndEtagQuery = new BasicDBObject("_id", "_properties.".concat(collName));
            idAndEtagQuery.append("_etag", etag);

// LEFT //            if (propsColl.count(idAndEtagQuery) < 1) {
                return HttpStatus.SC_PRECONDITION_FAILED;
            }
        }

        ObjectId timestamp = new ObjectId();
        Instant now = Instant.ofEpochSecond(timestamp.getTimestamp());

        if (content == null) {
            content = new BasicDBObject();
        }

        content.removeField("_id"); // make sure we don't change this field

        if (updating) {
            content.removeField("_crated_on"); // don't allow to update this field
            content.put("_etag", timestamp);
        } else {
// LEFT //            content.put("_id", "_properties.".concat(collName));
            content.put("_created_on", now.toString());
            content.put("_etag", timestamp);
        }

        if (patching) {
// LEFT //            propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), new BasicDBObject("$set", content), true, false);
            return HttpStatus.SC_OK;
        } else {
            // we use findAndModify to get the @created_on field value from the existing properties document
            // we need to put this field back using a second update 
            // it is not possible in a single update even using $setOnInsert update operator
            // in this case we need to provide the other data using $set operator and this makes it a partial update (patch semantic) 

// LEFT //            DBObject old = propsColl.findAndModify(new BasicDBObject("_id", "_properties.".concat(collName)), fieldsToReturn, null, false, content, false, true);

            if (old != null) {
                Object oldTimestamp = old.get("_created_on");

                if (oldTimestamp == null) {
                    oldTimestamp = now.toString();
// LEFT //                    LOGGER.warn("properties of collection {} had no @created_on field. set it to now", dbName + "." + collName);
                }

                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", "" + oldTimestamp);
                createdContent.markAsPartialObject();
// LEFT //                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), new BasicDBObject("$set", createdContent), true, false);

                return HttpStatus.SC_OK;
            } else {
                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", now.toString());
                createdContent.markAsPartialObject();
// LEFT //                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), new BasicDBObject("$set", createdContent), true, false);

// LEFT //                initDefaultIndexes(db.getCollection(collName));

                return HttpStatus.SC_CREATED;
            }
        }
// END upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [473, 475, 478, 483]
Right editions: [471]
Merged body: 
// START deleteCollection(String-String-String-String-ObjectId-ObjectId)//// RIGHT //int deleteCollection(String dbName, String collName, ObjectId etag) {
        DBCollection coll = getCollection(dbName, collName);
// LEFT //        DBCollection propsColl = getCollection(dbName, "_properties");

// LEFT //        BasicDBObject checkEtag = new BasicDBObject("_id", "_properties.".concat(collName));
        checkEtag.append("_etag", etag);

// LEFT //        DBObject exists = propsColl.findOne(checkEtag, fieldsToReturn);

        if (exists == null) {
            return HttpStatus.SC_PRECONDITION_FAILED;
        } else {
// LEFT //            propsColl.remove(new BasicDBObject("_id", "_properties.".concat(collName)));
            coll.drop();
            return HttpStatus.SC_NO_CONTENT;
        }
// END deleteCollection(String-String-String-String-ObjectId-ObjectId)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\document\GetDocumentHandler.java
Different Spacing: false
Left editions: [86, 110]
Right editions: [88]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
// LEFT //        BasicDBObject query = new BasicDBObject("_id", context.getDocumentId());;

// RIGHT //        DBObject document = dbsDAO.getCollection(context.getDBName(), context.getCollectionName()).findOne(query);

        if (document == null) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_FOUND, "document does not exist");
            return;
        }

        Object etag = document.get("_etag");

        if (etag != null && ObjectId.isValid("" + etag)) {
            ObjectId _etag = new ObjectId("" + etag);

            document.put("_lastupdated_on", Instant.ofEpochSecond(_etag.getTimestamp()).toString());

            // in case the request contains the IF_NONE_MATCH header with the current etag value,
            // just return 304 NOT_MODIFIED code
            if (RequestHelper.checkReadEtag(exchange, etag.toString())) {
                ResponseHelper.endExchange(exchange, HttpStatus.SC_NOT_MODIFIED);
                return;
            }
        }

// LEFT //        String requestPath = URLUtils.removeTrailingSlashes(exchange.getRequestPath());

        ResponseHelper.injectEtagHeader(exchange, document);
        exchange.setResponseCode(HttpStatus.SC_OK);

        DocumentRepresentationFactory.sendDocument(requestPath, exchange, context, document);
        exchange.endExchange();
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c96bc-9ce4e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6ce44-89c22
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e5135-a8a75
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2e9a8-40697
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_2e9a8_40697\rev_rev_left_2e9a8-rev_right_40697\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [638, 646]
Right editions: [545, 548]
Merged body: 
// START startCoreSystem({FormalParametersInternal})//private static void startCoreSystem() {
        if (configuration == null) {
            LOGGER.error("no configuration found. exiting..");
            stopServer();
            System.exit(-1);
        }

        if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
            LOGGER.error("no listener specified. exiting..");
            stopServer();
            System.exit(-1);
        }

        IdentityManager identityManager = null;

        if (configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no identity manager specified. authentication disabled.");
            identityManager = null;

        } else {
            try {
                Object idm = Class.forName(configuration.getIdmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getIdmArgs());
                identityManager = (IdentityManager) idm;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring idm implementation {}", configuration.getIdmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }

        AccessManager accessManager = null;

        if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
            LOGGER.warn("***** no access manager specified. authenticated users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();
        } else if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no access manager specified. users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();

        } else {
            try {
                Object am = Class.forName(configuration.getAmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getAmArgs());
                accessManager = (AccessManager) am;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring acess manager implementation {}", configuration.getAmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }
        
        if (configuration.isAuthTokenEnabled()) {
            LOGGER.info("token based authentication enabled with token TTL {} minutes", configuration.getAuthTokenTtl());
        }

        SSLContext sslContext = null;

        try {
            KeyManagerFactory kmf;
            KeyStore ks;

            if (getConf().isUseEmbeddedKeystore()) {
                char[] storepass = "restheart".toCharArray();
                char[] keypass = "restheart".toCharArray();

                String storename = "rakeystore.jks";

                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");
                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);

                kmf.init(ks, keypass);

                sslContext.init(kmf.getKeyManagers(), null, null);
            } else {
                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {
                    ks.load(fis, configuration.getKeystorePassword().toCharArray());

                    kmf.init(ks, configuration.getCertPassword().toCharArray());
                    sslContext.init(kmf.getKeyManagers(), null, null);
                }
            }
        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {
            LOGGER.error("couldn't start RESTHeart, error with specified keystore. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (FileNotFoundException ex) {
            LOGGER.error("couldn't start RESTHeart, keystore file not found. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (IOException ex) {
            LOGGER.error("couldn't start RESTHeart, error reading the keystore file. exiting..", ex);
            stopServer();
            System.exit(-1);
        }

        Builder builder = Undertow.builder();

        if (configuration.isHttpsListener()) {
            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);
            LOGGER.info("https listener bound at {}:{}", configuration.getHttpsHost(), configuration.getHttpsPort());
        }

        if (configuration.isHttpListener()) {
            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());
            LOGGER.info("http listener bound at {}:{}", configuration.getHttpHost(), configuration.getHttpPort());
        }

        if (configuration.isAjpListener()) {
            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());
            LOGGER.info("ajp listener bound at {}:{}", configuration.getAjpHost(), configuration.getAjpPort());
        }

        LocalCachesSingleton.init(configuration);

        if (configuration.isLocalCacheEnabled()) {
            LOGGER.info("local cache enabled");
        } else {
            LOGGER.info("local cache not enabled");
        }

// LEFT //        shutdownHandler = getHandlersPipe(identityManager, accessManager);

        builder
                .setIoThreads(configuration.getIoThreads())
                .setWorkerThreads(configuration.getWorkerThreads())
                .setDirectBuffers(configuration.isDirectBuffers())
                .setBufferSize(configuration.getBufferSize())
                .setBuffersPerRegion(configuration.getBuffersPerRegion())
// LEFT //                .setHandler(shutdownHandler);

        builder.build().start();
// END startCoreSystem({FormalParametersInternal})//    }

#CP_===_CP#
#CP_===_CP#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_2e9a8_40697\rev_rev_left_2e9a8-rev_right_40697\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: []
Right editions: [686]
Merged body: 
// START getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager, final AccessManager accessManager) {
        PipedHttpHandler coreHandlerChain
                = new DbPropsInjectorHandler(
                        new CollectionPropsInjectorHandler(
                                new BodyInjectorHandler(
                                        new RequestScriptMetadataHandler(
                                                new RequestDispacherHandler()
                                        )
                                )
                        )
                );

        PathHandler paths = path();

        configuration.getMongoMounts().stream().forEach(m -> {
            String url = (String) m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
            String db = (String) m.get(Configuration.MONGO_MOUNT_WHAT_KEY);

            paths.addPrefixPath(url,
                    new AuthTokenInjecterHandler(
                            new CORSHandler(
                                    new RequestContextInjectorHandler(url, db,
                                            new OptionsHandler(
                                                    new SecurityHandler(coreHandlerChain, identityManager, accessManager))))));

            LOGGER.info("url {} bound to mongodb resource {}", url, db);
        });

        pipeStaticResourcesHandlers(configuration, paths, identityManager, accessManager);

        pipeApplicationLogicHandlers(configuration, paths, identityManager, accessManager);
        
        // pipe the auth tokens invalidation handler
        
// RIGHT //        paths.addPrefixPath("/_authtokens", new AuthTokenInjecterHandler(new CORSHandler(new SecurityHandler(new AuthTokenHandler(), identityManager, new FullAccessManager()))));

        return new GracefulShutdownHandler(
                new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),
                        new AllowedMethodsHandler(
                                new BlockingHandler(
                                        new GzipEncodingHandler(
                                                new ErrorHandler(
                                                        new HttpContinueAcceptingHandler(paths)
                                                ), configuration.isForceGzipEncoding()
                                        )
                                ), // allowed methods
                                HttpString.tryFromString(RequestContext.METHOD.GET.name()),
                                HttpString.tryFromString(RequestContext.METHOD.POST.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PUT.name()),
                                HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),
                                HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name())
                        )
                )
        );
// END getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_2e9a8_40697\rev_rev_left_2e9a8-rev_right_40697\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [638, 646]
Right editions: [545, 548]
Merged body: 
// START startCoreSystem({FormalParametersInternal})//private static void startCoreSystem() {
        if (configuration == null) {
            LOGGER.error("no configuration found. exiting..");
            stopServer();
            System.exit(-1);
        }

        if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
            LOGGER.error("no listener specified. exiting..");
            stopServer();
            System.exit(-1);
        }

        IdentityManager identityManager = null;

        if (configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no identity manager specified. authentication disabled.");
            identityManager = null;

        } else {
            try {
                Object idm = Class.forName(configuration.getIdmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getIdmArgs());
                identityManager = (IdentityManager) idm;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring idm implementation {}", configuration.getIdmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }

        AccessManager accessManager = null;

        if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
            LOGGER.warn("***** no access manager specified. authenticated users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();
        } else if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no access manager specified. users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();

        } else {
            try {
                Object am = Class.forName(configuration.getAmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getAmArgs());
                accessManager = (AccessManager) am;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring acess manager implementation {}", configuration.getAmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }
        
        if (configuration.isAuthTokenEnabled()) {
            LOGGER.info("token based authentication enabled with token TTL {} minutes", configuration.getAuthTokenTtl());
        }

        SSLContext sslContext = null;

        try {
            KeyManagerFactory kmf;
            KeyStore ks;

            if (getConf().isUseEmbeddedKeystore()) {
                char[] storepass = "restheart".toCharArray();
                char[] keypass = "restheart".toCharArray();

                String storename = "rakeystore.jks";

                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");
                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);

                kmf.init(ks, keypass);

                sslContext.init(kmf.getKeyManagers(), null, null);
            } else {
                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {
                    ks.load(fis, configuration.getKeystorePassword().toCharArray());

                    kmf.init(ks, configuration.getCertPassword().toCharArray());
                    sslContext.init(kmf.getKeyManagers(), null, null);
                }
            }
        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {
            LOGGER.error("couldn't start RESTHeart, error with specified keystore. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (FileNotFoundException ex) {
            LOGGER.error("couldn't start RESTHeart, keystore file not found. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (IOException ex) {
            LOGGER.error("couldn't start RESTHeart, error reading the keystore file. exiting..", ex);
            stopServer();
            System.exit(-1);
        }

        Builder builder = Undertow.builder();

        if (configuration.isHttpsListener()) {
            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);
            LOGGER.info("https listener bound at {}:{}", configuration.getHttpsHost(), configuration.getHttpsPort());
        }

        if (configuration.isHttpListener()) {
            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());
            LOGGER.info("http listener bound at {}:{}", configuration.getHttpHost(), configuration.getHttpPort());
        }

        if (configuration.isAjpListener()) {
            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());
            LOGGER.info("ajp listener bound at {}:{}", configuration.getAjpHost(), configuration.getAjpPort());
        }

        LocalCachesSingleton.init(configuration);

        if (configuration.isLocalCacheEnabled()) {
            LOGGER.info("local cache enabled");
        } else {
            LOGGER.info("local cache not enabled");
        }

// LEFT //        shutdownHandler = getHandlersPipe(identityManager, accessManager);

        builder
                .setIoThreads(configuration.getIoThreads())
                .setWorkerThreads(configuration.getWorkerThreads())
                .setDirectBuffers(configuration.isDirectBuffers())
                .setBufferSize(configuration.getBufferSize())
                .setBuffersPerRegion(configuration.getBuffersPerRegion())
// LEFT //                .setHandler(shutdownHandler);

        builder.build().start();
// END startCoreSystem({FormalParametersInternal})//    }
Edition adds call: 1
#HAS_***REFERENCE_#

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_dcff0-47433
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ef43a-7f21b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_22db0-7b303
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e8678-3d605
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//DBCursor getCollectionDBCursor(
            final DBCollection coll, 
            final Deque<String> sortBy, 
            final Deque<String> filters, 
            final Deque<String> keys) throws JSONParseException {
        // apply sort_by
        DBObject sort = new BasicDBObject();

        if (sortBy == null || sortBy.isEmpty()) {
            sort.put("_id", -1);
        } else {
            sortBy.stream().forEach((s) -> {

                String _s = s.trim(); // the + sign is decoded into a space, in case remove it

                if (_s.startsWith("-")) {
                    sort.put(_s.substring(1), -1);
                } else if (_s.startsWith("+")) {
                    sort.put(_s.substring(1), 1);
                } else {
                    sort.put(_s, 1);
                }
            });
        }

        // apply filter
        final BasicDBObject query = new BasicDBObject();

        if (filters != null) {
            filters.stream().forEach((String f) -> {
                BSONObject filterQuery = (BSONObject) JSON.parse(f);

                query.putAll(filterQuery);  // this can throw JSONParseException for invalid filter parameters
            });
        }

        final BasicDBObject fields = new BasicDBObject();

        if (keys != null) {
            keys.stream().forEach((String f) -> {
                BSONObject keyQuery = (BSONObject) JSON.parse(f);

                fields.putAll(keyQuery);  // this can throw JSONParseException for invalid filter parameters
            });
        }

        return coll.find(query, fields).sort(sort);
// END getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//OperationResult upsertCollection(
            final String dbName, 
            final String collName, 
            final DBObject properties, 
            final ObjectId requestEtag, 
            final boolean updating, 
            final boolean patching) {
        
        DB db = client.getDB(dbName);

        if (patching && !updating) {
            return new OperationResult(HttpStatus.SC_NOT_FOUND);
        }

        final DBCollection propsColl = db.getCollection("_properties");

        final DBObject exists = propsColl.findOne(new BasicDBObject("_id", "_properties.".concat(collName)), FIELDS_TO_RETURN);

        if (exists == null && updating) {
            LOGGER.error("updating but cannot find collection _properties.{} for {}/{}", collName, dbName, collName);
            return new OperationResult(HttpStatus.SC_NOT_FOUND);
        } else if (exists != null) {
            Object oldEtag = exists.get("_etag");

            if (oldEtag != null) {
                if (requestEtag == null) {
                    return new OperationResult(HttpStatus.SC_CONFLICT, oldEtag);
                }

                if (!oldEtag.equals(requestEtag)) {
                    return new OperationResult(HttpStatus.SC_PRECONDITION_FAILED, oldEtag);
                }
            }
        }

        ObjectId newEtag = new ObjectId();
        Instant now = Instant.ofEpochSecond(newEtag.getTimestamp());

        final DBObject content = DAOUtils.validContent(properties);

        content.removeField("_id"); // make sure we don't change this field

        if (updating) {
            content.removeField("_crated_on"); // don't allow to update this field
            content.put("_etag", newEtag);
        } else {
            content.put("_id", "_properties.".concat(collName));
            content.put("_created_on", now.toString());
            content.put("_etag", newEtag);
        }

        if (patching) {
            propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), 
                    new BasicDBObject("$set", content), true, false);
            return new OperationResult(HttpStatus.SC_OK, newEtag);
        } else {
            // we use findAndModify to get the @created_on field value from the existing properties document
            // we need to put this field back using a second update 
            // it is not possible in a single update even using $setOnInsert update operator
            // in this case we need to provide the other data using $set operator and this makes it a partial update (patch semantic) 

            DBObject old = propsColl.findAndModify(new BasicDBObject("_id", "_properties.".concat(collName)),
                    FIELDS_TO_RETURN, null, false, content, false, true);

            if (old != null) {
                Object oldTimestamp = old.get("_created_on");

                if (oldTimestamp == null) {
                    oldTimestamp = now.toString();
                    LOGGER.warn("properties of collection {} had no @created_on field. set it to now", dbName + "." + collName);
                }

                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", "" + oldTimestamp);
                createdContent.markAsPartialObject();
                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)),
                        new BasicDBObject("$set", createdContent), true, false);

                return new OperationResult(HttpStatus.SC_OK, newEtag);
            } else {
                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", now.toString());
                createdContent.markAsPartialObject();
                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), 
                        new BasicDBObject("$set", createdContent), true, false);

                initDefaultIndexes(db.getCollection(collName));

                return new OperationResult(HttpStatus.SC_CREATED, newEtag);
            }
        }
// END upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\DBCursorPool.java
Different Spacing: false
Left editions: [254, 271, 272, 274, 275, 276, 277, 278, 279]
Right editions: [266]
Merged body: 
// START populateCacheRandom(DBCursorPoolEntryKey-DBCursorPoolEntryKey)//private void populateCacheRandom(DBCursorPoolEntryKey key) {
        executor.submit(() -> {
            Long size = collSizes.getLoading(key).get();

            int sliceWidht;
// LEFT //            int slices;
            int totalSlices = size.intValue() / SKIP_SLICE_RND_MIN_WIDTH + 1;

            if (totalSlices <= SKIP_SLICE_RND_MAX_CURSORS) {
                slices = totalSlices;
                sliceWidht = SKIP_SLICE_RND_MIN_WIDTH;
            } else {
                slices = SKIP_SLICE_RND_MAX_CURSORS;
                sliceWidht = size.intValue() / slices;
            }

            for (int slice = 1; slice < slices; slice++) {
// RIGHT //                int sliceSkips = slice * sliceWidht;

                DBCursorPoolEntryKey sliceKey = new DBCursorPoolEntryKey(key.getCollection(), key.getSort(), key.getFilter(), key.getKeys(), sliceSkips, -1);

                long existing = getSliceHeight(sliceKey);
// LEFT //                
// LEFT //                if (existing == 0) {
                    DBCursor cursor = dbsDAO.getCollectionDBCursor(key.getCollection(), key.getSort(), key.getFilter(), key.getKeys());
// LEFT //                    cursor
// LEFT //                            .skip(sliceSkips)
// LEFT //                            .limit(1000 + sliceWidht);
// LEFT //                    
// LEFT //                    cursor.hasNext(); // this forces the actual skipping
// LEFT //                    
                    DBCursorPoolEntryKey newkey = new DBCursorPoolEntryKey(key.getCollection(), key.getSort(), key.getFilter(), key.getKeys(), sliceSkips, System.nanoTime());
                    cache.put(newkey, cursor);
                    LOGGER.debug("created new cursor in pool: {}", newkey);
                }
            }
        });
// END populateCacheRandom(DBCursorPoolEntryKey-DBCursorPoolEntryKey)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\DBCursorPool.java
Different Spacing: false
Left editions: [191]
Right editions: []
Merged body: 
// START populateCache(DBCursorPoolEntryKey-DBCursorPoolEntryKey-EAGER_CURSOR_ALLOCATION_POLICY-EAGER_CURSOR_ALLOCATION_POLICY)//// LEFT //void populateCache(DBCursorPoolEntryKey key, EAGER_CURSOR_ALLOCATION_POLICY allocationPolicy) {
        if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.LINEAR) {
            populateCacheLinear(key);
        } else if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.RANDOM) {
            populateCacheRandom(key);
        }
// END populateCache(DBCursorPoolEntryKey-DBCursorPoolEntryKey-EAGER_CURSOR_ALLOCATION_POLICY-EAGER_CURSOR_ALLOCATION_POLICY)//    }
Edition adds call: 0
#HAS_***REFERENCE_#

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1bdee-360d6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_66e11-0c0c9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a8b7b-01d40
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\document\PutDocumentHandler.java
Different Spacing: false
Left editions: [100, 103]
Right editions: [111]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
        DBObject content = context.getContent();

        if (content == null) {
            content = new BasicDBObject();
        }

        // cannot PUT an array
        if (content instanceof BasicDBList) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, "data cannot be an array");
            return;
        }

// LEFT //        Object id = context.getDocumentId();

        if (content.get("_id") == null) {
// LEFT //            content.put("_id", id);
        } else if (!content.get("_id").equals(id)) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, "_id in content body is different than id in URL");
            return;
        }

        ObjectId etag = RequestHelper.getWriteEtag(exchange);
        
// RIGHT //        int httpCode = this.documentDAO.upsertDocument(
                context.getDBName(),
                context.getCollectionName(),
                context.getDocumentId(),
                content,
                etag,
                false);

        // send the warnings if any (and in case no_content change the return code to ok
        if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
            sendWarnings(httpCode, exchange, context);
        } else {
            exchange.setResponseCode(httpCode);
        }

        exchange.endExchange();
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START startServer({FormalParametersInternal})//private static void startServer() {
        if (RESTHEART_VERSION != null )
            LOGGER.info("RESTHeart version {}", RESTHEART_VERSION);

        String mongoHosts = configuration.getMongoServers().stream()
                .map(s -> s.get(Configuration.MONGO_HOST_KEY) + ":" + s.get(Configuration.MONGO_PORT_KEY) + " ")
                .reduce("", String::concat);

        LOGGER.info("initializing mongodb connection pool to {}", mongoHosts);

        try {
            MongoDBClientSingleton.init(configuration);

            LOGGER.info("mongodb connection pool initialized");

            new PropsFixer().fixAllMissingProps();
        } catch (Throwable t) {
            LOGGER.error("error connecting to mongodb. exiting..", t);
            stopServer();
            System.exit(-1);
        }

        try {
            startCoreSystem();
        } catch (Throwable t) {
            LOGGER.error("error starting RESTHeart. exiting..", t);
            stopServer();
            System.exit(-2);
        }

        Runtime.getRuntime().addShutdownHook(new Thread() {
            @Override
            public void run() {
                stopServer();
            }
        });

        LOGGER.info("RESTHeart started **********************************************");
// END startServer({FormalParametersInternal})//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [688]
Right editions: [655, 677]
Merged body: 
// START getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager, final AccessManager accessManager) {
// RIGHT //        PipedHttpHandler coreHandlerChain
                = new DbPropsInjectorHandler(
                        new CollectionPropsInjectorHandler(
                                new BodyInjectorHandler(
                                        new MetadataEnforcerHandler(
                                                new RequestDispacherHandler()
                                        )
                                )
                        )
                );

        PathHandler paths = path();

        configuration.getMongoMounts().stream().forEach(m -> {
            String url = (String) m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
            String db = (String) m.get(Configuration.MONGO_MOUNT_WHAT_KEY);

            paths.addPrefixPath(url,
                    new AuthTokenInjecterHandler(
                            new CORSHandler(
                                    new RequestContextInjectorHandler(url, db,
                                            new OptionsHandler(
// RIGHT //                                                    new SecurityHandler(coreHandlerChain, identityManager, accessManager))))));

            LOGGER.info("url {} bound to mongodb resource {}", url, db);
        });

        pipeStaticResourcesHandlers(configuration, paths, identityManager, accessManager);

        pipeApplicationLogicHandlers(configuration, paths, identityManager, accessManager);
        
        // pipe the auth tokens invalidation handler
        
// LEFT //        paths.addPrefixPath("/_authtokens", new SecurityHandler(new AuthTokenHandler(), identityManager, accessManager));

        return new GracefulShutdownHandler(
                new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),
                        new AllowedMethodsHandler(
                                new BlockingHandler(
                                        new GzipEncodingHandler(
                                                new ErrorHandler(
                                                        new HttpContinueAcceptingHandler(paths)
                                                ), configuration.isForceGzipEncoding()
                                        )
                                ), // allowed methods
                                HttpString.tryFromString(RequestContext.METHOD.GET.name()),
                                HttpString.tryFromString(RequestContext.METHOD.POST.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PUT.name()),
                                HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),
                                HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name())
                        )
                )
        );
// END getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [564, 565, 566, 567]
Right editions: []
Merged body: 
// START startCoreSystem({FormalParametersInternal})//private static void startCoreSystem() {
        if (configuration == null) {
            LOGGER.error("no configuration found. exiting..");
            stopServer();
            System.exit(-1);
        }

        if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
            LOGGER.error("no listener specified. exiting..");
            stopServer();
            System.exit(-1);
        }

        IdentityManager identityManager = null;

        if (configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no identity manager specified. authentication disabled.");
            identityManager = null;

        } else {
            try {
                Object idm = Class.forName(configuration.getIdmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getIdmArgs());
                identityManager = (IdentityManager) idm;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring idm implementation {}", configuration.getIdmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }

        AccessManager accessManager = null;

        if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
            LOGGER.warn("***** no access manager specified. authenticated users can do anything.");
            accessManager = null;
        } else if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no access manager specified. users can do anything.");
            accessManager = null;

        } else {
            try {
                Object am = Class.forName(configuration.getAmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getAmArgs());
                accessManager = (AccessManager) am;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring acess manager implementation {}", configuration.getAmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }
// LEFT //        
// LEFT //        if (configuration.isAuthTokenEnabled()) {
// LEFT //            LOGGER.info("token based authentication enabled with token TTL {} minutes", configuration.getAuthTokenTtl());
// LEFT //        }

        SSLContext sslContext = null;

        try {
            KeyManagerFactory kmf;
            KeyStore ks;

            if (getConf().isUseEmbeddedKeystore()) {
                char[] storepass = "restheart".toCharArray();
                char[] keypass = "restheart".toCharArray();

                String storename = "rakeystore.jks";

                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");
                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);

                kmf.init(ks, keypass);

                sslContext.init(kmf.getKeyManagers(), null, null);
            } else {
                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {
                    ks.load(fis, configuration.getKeystorePassword().toCharArray());

                    kmf.init(ks, configuration.getCertPassword().toCharArray());
                    sslContext.init(kmf.getKeyManagers(), null, null);
                }
            }
        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {
            LOGGER.error("couldn't start RESTHeart, error with specified keystore. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (FileNotFoundException ex) {
            LOGGER.error("couldn't start RESTHeart, keystore file not found. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (IOException ex) {
            LOGGER.error("couldn't start RESTHeart, error reading the keystore file. exiting..", ex);
            stopServer();
            System.exit(-1);
        }

        Builder builder = Undertow.builder();

        if (configuration.isHttpsListener()) {
            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);
            LOGGER.info("https listener bound at {}:{}", configuration.getHttpsHost(), configuration.getHttpsPort());
        }

        if (configuration.isHttpListener()) {
            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());
            LOGGER.info("http listener bound at {}:{}", configuration.getHttpHost(), configuration.getHttpPort());
        }

        if (configuration.isAjpListener()) {
            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());
            LOGGER.info("ajp listener bound at {}:{}", configuration.getAjpHost(), configuration.getAjpPort());
        }

        LocalCachesSingleton.init(configuration);

        if (configuration.isLocalCacheEnabled()) {
            LOGGER.info("local cache enabled");
        } else {
            LOGGER.info("local cache not enabled");
        }

        hanldersPipe = getHandlersPipe(identityManager, accessManager);

        builder
                .setIoThreads(configuration.getIoThreads())
                .setWorkerThreads(configuration.getWorkerThreads())
                .setDirectBuffers(configuration.isDirectBuffers())
                .setBufferSize(configuration.getBufferSize())
                .setBuffersPerRegion(configuration.getBuffersPerRegion())
                .setHandler(hanldersPipe);

        builder.build().start();
// END startCoreSystem({FormalParametersInternal})//    }
Edition adds call: 0
#HAS_***REFERENCE_#

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\document\PatchDocumentHandler.java
Different Spacing: false
Left editions: [92, 95]
Right editions: [80, 81, 87, 88, 97, 98]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
        DBObject content = context.getContent();

        // cannot PATCH with no data
        if (content == null) {
// RIGHT //            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE,
// RIGHT //                    "data is empty");
            return;
        }

        // cannot PATCH an array
        if (content instanceof BasicDBList) {
// RIGHT //            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE,
// RIGHT //                    "data cannot be an array");
            return;
        }

// LEFT //        Object id = context.getDocumentId();

        if (content.get("_id") == null) {
// LEFT //            content.put("_id", id);
        } else if (!content.get("_id").equals(id)) {
// RIGHT //            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_ACCEPTABLE, 
// RIGHT //                    "_id in json data cannot be different than id in URL");
            return;
        }

        ObjectId etag = RequestHelper.getWriteEtag(exchange);

        if (etag == null) {
            ResponseHelper.endExchange(exchange, HttpStatus.SC_CONFLICT);
            return;
        }

        int httpCode = documentDAO.upsertDocument(
                context.getDBName(),
                context.getCollectionName(),
                context.getDocumentId(),
                content,
                etag,
                true);

        // send the warnings if any (and in case no_content change the return code to ok
        if (context.getWarnings() != null && !context.getWarnings().isEmpty()) {
            sendWarnings(httpCode, exchange, context);
        } else {
            exchange.setResponseCode(httpCode);
        }

        exchange.endExchange();
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\database\DBRepresentationFactory.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START addLinkTemplatesAndCuries(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext-Representation-Representation-String-String)//private void addLinkTemplatesAndCuries(final HttpServerExchange exchange, final RequestContext context, final Representation rep, final String requestPath) {
        // link templates and curies
        if (context.isParentAccessible()) {
            // this can happen due to mongo-mounts mapped URL
            rep.addLink(new Link("rh:root", URLUtils.getParentPath(requestPath)));
        }
        rep.addLink(new Link("rh:paging", requestPath + "/{?page}{&pagesize}", true));
        rep.addLink(new Link("rh", "curies", Configuration.RESTHEART_ONLINE_DOC_URL + "/#api-db-{rel}", false), true);
// END addLinkTemplatesAndCuries(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext-Representation-Representation-String-String)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\database\DBRepresentationFactory.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START embeddedCollections(List<DBObject>-List<DBObject>-String-String-Representation-Representation)//private void embeddedCollections(
            final List<DBObject> embeddedData, 
            final String requestPath, 
            final Representation rep) {
        embeddedData.stream().forEach((d) -> {
            Object _id = d.get("_id");

            if (_id != null && (_id instanceof String || _id instanceof ObjectId)) {
                Representation nrep = new Representation(requestPath + "/" + _id.toString());

                nrep.addProperty("_type", RequestContext.TYPE.COLLECTION.name());

                if (d.get("_etag") != null && d.get("_etag") instanceof ObjectId) {
                    d.put("_etag", ((ObjectId) d.get("_etag")).toString()); // represent the etag as a string
                }
                nrep.addProperties(d);

                rep.addRepresentation("rh:coll", nrep);
            } else {
                logger.error("document missing string _id field", d);
            }
        });
// END embeddedCollections(List<DBObject>-List<DBObject>-String-String-Representation-Representation)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\injectors\RequestContextInjectorHandler.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
        RequestContext rcontext = new RequestContext(exchange, whereUri, whatUri);

        Deque<String> __pagesize = exchange.getQueryParameters().get(PAGESIZE_QPARAM_KEY);

        int page = 1; // default page
        int pagesize = 100; // default pagesize

        if (__pagesize != null && !(__pagesize.isEmpty())) {
            try {
                pagesize = Integer.parseInt(__pagesize.getFirst());
            } catch (NumberFormatException ex) {
                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                        "illegal pagesize paramenter, it is not a number", ex);
                return;
            }
        }

        if (pagesize < 1 || pagesize > 1000) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                    "illegal page parameter, pagesize must be >= 0 and <= 1000");
            return;
        } else {
            rcontext.setPagesize(pagesize);
        }

        Deque<String> __page = exchange.getQueryParameters().get(PAGE_QPARAM_KEY);

        if (__page != null && !(__page.isEmpty())) {
            try {
                page = Integer.parseInt(__page.getFirst());
            } catch (NumberFormatException ex) {
                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                        "illegal page paramenter, it is not a number", ex);
                return;
            }
        }

        if (page < 1) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                    "illegal page paramenter, it is < 1");
            return;
        } else {
            rcontext.setPage(page);
        }

        Deque<String> __count = exchange.getQueryParameters().get("count");

        if (__count != null) {
            rcontext.setCount(true);
        }
        // get and check sort_by parameter
        Deque<String> sort_by = exchange.getQueryParameters().get("sort_by");

        if (sort_by != null) {
            if (sort_by.stream().anyMatch(s -> s == null || s.isEmpty())) {
                ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                        "illegal sort_by paramenter");
                return;
            }

            rcontext.setSortBy(exchange.getQueryParameters().get(SORT_BY_QPARAM_KEY));
        }

        // get and check filter parameter
        Deque<String> filters = exchange.getQueryParameters().get(FILTER_QPARAM_KEY);

        if (filters != null) {
            if (filters.stream().anyMatch(f -> {
                if (f == null || f.isEmpty()) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                            "illegal filter paramenter (empty)");
                    return true;
                }

                try {
                    JSON.parse(f);
                } catch (Throwable t) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST,
                            "illegal filter paramenter: " + f, t);
                    return true;
                }

                return false;
            })) {
                return; // an error occurred
            }

            rcontext.setFilter(exchange.getQueryParameters().get(FILTER_QPARAM_KEY));
        }

        // get and check eager parameter
        Deque<String> __eager = exchange.getQueryParameters().get(EAGER_CURSOR_ALLOCATION_POLICY_QPARAM_KEY);

        // default value
        EAGER_CURSOR_ALLOCATION_POLICY eager = EAGER_CURSOR_ALLOCATION_POLICY.LINEAR;

        if (__eager != null && !__eager.isEmpty()) {
            String _eager = __eager.getFirst();

            if (_eager != null && !_eager.isEmpty()) {
                try {
                    eager = EAGER_CURSOR_ALLOCATION_POLICY.valueOf(_eager.trim().toUpperCase());
                } catch (IllegalArgumentException iae) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST, "illegal eager paramenter (must be LINEAR, RANDOM or NONE)");
                    return;
                }
            }
        }

        rcontext.setCursorAllocationPolicy(eager);

        // get and check the doc id type parameter
        Deque<String> __docIdType = exchange.getQueryParameters().get(DOC_ID_TYPE_KEY);

        // default value
        URLUtils.DOC_ID_TYPE docIdType = URLUtils.DOC_ID_TYPE.STRING_OBJECTID;

        if (__docIdType != null && !__docIdType.isEmpty()) {
            String _docIdType = __docIdType.getFirst();

            if (_docIdType != null && !_docIdType.isEmpty()) {
                try {
                    docIdType = URLUtils.DOC_ID_TYPE.valueOf(_docIdType.trim().toUpperCase());
                } catch (IllegalArgumentException iae) {
                    ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST, "illegal " + DOC_ID_TYPE_KEY + " paramenter (must be STRING_OBJECTID, INT, LONG, FLOAT, DOUBLE, STRING or OBJECTID)");
                    return;
                }
            }
        }

        rcontext.setDocIdType(docIdType);
        
        // get and check the document id
        
        String _docId = rcontext.getDocumentIdRaw();
        
        try {
            rcontext.setDocumentId(URLUtils.getId(_docId, docIdType));
        } catch(IllegalDocumentIdException idide) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_BAD_REQUEST, "wrong document id format. it is not a valid " + docIdType.name());
            return;
        }

        // get the autodetect objectid parameter
        Deque<String> __autodetectObjectId = exchange.getQueryParameters().get(DETECT_OBJECTIDS_KEY);

        // default value
        boolean detectObjectIds = true;

        if (__autodetectObjectId != null && !__autodetectObjectId.isEmpty()) {
            String _autodetectObjectId = __autodetectObjectId.getFirst();

            if (_autodetectObjectId != null && !_autodetectObjectId.isEmpty()) {
                detectObjectIds = "true".equalsIgnoreCase(_autodetectObjectId);
            }
        }

        rcontext.setDetectObjectIds(detectObjectIds);
        
        next.handleRequest(exchange, rcontext);
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: []
Right editions: [116]
Merged body: 
// START getCollection(String-String-String-String)//// RIGHT //DBCollection getCollection(String dbName, String collName) {
        return client.getDB(dbName).getCollection(collName);
// END getCollection(String-String-String-String)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [473, 475, 478, 483]
Right editions: [471]
Merged body: 
// START deleteCollection(String-String-String-String-ObjectId-ObjectId)//// RIGHT //int deleteCollection(String dbName, String collName, ObjectId etag) {
        DBCollection coll = getCollection(dbName, collName);
// LEFT //        DBCollection propsColl = getCollection(dbName, "_properties");

// LEFT //        BasicDBObject checkEtag = new BasicDBObject("_id", "_properties.".concat(collName));
        checkEtag.append("_etag", etag);

// LEFT //        DBObject exists = propsColl.findOne(checkEtag, fieldsToReturn);

        if (exists == null) {
            return HttpStatus.SC_PRECONDITION_FAILED;
        } else {
// LEFT //            propsColl.remove(new BasicDBObject("_id", "_properties.".concat(collName)));
            coll.drop();
            return HttpStatus.SC_NO_CONTENT;
        }
// END deleteCollection(String-String-String-String-ObjectId-ObjectId)//    }
Edition adds call: 1
#HAS_***REFERENCE_#

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [215]
Right editions: [191]
Merged body: 
// START getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//// RIGHT //DBCursor getCollectionDBCursor(DBCollection coll, Deque<String> sortBy, Deque<String> filters) throws JSONParseException {
        // apply sort_by
        DBObject sort = new BasicDBObject();

        if (sortBy == null || sortBy.isEmpty()) {
            sort.put("_created_on", -1);
        } else {
            sortBy.stream().forEach((s) -> {

                String _s = s.trim(); // the + sign is decoded into a space, in case remove it

                _s = _s.replaceAll("_lastupdated_on", "_etag"); // _lastupdated is not stored and actually generated from @etag

                if (_s.startsWith("-")) {
                    sort.put(_s.substring(1), -1);
                } else if (_s.startsWith("+")) {
                    sort.put(_s.substring(1), 1);
                } else {
                    sort.put(_s, 1);
                }
            });
        }

        // apply filter
// LEFT //        final BasicDBObject query = new BasicDBObject();

        if (filters != null) {
            filters.stream().forEach((String f) -> {
                BSONObject filterQuery = (BSONObject) JSON.parse(f);

                query.putAll(filterQuery);  // this can throw JSONParseException for invalid filter parameters
            });
        }

        return coll.find(query).sort(sort);
// END getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [386, 397, 400, 418, 424, 432, 439, 445, 452, 454]
Right editions: [383, 384]
Merged body: 
// START upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//// RIGHT //int upsertCollection(String dbName, String collName, DBObject content, ObjectId etag, boolean updating, boolean patching) {
// RIGHT //        DB db = client.getDB(dbName);

// LEFT //        DBCollection propsColl = db.getCollection("_properties");

        if (patching && !updating) {
            return HttpStatus.SC_NOT_FOUND;
        }

        if (updating) {
            if (etag == null) {
                return HttpStatus.SC_CONFLICT;
            }

// LEFT //            BasicDBObject idAndEtagQuery = new BasicDBObject("_id", "_properties.".concat(collName));
            idAndEtagQuery.append("_etag", etag);

// LEFT //            if (propsColl.count(idAndEtagQuery) < 1) {
                return HttpStatus.SC_PRECONDITION_FAILED;
            }
        }

        ObjectId timestamp = new ObjectId();
        Instant now = Instant.ofEpochSecond(timestamp.getTimestamp());

        if (content == null) {
            content = new BasicDBObject();
        }

        content.removeField("_id"); // make sure we don't change this field

        if (updating) {
            content.removeField("_crated_on"); // don't allow to update this field
            content.put("_etag", timestamp);
        } else {
// LEFT //            content.put("_id", "_properties.".concat(collName));
            content.put("_created_on", now.toString());
            content.put("_etag", timestamp);
        }

        if (patching) {
// LEFT //            propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), new BasicDBObject("$set", content), true, false);
            return HttpStatus.SC_OK;
        } else {
            // we use findAndModify to get the @created_on field value from the existing properties document
            // we need to put this field back using a second update 
            // it is not possible in a single update even using $setOnInsert update operator
            // in this case we need to provide the other data using $set operator and this makes it a partial update (patch semantic) 

// LEFT //            DBObject old = propsColl.findAndModify(new BasicDBObject("_id", "_properties.".concat(collName)), fieldsToReturn, null, false, content, false, true);

            if (old != null) {
                Object oldTimestamp = old.get("_created_on");

                if (oldTimestamp == null) {
                    oldTimestamp = now.toString();
// LEFT //                    LOGGER.warn("properties of collection {} had no @created_on field. set it to now", dbName + "." + collName);
                }

                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", "" + oldTimestamp);
                createdContent.markAsPartialObject();
// LEFT //                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), new BasicDBObject("$set", createdContent), true, false);

                return HttpStatus.SC_OK;
            } else {
                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", now.toString());
                createdContent.markAsPartialObject();
// LEFT //                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), new BasicDBObject("$set", createdContent), true, false);

// LEFT //                initDefaultIndexes(db.getCollection(collName));

                return HttpStatus.SC_CREATED;
            }
        }
// END upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: false
Left editions: [473, 475, 478, 483]
Right editions: [471]
Merged body: 
// START deleteCollection(String-String-String-String-ObjectId-ObjectId)//// RIGHT //int deleteCollection(String dbName, String collName, ObjectId etag) {
        DBCollection coll = getCollection(dbName, collName);
// LEFT //        DBCollection propsColl = getCollection(dbName, "_properties");

// LEFT //        BasicDBObject checkEtag = new BasicDBObject("_id", "_properties.".concat(collName));
        checkEtag.append("_etag", etag);

// LEFT //        DBObject exists = propsColl.findOne(checkEtag, fieldsToReturn);

        if (exists == null) {
            return HttpStatus.SC_PRECONDITION_FAILED;
        } else {
// LEFT //            propsColl.remove(new BasicDBObject("_id", "_properties.".concat(collName)));
            coll.drop();
            return HttpStatus.SC_NO_CONTENT;
        }
// END deleteCollection(String-String-String-String-ObjectId-ObjectId)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_a8b7b_01d40\rev_rev_left_a8b7b-rev_right_01d40\src\main\java\org\restheart\handlers\document\GetDocumentHandler.java
Different Spacing: false
Left editions: [86, 110]
Right editions: [88]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange, RequestContext context) throws Exception {
// LEFT //        BasicDBObject query = new BasicDBObject("_id", context.getDocumentId());;

// RIGHT //        DBObject document = dbsDAO.getCollection(context.getDBName(), context.getCollectionName()).findOne(query);

        if (document == null) {
            ResponseHelper.endExchangeWithMessage(exchange, HttpStatus.SC_NOT_FOUND, "document does not exist");
            return;
        }

        Object etag = document.get("_etag");

        if (etag != null && ObjectId.isValid("" + etag)) {
            ObjectId _etag = new ObjectId("" + etag);

            document.put("_lastupdated_on", Instant.ofEpochSecond(_etag.getTimestamp()).toString());

            // in case the request contains the IF_NONE_MATCH header with the current etag value,
            // just return 304 NOT_MODIFIED code
            if (RequestHelper.checkReadEtag(exchange, etag.toString())) {
                ResponseHelper.endExchange(exchange, HttpStatus.SC_NOT_MODIFIED);
                return;
            }
        }

// LEFT //        String requestPath = URLUtils.removeTrailingSlashes(exchange.getRequestPath());

        ResponseHelper.injectEtagHeader(exchange, document);
        exchange.setResponseCode(HttpStatus.SC_OK);

        DocumentRepresentationFactory.sendDocument(requestPath, exchange, context, document);
        exchange.endExchange();
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c96bc-9ce4e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6ce44-89c22
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e5135-a8a75
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2e9a8-40697
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_2e9a8_40697\rev_rev_left_2e9a8-rev_right_40697\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [638, 646]
Right editions: [545, 548]
Merged body: 
// START startCoreSystem({FormalParametersInternal})//private static void startCoreSystem() {
        if (configuration == null) {
            LOGGER.error("no configuration found. exiting..");
            stopServer();
            System.exit(-1);
        }

        if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
            LOGGER.error("no listener specified. exiting..");
            stopServer();
            System.exit(-1);
        }

        IdentityManager identityManager = null;

        if (configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no identity manager specified. authentication disabled.");
            identityManager = null;

        } else {
            try {
                Object idm = Class.forName(configuration.getIdmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getIdmArgs());
                identityManager = (IdentityManager) idm;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring idm implementation {}", configuration.getIdmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }

        AccessManager accessManager = null;

        if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
            LOGGER.warn("***** no access manager specified. authenticated users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();
        } else if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no access manager specified. users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();

        } else {
            try {
                Object am = Class.forName(configuration.getAmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getAmArgs());
                accessManager = (AccessManager) am;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring acess manager implementation {}", configuration.getAmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }
        
        if (configuration.isAuthTokenEnabled()) {
            LOGGER.info("token based authentication enabled with token TTL {} minutes", configuration.getAuthTokenTtl());
        }

        SSLContext sslContext = null;

        try {
            KeyManagerFactory kmf;
            KeyStore ks;

            if (getConf().isUseEmbeddedKeystore()) {
                char[] storepass = "restheart".toCharArray();
                char[] keypass = "restheart".toCharArray();

                String storename = "rakeystore.jks";

                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");
                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);

                kmf.init(ks, keypass);

                sslContext.init(kmf.getKeyManagers(), null, null);
            } else {
                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {
                    ks.load(fis, configuration.getKeystorePassword().toCharArray());

                    kmf.init(ks, configuration.getCertPassword().toCharArray());
                    sslContext.init(kmf.getKeyManagers(), null, null);
                }
            }
        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {
            LOGGER.error("couldn't start RESTHeart, error with specified keystore. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (FileNotFoundException ex) {
            LOGGER.error("couldn't start RESTHeart, keystore file not found. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (IOException ex) {
            LOGGER.error("couldn't start RESTHeart, error reading the keystore file. exiting..", ex);
            stopServer();
            System.exit(-1);
        }

        Builder builder = Undertow.builder();

        if (configuration.isHttpsListener()) {
            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);
            LOGGER.info("https listener bound at {}:{}", configuration.getHttpsHost(), configuration.getHttpsPort());
        }

        if (configuration.isHttpListener()) {
            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());
            LOGGER.info("http listener bound at {}:{}", configuration.getHttpHost(), configuration.getHttpPort());
        }

        if (configuration.isAjpListener()) {
            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());
            LOGGER.info("ajp listener bound at {}:{}", configuration.getAjpHost(), configuration.getAjpPort());
        }

        LocalCachesSingleton.init(configuration);

        if (configuration.isLocalCacheEnabled()) {
            LOGGER.info("local cache enabled");
        } else {
            LOGGER.info("local cache not enabled");
        }

// LEFT //        shutdownHandler = getHandlersPipe(identityManager, accessManager);

        builder
                .setIoThreads(configuration.getIoThreads())
                .setWorkerThreads(configuration.getWorkerThreads())
                .setDirectBuffers(configuration.isDirectBuffers())
                .setBufferSize(configuration.getBufferSize())
                .setBuffersPerRegion(configuration.getBuffersPerRegion())
// LEFT //                .setHandler(shutdownHandler);

        builder.build().start();
// END startCoreSystem({FormalParametersInternal})//    }

#CP_===_CP#
#CP_===_CP#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_2e9a8_40697\rev_rev_left_2e9a8-rev_right_40697\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: []
Right editions: [686]
Merged body: 
// START getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//private static GracefulShutdownHandler getHandlersPipe(final IdentityManager identityManager, final AccessManager accessManager) {
        PipedHttpHandler coreHandlerChain
                = new DbPropsInjectorHandler(
                        new CollectionPropsInjectorHandler(
                                new BodyInjectorHandler(
                                        new RequestScriptMetadataHandler(
                                                new RequestDispacherHandler()
                                        )
                                )
                        )
                );

        PathHandler paths = path();

        configuration.getMongoMounts().stream().forEach(m -> {
            String url = (String) m.get(Configuration.MONGO_MOUNT_WHERE_KEY);
            String db = (String) m.get(Configuration.MONGO_MOUNT_WHAT_KEY);

            paths.addPrefixPath(url,
                    new AuthTokenInjecterHandler(
                            new CORSHandler(
                                    new RequestContextInjectorHandler(url, db,
                                            new OptionsHandler(
                                                    new SecurityHandler(coreHandlerChain, identityManager, accessManager))))));

            LOGGER.info("url {} bound to mongodb resource {}", url, db);
        });

        pipeStaticResourcesHandlers(configuration, paths, identityManager, accessManager);

        pipeApplicationLogicHandlers(configuration, paths, identityManager, accessManager);
        
        // pipe the auth tokens invalidation handler
        
// RIGHT //        paths.addPrefixPath("/_authtokens", new AuthTokenInjecterHandler(new CORSHandler(new SecurityHandler(new AuthTokenHandler(), identityManager, new FullAccessManager()))));

        return new GracefulShutdownHandler(
                new RequestLimitingHandler(new RequestLimit(configuration.getRequestLimit()),
                        new AllowedMethodsHandler(
                                new BlockingHandler(
                                        new GzipEncodingHandler(
                                                new ErrorHandler(
                                                        new HttpContinueAcceptingHandler(paths)
                                                ), configuration.isForceGzipEncoding()
                                        )
                                ), // allowed methods
                                HttpString.tryFromString(RequestContext.METHOD.GET.name()),
                                HttpString.tryFromString(RequestContext.METHOD.POST.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PUT.name()),
                                HttpString.tryFromString(RequestContext.METHOD.DELETE.name()),
                                HttpString.tryFromString(RequestContext.METHOD.PATCH.name()),
                                HttpString.tryFromString(RequestContext.METHOD.OPTIONS.name())
                        )
                )
        );
// END getHandlersPipe(IdentityManager-IdentityManager-AccessManager-AccessManager)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_2e9a8_40697\rev_rev_left_2e9a8-rev_right_40697\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: false
Left editions: [638, 646]
Right editions: [545, 548]
Merged body: 
// START startCoreSystem({FormalParametersInternal})//private static void startCoreSystem() {
        if (configuration == null) {
            LOGGER.error("no configuration found. exiting..");
            stopServer();
            System.exit(-1);
        }

        if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
            LOGGER.error("no listener specified. exiting..");
            stopServer();
            System.exit(-1);
        }

        IdentityManager identityManager = null;

        if (configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no identity manager specified. authentication disabled.");
            identityManager = null;

        } else {
            try {
                Object idm = Class.forName(configuration.getIdmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getIdmArgs());
                identityManager = (IdentityManager) idm;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring idm implementation {}", configuration.getIdmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }

        AccessManager accessManager = null;

        if (configuration.getAmImpl() == null && configuration.getIdmImpl() != null) {
            LOGGER.warn("***** no access manager specified. authenticated users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();
        } else if (configuration.getAmImpl() == null && configuration.getIdmImpl() == null) {
            LOGGER.warn("***** no access manager specified. users can do anything.");
// RIGHT //            accessManager = new FullAccessManager();

        } else {
            try {
                Object am = Class.forName(configuration.getAmImpl())
                        .getConstructor(Map.class)
                        .newInstance(configuration.getAmArgs());
                accessManager = (AccessManager) am;
            } catch (ClassCastException | NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {
                LOGGER.error("error configuring acess manager implementation {}", configuration.getAmImpl(), ex);
                stopServer();
                System.exit(-3);
            }
        }
        
        if (configuration.isAuthTokenEnabled()) {
            LOGGER.info("token based authentication enabled with token TTL {} minutes", configuration.getAuthTokenTtl());
        }

        SSLContext sslContext = null;

        try {
            KeyManagerFactory kmf;
            KeyStore ks;

            if (getConf().isUseEmbeddedKeystore()) {
                char[] storepass = "restheart".toCharArray();
                char[] keypass = "restheart".toCharArray();

                String storename = "rakeystore.jks";

                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");
                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);

                kmf.init(ks, keypass);

                sslContext.init(kmf.getKeyManagers(), null, null);
            } else {
                sslContext = SSLContext.getInstance("TLS");
                kmf = KeyManagerFactory.getInstance("SunX509");
                ks = KeyStore.getInstance("JKS");

                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {
                    ks.load(fis, configuration.getKeystorePassword().toCharArray());

                    kmf.init(ks, configuration.getCertPassword().toCharArray());
                    sslContext.init(kmf.getKeyManagers(), null, null);
                }
            }
        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {
            LOGGER.error("couldn't start RESTHeart, error with specified keystore. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (FileNotFoundException ex) {
            LOGGER.error("couldn't start RESTHeart, keystore file not found. exiting..", ex);
            stopServer();
            System.exit(-1);
        } catch (IOException ex) {
            LOGGER.error("couldn't start RESTHeart, error reading the keystore file. exiting..", ex);
            stopServer();
            System.exit(-1);
        }

        Builder builder = Undertow.builder();

        if (configuration.isHttpsListener()) {
            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);
            LOGGER.info("https listener bound at {}:{}", configuration.getHttpsHost(), configuration.getHttpsPort());
        }

        if (configuration.isHttpListener()) {
            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());
            LOGGER.info("http listener bound at {}:{}", configuration.getHttpHost(), configuration.getHttpPort());
        }

        if (configuration.isAjpListener()) {
            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());
            LOGGER.info("ajp listener bound at {}:{}", configuration.getAjpHost(), configuration.getAjpPort());
        }

        LocalCachesSingleton.init(configuration);

        if (configuration.isLocalCacheEnabled()) {
            LOGGER.info("local cache enabled");
        } else {
            LOGGER.info("local cache not enabled");
        }

// LEFT //        shutdownHandler = getHandlersPipe(identityManager, accessManager);

        builder
                .setIoThreads(configuration.getIoThreads())
                .setWorkerThreads(configuration.getWorkerThreads())
                .setDirectBuffers(configuration.isDirectBuffers())
                .setBufferSize(configuration.getBufferSize())
                .setBuffersPerRegion(configuration.getBuffersPerRegion())
// LEFT //                .setHandler(shutdownHandler);

        builder.build().start();
// END startCoreSystem({FormalParametersInternal})//    }
Edition adds call: 1
#HAS_***REFERENCE_#

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_dcff0-47433
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ef43a-7f21b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_22db0-7b303
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e8678-3d605
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//DBCursor getCollectionDBCursor(
            final DBCollection coll, 
            final Deque<String> sortBy, 
            final Deque<String> filters, 
            final Deque<String> keys) throws JSONParseException {
        // apply sort_by
        DBObject sort = new BasicDBObject();

        if (sortBy == null || sortBy.isEmpty()) {
            sort.put("_id", -1);
        } else {
            sortBy.stream().forEach((s) -> {

                String _s = s.trim(); // the + sign is decoded into a space, in case remove it

                if (_s.startsWith("-")) {
                    sort.put(_s.substring(1), -1);
                } else if (_s.startsWith("+")) {
                    sort.put(_s.substring(1), 1);
                } else {
                    sort.put(_s, 1);
                }
            });
        }

        // apply filter
        final BasicDBObject query = new BasicDBObject();

        if (filters != null) {
            filters.stream().forEach((String f) -> {
                BSONObject filterQuery = (BSONObject) JSON.parse(f);

                query.putAll(filterQuery);  // this can throw JSONParseException for invalid filter parameters
            });
        }

        final BasicDBObject fields = new BasicDBObject();

        if (keys != null) {
            keys.stream().forEach((String f) -> {
                BSONObject keyQuery = (BSONObject) JSON.parse(f);

                fields.putAll(keyQuery);  // this can throw JSONParseException for invalid filter parameters
            });
        }

        return coll.find(query, fields).sort(sort);
// END getCollectionDBCursor(DBCollection-DBCollection-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>-Deque<String>)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\CollectionDAO.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//OperationResult upsertCollection(
            final String dbName, 
            final String collName, 
            final DBObject properties, 
            final ObjectId requestEtag, 
            final boolean updating, 
            final boolean patching) {
        
        DB db = client.getDB(dbName);

        if (patching && !updating) {
            return new OperationResult(HttpStatus.SC_NOT_FOUND);
        }

        final DBCollection propsColl = db.getCollection("_properties");

        final DBObject exists = propsColl.findOne(new BasicDBObject("_id", "_properties.".concat(collName)), FIELDS_TO_RETURN);

        if (exists == null && updating) {
            LOGGER.error("updating but cannot find collection _properties.{} for {}/{}", collName, dbName, collName);
            return new OperationResult(HttpStatus.SC_NOT_FOUND);
        } else if (exists != null) {
            Object oldEtag = exists.get("_etag");

            if (oldEtag != null) {
                if (requestEtag == null) {
                    return new OperationResult(HttpStatus.SC_CONFLICT, oldEtag);
                }

                if (!oldEtag.equals(requestEtag)) {
                    return new OperationResult(HttpStatus.SC_PRECONDITION_FAILED, oldEtag);
                }
            }
        }

        ObjectId newEtag = new ObjectId();
        Instant now = Instant.ofEpochSecond(newEtag.getTimestamp());

        final DBObject content = DAOUtils.validContent(properties);

        content.removeField("_id"); // make sure we don't change this field

        if (updating) {
            content.removeField("_crated_on"); // don't allow to update this field
            content.put("_etag", newEtag);
        } else {
            content.put("_id", "_properties.".concat(collName));
            content.put("_created_on", now.toString());
            content.put("_etag", newEtag);
        }

        if (patching) {
            propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), 
                    new BasicDBObject("$set", content), true, false);
            return new OperationResult(HttpStatus.SC_OK, newEtag);
        } else {
            // we use findAndModify to get the @created_on field value from the existing properties document
            // we need to put this field back using a second update 
            // it is not possible in a single update even using $setOnInsert update operator
            // in this case we need to provide the other data using $set operator and this makes it a partial update (patch semantic) 

            DBObject old = propsColl.findAndModify(new BasicDBObject("_id", "_properties.".concat(collName)),
                    FIELDS_TO_RETURN, null, false, content, false, true);

            if (old != null) {
                Object oldTimestamp = old.get("_created_on");

                if (oldTimestamp == null) {
                    oldTimestamp = now.toString();
                    LOGGER.warn("properties of collection {} had no @created_on field. set it to now", dbName + "." + collName);
                }

                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", "" + oldTimestamp);
                createdContent.markAsPartialObject();
                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)),
                        new BasicDBObject("$set", createdContent), true, false);

                return new OperationResult(HttpStatus.SC_OK, newEtag);
            } else {
                // need to readd the @created_on field 
                BasicDBObject createdContent = new BasicDBObject("_created_on", now.toString());
                createdContent.markAsPartialObject();
                propsColl.update(new BasicDBObject("_id", "_properties.".concat(collName)), 
                        new BasicDBObject("$set", createdContent), true, false);

                initDefaultIndexes(db.getCollection(collName));

                return new OperationResult(HttpStatus.SC_CREATED, newEtag);
            }
        }
// END upsertCollection(String-String-String-String-DBObject-DBObject-ObjectId-ObjectId-boolean-boolean-boolean-boolean)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\DBCursorPool.java
Different Spacing: false
Left editions: [254, 271, 272, 274, 275, 276, 277, 278, 279]
Right editions: [266]
Merged body: 
// START populateCacheRandom(DBCursorPoolEntryKey-DBCursorPoolEntryKey)//private void populateCacheRandom(DBCursorPoolEntryKey key) {
        executor.submit(() -> {
            Long size = collSizes.getLoading(key).get();

            int sliceWidht;
// LEFT //            int slices;
            int totalSlices = size.intValue() / SKIP_SLICE_RND_MIN_WIDTH + 1;

            if (totalSlices <= SKIP_SLICE_RND_MAX_CURSORS) {
                slices = totalSlices;
                sliceWidht = SKIP_SLICE_RND_MIN_WIDTH;
            } else {
                slices = SKIP_SLICE_RND_MAX_CURSORS;
                sliceWidht = size.intValue() / slices;
            }

            for (int slice = 1; slice < slices; slice++) {
// RIGHT //                int sliceSkips = slice * sliceWidht;

                DBCursorPoolEntryKey sliceKey = new DBCursorPoolEntryKey(key.getCollection(), key.getSort(), key.getFilter(), key.getKeys(), sliceSkips, -1);

                long existing = getSliceHeight(sliceKey);
// LEFT //                
// LEFT //                if (existing == 0) {
                    DBCursor cursor = dbsDAO.getCollectionDBCursor(key.getCollection(), key.getSort(), key.getFilter(), key.getKeys());
// LEFT //                    cursor
// LEFT //                            .skip(sliceSkips)
// LEFT //                            .limit(1000 + sliceWidht);
// LEFT //                    
// LEFT //                    cursor.hasNext(); // this forces the actual skipping
// LEFT //                    
                    DBCursorPoolEntryKey newkey = new DBCursorPoolEntryKey(key.getCollection(), key.getSort(), key.getFilter(), key.getKeys(), sliceSkips, System.nanoTime());
                    cache.put(newkey, cursor);
                    LOGGER.debug("created new cursor in pool: {}", newkey);
                }
            }
        });
// END populateCacheRandom(DBCursorPoolEntryKey-DBCursorPoolEntryKey)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditDiffMC
File: C:\download\ssmerge\restheart\revisions\rev_e8678_3d605\rev_rev_left_e8678-rev_right_3d605\src\main\java\org\restheart\db\DBCursorPool.java
Different Spacing: false
Left editions: [191]
Right editions: []
Merged body: 
// START populateCache(DBCursorPoolEntryKey-DBCursorPoolEntryKey-EAGER_CURSOR_ALLOCATION_POLICY-EAGER_CURSOR_ALLOCATION_POLICY)//// LEFT //void populateCache(DBCursorPoolEntryKey key, EAGER_CURSOR_ALLOCATION_POLICY allocationPolicy) {
        if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.LINEAR) {
            populateCacheLinear(key);
        } else if (allocationPolicy == EAGER_CURSOR_ALLOCATION_POLICY.RANDOM) {
            populateCacheRandom(key);
        }
// END populateCache(DBCursorPoolEntryKey-DBCursorPoolEntryKey-EAGER_CURSOR_ALLOCATION_POLICY-EAGER_CURSOR_ALLOCATION_POLICY)//    }
Edition adds call: 0
#HAS_***REFERENCE_#

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_eb887-908e3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_01e6f-160b5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7d8bb-54bd9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_08c6f-d25eb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0b0ee-6568d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_69dc6-5b6fa
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_69dc6_5b6fa\rev_rev_left_69dc6-rev_right_5b6fa\src\main\java\org\restheart\utils\FileUtils.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START getFileAbsoultePath(String-String)//public static Path getFileAbsoultePath(String path) {
        if (path == null) {
            return null;
        }

        FileSystem fileSystem = FileSystems.getDefault();
        Path absolutePath = fileSystem.getPath(path).toAbsolutePath();
        try {
            fileSystem.close();
        } catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
        }
        return absolutePath;
// END getFileAbsoultePath(String-String)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2433a-2fd96
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6e219-64538
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e936b-b73a6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3c07e-4d4b3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_89b6d-b71c5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_aa663-3d0a7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_90c8b-8bd30
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_90c8b_8bd30\rev_rev_left_90c8b-rev_right_8bd30\src\main\java\org\restheart\Configuration.java
Different Spacing: false
Left editions: [1127, 1128]
Right editions: [1058]
Merged body: 
// START Configuration(Map<String,Object>-Map<String,Object>-boolean-boolean)//public Configuration(Map<String, Object> conf, boolean silent) throws ConfigurationException {
        this.silent = silent;

        httpsListener = getAsBooleanOrDefault(conf, HTTPS_LISTENER, true);
        httpsPort = getAsIntegerOrDefault(conf, HTTPS_PORT_KEY, DEFAULT_HTTPS_PORT);
        httpsHost = getAsStringOrDefault(conf, HTTPS_HOST_KEY, DEFAULT_HTTPS_HOST);

        httpListener = getAsBooleanOrDefault(conf, HTTP_LISTENER_KEY, false);
        httpPort = getAsIntegerOrDefault(conf, HTTP_PORT_KEY, DEFAULT_HTTP_PORT);
        httpHost = getAsStringOrDefault(conf, HTTP_HOST_KEY, DEFAULT_HTTP_HOST);

        ajpListener = getAsBooleanOrDefault(conf, AJP_LISTENER_KEY, false);
        ajpPort = getAsIntegerOrDefault(conf, AJP_PORT_KEY, DEFAULT_AJP_PORT);
        ajpHost = getAsStringOrDefault(conf, AJP_HOST_KEY, DEFAULT_AJP_HOST);

        instanceName = getAsStringOrDefault(conf, INSTANCE_NAME_KEY, DEFAULT_INSTANCE_NAME);

        String _representationFormat = getAsStringOrDefault(conf,
                REPRESENTATION_FORMAT_KEY, DEFAULT_REPRESENTATION_FORMAT.name());

// RIGHT //        REPRESENTATION_FORMAT rf = REPRESENTATION_FORMAT.PLAIN_JSON;

        try {
            rf = REPRESENTATION_FORMAT.valueOf(_representationFormat);
        } catch (IllegalArgumentException iar) {
            LOGGER.warn("wrong value for {}. allowed values are {}; "
                    + "setting it to {}",
                    REPRESENTATION_FORMAT_KEY,
                    REPRESENTATION_FORMAT.values(),
                    REPRESENTATION_FORMAT.PLAIN_JSON);
        } finally {
            defaultRepresentationFromat = rf;
        }

        useEmbeddedKeystore = getAsBooleanOrDefault(conf, USE_EMBEDDED_KEYSTORE_KEY, true);
        keystoreFile = getAsStringOrDefault(conf, KEYSTORE_FILE_KEY, null);
        keystorePassword = getAsStringOrDefault(conf, KEYSTORE_PASSWORD_KEY, null);
        certPassword = getAsStringOrDefault(conf, CERT_PASSWORD_KEY, null);

        try {
            mongoUri = new MongoClientURI(getAsStringOrDefault(conf, MONGO_URI_KEY, DEFAULT_MONGO_URI));
        } catch (IllegalArgumentException iae) {
            throw new ConfigurationException("wrong parameter " + MONGO_URI_KEY, iae);
        }

        List<Map<String, Object>> mongoMountsDefault = new ArrayList<>();
        Map<String, Object> defaultMongoMounts = new HashMap<>();
        defaultMongoMounts.put(MONGO_MOUNT_WHAT_KEY, "*");
        defaultMongoMounts.put(MONGO_MOUNT_WHERE_KEY, "/");
        mongoMountsDefault.add(defaultMongoMounts);

        mongoMounts = getAsListOfMaps(conf, MONGO_MOUNTS_KEY, mongoMountsDefault);

        applicationLogicMounts = getAsListOfMaps(conf, APPLICATION_LOGIC_MOUNTS_KEY, new ArrayList<>());

        staticResourcesMounts = getAsListOfMaps(conf, STATIC_RESOURCES_MOUNTS_KEY, new ArrayList<>());

        metadataNamedSingletons = getAsListOfMaps(conf, METADATA_NAMED_SINGLETONS_KEY, new ArrayList<>());

        Map<String, Object> idm = getAsMap(conf, IDM_KEY);
        Map<String, Object> am = getAsMap(conf, ACCESS_MANAGER_KEY);

        idmImpl = getAsStringOrDefault(idm, IMPLEMENTATION_CLASS_KEY, DEFAULT_IDM_IMPLEMENTATION_CLASS);
        idmArgs = idm;

        amImpl = getAsStringOrDefault(am, IMPLEMENTATION_CLASS_KEY, DEFAULT_AM_IMPLEMENTATION_CLASS);
        amArgs = am;

        logFilePath = getAsStringOrDefault(conf, LOG_FILE_PATH_KEY,
                URLUtils.removeTrailingSlashes(System.getProperty("java.io.tmpdir"))
                        .concat(File.separator + "restheart.log"));
        String _logLevel = getAsStringOrDefault(conf, LOG_LEVEL_KEY, "INFO");
        logToConsole = getAsBooleanOrDefault(conf, ENABLE_LOG_CONSOLE_KEY, true);
        logToFile = getAsBooleanOrDefault(conf, ENABLE_LOG_FILE_KEY, true);

        Level level;

        try {
            level = Level.valueOf(_logLevel);
        } catch (Exception e) {
            if (!silent) {
                LOGGER.info("wrong value for parameter {}: {}. using its default value {}", "log-level", _logLevel, "INFO");
            }
            level = Level.INFO;
        }

        logLevel = level;

        requestsLimit = getAsIntegerOrDefault(conf, REQUESTS_LIMIT_KEY, 100);
// LEFT //        queryTimeLimit = getAsLongOrDefault(conf, QUERY_TIME_LIMIT_KEY, (long) 0);
// LEFT //        aggregationTimeLimit = getAsLongOrDefault(conf, AGGREGATION_TIME_LIMIT_KEY, (long) 0);

        localCacheEnabled = getAsBooleanOrDefault(conf, LOCAL_CACHE_ENABLED_KEY, true);
        localCacheTtl = getAsLongOrDefault(conf, LOCAL_CACHE_TTL_KEY, (long) 1000);

        schemaCacheEnabled = getAsBooleanOrDefault(conf, SCHEMA_CACHE_ENABLED_KEY, true);
        schemaCacheTtl = getAsLongOrDefault(conf, SCHEMA_CACHE_TTL_KEY, (long) 1000);

        ioThreads = getAsIntegerOrDefault(conf, IO_THREADS_KEY, 2);
        workerThreads = getAsIntegerOrDefault(conf, WORKER_THREADS_KEY, 32);
        bufferSize = getAsIntegerOrDefault(conf, BUFFER_SIZE_KEY, 16384);
        buffersPerRegion = getAsIntegerOrDefault(conf, BUFFERS_PER_REGION_KEY, 20);
        directBuffers = getAsBooleanOrDefault(conf, DIRECT_BUFFERS_KEY, true);

        forceGzipEncoding = getAsBooleanOrDefault(conf, FORCE_GZIP_ENCODING_KEY, false);

        eagerPoolSize = getAsIntegerOrDefault(conf, EAGER_POOL_SIZE, 100);
        eagerLinearSliceWidht = getAsIntegerOrDefault(conf, EAGER_LINEAR_SLICE_WIDHT, 1000);
        eagerLinearSliceDelta = getAsIntegerOrDefault(conf, EAGER_LINEAR_SLICE_DELTA, 100);
        eagerLinearSliceHeights = getAsArrayOfInts(conf, EAGER_LINEAR_HEIGHTS, new int[]{4, 2, 1});
        eagerRndSliceMinWidht = getAsIntegerOrDefault(conf, EAGER_RND_SLICE_MIN_WIDHT, 1000);
        eagerRndMaxCursors = getAsIntegerOrDefault(conf, EAGER_RND_MAX_CURSORS, 50);

        authTokenEnabled = getAsBooleanOrDefault(conf, AUTH_TOKEN_ENABLED, true);
        authTokenTtl = getAsIntegerOrDefault(conf, AUTH_TOKEN_TTL, 15);

        Map<String, Object> etagCheckPolicies = getAsMap(conf, ETAG_CHECK_POLICY_KEY);

        if (etagCheckPolicies != null) {
            String _dbEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_DB_KEY,
                            DEFAULT_DB_ETAG_CHECK_POLICY.name());

            String _collEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_COLL_KEY,
                            DEFAULT_COLL_ETAG_CHECK_POLICY.name());

            String _docEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_DOC_KEY,
                            DEFAULT_DOC_ETAG_CHECK_POLICY.name());

            ETAG_CHECK_POLICY validDbValue;
            ETAG_CHECK_POLICY validCollValue;
            ETAG_CHECK_POLICY validDocValue;

            try {
                validDbValue = ETAG_CHECK_POLICY.valueOf(_dbEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_DB_KEY, DEFAULT_DB_ETAG_CHECK_POLICY);
                validDbValue = DEFAULT_DB_ETAG_CHECK_POLICY;
            }

            dbEtagCheckPolicy = validDbValue;

            try {

                validCollValue = ETAG_CHECK_POLICY.valueOf(_collEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_COLL_KEY, DEFAULT_COLL_ETAG_CHECK_POLICY);
                validCollValue = DEFAULT_COLL_ETAG_CHECK_POLICY;
            }

            collEtagCheckPolicy = validCollValue;

            try {
                validDocValue = ETAG_CHECK_POLICY.valueOf(_docEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_COLL_KEY, DEFAULT_COLL_ETAG_CHECK_POLICY);
                validDocValue = DEFAULT_DOC_ETAG_CHECK_POLICY;
            }

            docEtagCheckPolicy = validDocValue;
        } else {
            dbEtagCheckPolicy = DEFAULT_DB_ETAG_CHECK_POLICY;
            collEtagCheckPolicy = DEFAULT_COLL_ETAG_CHECK_POLICY;
            docEtagCheckPolicy = DEFAULT_DOC_ETAG_CHECK_POLICY;
        }

        logExchangeDump = getAsIntegerOrDefault(conf, LOG_REQUESTS_LEVEL_KEY, 0);

        connectionOptions = getAsMap(conf, CONNECTION_OPTIONS_KEY);
// END Configuration(Map<String,Object>-Map<String,Object>-boolean-boolean)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_90c8b_8bd30\rev_rev_left_90c8b-rev_right_8bd30\src\main\java\org\restheart\handlers\ErrorHandler.java
Different Spacing: false
Left editions: [107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117]
Right editions: [119, 160]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange)//@Override
    public void handleRequest(
            HttpServerExchange exchange)
            throws Exception {
        try {
            next.handleRequest(exchange);
        } catch (MongoTimeoutException nte) {
            RequestContext errorContext = new RequestContext(exchange, "/", "_error");
            
            ResponseHelper.endExchangeWithMessage(
                    exchange,
                    errorContext,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
                    "Timeout connecting to MongoDB, is it running?", nte);
            
            sender.handleRequest(exchange, errorContext);
// LEFT //        } catch (MongoExecutionTimeoutException mete) {
// LEFT //            RequestContext errorContext = new RequestContext(exchange, "/", "_error");
// LEFT //
// LEFT //            ResponseHelper.endExchangeWithMessage(
// LEFT //                    exchange,
// LEFT //                    errorContext,
// LEFT //                    HttpStatus.SC_REQUEST_TIMEOUT,
// LEFT //                    "Operation exceeded time limit"
// LEFT //            );
// LEFT //
// LEFT //            sender.handleRequest(exchange, errorContext);
        } catch (MongoBulkWriteException mce) {
// RIGHT //            MongoBulkWriteException bmce = mce;

            BulkResultRepresentationFactory rf = new BulkResultRepresentationFactory();

            Representation rep = rf.getRepresentation(exchange, bmce);
            
            RequestContext errorContext = new RequestContext(exchange, "/", "_error");

            ResponseHelper.endExchangeWithRepresentation(
                    exchange,
                    errorContext,
                    HttpStatus.SC_MULTI_STATUS,
                    rep);

            sender.handleRequest(exchange, errorContext);
        } catch (MongoException mce) {
            int httpCode = ResponseHelper.getHttpStatusFromErrorCode(mce.getCode());

            LOGGER.error("Error handling the request", mce);

            RequestContext errorContext = new RequestContext(exchange, "/", "_error");
            
            if (httpCode >= 500
                    && mce.getMessage() != null
                    && !mce.getMessage().trim().isEmpty()) {

                ResponseHelper.endExchangeWithMessage(
                        exchange,
                        errorContext,
                        httpCode,
                        mce.getMessage());

            } else {
                ResponseHelper.endExchangeWithMessage(
                        exchange,
                        errorContext,
                        httpCode,
                        ResponseHelper.getMessageFromErrorCode(mce.getCode()));
            }

            sender.handleRequest(exchange, errorContext);
// RIGHT //        } catch (Exception t) {
            LOGGER.error("Error handling the request", t);
            
            RequestContext errorContext = new RequestContext(exchange, "/", "_error");

            ResponseHelper.endExchangeWithMessage(
                    exchange,
                    errorContext,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR,
                    "Error handling the request, see log for more information", t);
            sender.handleRequest(exchange, errorContext);
        }
// END handleRequest(HttpServerExchange-HttpServerExchange)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_90c8b_8bd30\rev_rev_left_90c8b-rev_right_8bd30\src\main\java\org\restheart\handlers\aggregation\GetAggregationHandler.java
Different Spacing: false
Left editions: []
Right editions: [124, 131, 132, 133, 167, 172, 173, 207, 212, 213]
Merged body: 
// START handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//@Override
    public void handleRequest(HttpServerExchange exchange,
            RequestContext context) throws Exception {
        if (context.isInError()) {
            next(exchange, context);
            return;
        }

        String queryUri = context.getAggregationOperation();

        List<AbstractAggregationOperation> aggregations
                = AbstractAggregationOperation
                        .getFromJson(context.getCollectionProps());

        Optional<AbstractAggregationOperation> _query
                = aggregations.stream().filter(q
                        -> q.getUri().equals(queryUri)).findFirst();

        if (!_query.isPresent()) {
            ResponseHelper.endExchangeWithMessage(
                    exchange,
                    context,
                    HttpStatus.SC_NOT_FOUND, "query does not exist");
            next(exchange, context);
            return;
        }

        ArrayList<BsonDocument> data = new ArrayList<>();
        int size;

        AbstractAggregationOperation query = _query.get();

// RIGHT //        if (null == query.getType()) {
            ResponseHelper.endExchangeWithMessage(
                    exchange,
                    context,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR, "unknown query type");
            next(exchange, context);
            return;
// RIGHT //        } else {
// RIGHT //            switch (query.getType()) {
// RIGHT //                case MAP_REDUCE:
            MapReduceIterable<BsonDocument> mrOutput;
            MapReduce mapReduce = (MapReduce) query;
            try {
                mrOutput = getDatabase()
                        .getCollection(context.getDBName(),
                                context.getCollectionName())
                        .mapReduce(
                                mapReduce.getResolvedMap(context.getAggreationVars()),
                                mapReduce.getResolvedReduce(context.getAggreationVars()))
                        .filter(
                                mapReduce.getResolvedQuery(context.getAggreationVars()))
                        .maxTime(Bootstrapper.getConfiguration().getAggregationTimeLimit(), TimeUnit.MILLISECONDS);
            } catch (MongoCommandException | InvalidMetadataException ex) {
                ResponseHelper.endExchangeWithMessage(
                        exchange,
                        context,
                        HttpStatus.SC_INTERNAL_SERVER_ERROR,
                        "error executing mapReduce", ex);
                next(exchange, context);
                return;
            } catch (QueryVariableNotBoundException qvnbe) {
                ResponseHelper.endExchangeWithMessage(
                        exchange,
                        context,
                        HttpStatus.SC_BAD_REQUEST,
                        "error executing mapReduce: "
                        + qvnbe.getMessage());
                next(exchange, context);
                return;
            }
            if (mrOutput == null) {
                next(exchange, context);
                return;
// RIGHT //                    }   // ***** get data
            for (BsonDocument obj : mrOutput) {
                data.add(obj);
            }
            size = data.size();
// RIGHT //                    break;
// RIGHT //                case AGGREGATION_PIPELINE:
            AggregateIterable<BsonDocument> agrOutput;
            AggregationPipeline pipeline = (AggregationPipeline) query;
            try {
                agrOutput = getDatabase()
                        .getCollection(
                                context.getDBName(),
                                context.getCollectionName())
                        .aggregate(
                                pipeline
                                        .getResolvedStagesAsList(
                                                context.getAggreationVars()))
                        .maxTime(Bootstrapper.getConfiguration().getAggregationTimeLimit(), TimeUnit.MILLISECONDS);
            } catch (MongoCommandException | InvalidMetadataException ex) {
                ResponseHelper.endExchangeWithMessage(
                        exchange,
                        context,
                        HttpStatus.SC_INTERNAL_SERVER_ERROR,
                        "error executing aggreation pipeline", ex);
                next(exchange, context);
                return;
            } catch (QueryVariableNotBoundException qvnbe) {
                ResponseHelper.endExchangeWithMessage(
                        exchange,
                        context,
                        HttpStatus.SC_BAD_REQUEST,
                        "error executing aggreation pipeline: "
                        + qvnbe.getMessage());
                next(exchange, context);
                return;
            }
            if (agrOutput == null) {
                next(exchange, context);
                return;
// RIGHT //                    }   // ***** get data
            for (BsonDocument obj : agrOutput) {
                data.add(obj);
            }
            size = data.size();
// RIGHT //                    break;
// RIGHT //                default:
            ResponseHelper.endExchangeWithMessage(
                    exchange,
                    context,
                    HttpStatus.SC_INTERNAL_SERVER_ERROR, "unknown query type");
            next(exchange, context);
            return;
        }
        }

        if (exchange.isComplete()) {
            // if an error occured getting data, the exchange is already closed
            return;
        }

        try {
            context.setResponseContent(new AggregationResultRepresentationFactory()
                    .getRepresentation(
                            exchange,
                            context,
                            applyPagination(data, context),
                            size)
                    .asBsonDocument());

            context.setResponseContentType(Representation.HAL_JSON_MEDIA_TYPE);
            context.setResponseStatusCode(HttpStatus.SC_OK);

            // call the ResponseTransformerMetadataHandler if piped in
            next(exchange, context);
        } catch (IllegalQueryParamenterException ex) {
            ResponseHelper.endExchangeWithMessage(
                    exchange,
                    context,
                    HttpStatus.SC_BAD_REQUEST, ex.getMessage(), ex);
            next(exchange, context);
        }
// END handleRequest(HttpServerExchange-HttpServerExchange-RequestContext-RequestContext)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d5aee-38fcf
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_d5aee_38fcf\rev_rev_left_d5aee-rev_right_38fcf\src\main\java\org\restheart\Bootstrapper.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START startCoreSystem({FormalParametersInternal})//private static void startCoreSystem() {
        if (configuration == null) {
            logErrorAndExit("No configuration found. exiting..", null, false, -1);
        }

        if (!configuration.isHttpsListener() && !configuration.isHttpListener() && !configuration.isAjpListener()) {
            logErrorAndExit("No listener specified. exiting..", null, false, -1);
        }

        final IdentityManager identityManager = loadIdentityManager();
        
        final AuthenticationMechanism authenticationMechanism = loadAuthenticationMechanism(identityManager); 

        final AccessManager accessManager = loadAccessManager();

        if (configuration.isAuthTokenEnabled()) {
            LOGGER.info("Token based authentication enabled with token TTL {} minutes", configuration.getAuthTokenTtl());
        }

        SSLContext sslContext = null;

        try {
            sslContext = SSLContext.getInstance("TLS");

            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());

            if (getConfiguration().isUseEmbeddedKeystore()) {
                char[] storepass = "restheart".toCharArray();
                char[] keypass = "restheart".toCharArray();

                String storename = "rakeystore.jks";

                ks.load(Bootstrapper.class.getClassLoader().getResourceAsStream(storename), storepass);
                kmf.init(ks, keypass);
            } else {
                try (FileInputStream fis = new FileInputStream(new File(configuration.getKeystoreFile()))) {
                    ks.load(fis, configuration.getKeystorePassword().toCharArray());
                    kmf.init(ks, configuration.getCertPassword().toCharArray());
                }
            }

            tmf.init(ks);

            sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException | CertificateException | UnrecoverableKeyException ex) {
            logErrorAndExit("Couldn't start RESTHeart, error with specified keystore. exiting..", ex, false, -1);
        } catch (FileNotFoundException ex) {
            logErrorAndExit("Couldn't start RESTHeart, keystore file not found. exiting..", ex, false, -1);
        } catch (IOException ex) {
            logErrorAndExit("Couldn't start RESTHeart, error reading the keystore file. exiting..", ex, false, -1);
        }

        Builder builder = Undertow.builder();

        if (configuration.isHttpsListener()) {
            builder.addHttpsListener(configuration.getHttpsPort(), configuration.getHttpHost(), sslContext);
            LOGGER.info("HTTPS listener bound at {}:{}", configuration.getHttpsHost(), configuration.getHttpsPort());
        }

        if (configuration.isHttpListener()) {
            builder.addHttpListener(configuration.getHttpPort(), configuration.getHttpsHost());
            LOGGER.info("HTTP listener bound at {}:{}", configuration.getHttpHost(), configuration.getHttpPort());
        }

        if (configuration.isAjpListener()) {
            builder.addAjpListener(configuration.getAjpPort(), configuration.getAjpHost());
            LOGGER.info("Ajp listener bound at {}:{}", configuration.getAjpHost(), configuration.getAjpPort());
        }

        LocalCachesSingleton.init(configuration);

        if (configuration.isLocalCacheEnabled()) {
            LOGGER.info("Local cache for db and collection properties enabled with TTL {} msecs",
                    configuration.getLocalCacheTtl() < 0 ? "?"
                    : configuration.getLocalCacheTtl());
        } else {
            LOGGER.info("Local cache for db and collection properties not enabled");
        }

        if (configuration.isSchemaCacheEnabled()) {
            LOGGER.info("Local cache for schema stores enabled  with TTL {} msecs",
                    configuration.getSchemaCacheTtl() < 0 ? "?"
                    : configuration.getSchemaCacheTtl());
        } else {
            LOGGER.info("Local cache for schema stores not enabled");
        }

        shutdownHandler = getHandlersPipe(authenticationMechanism, identityManager, accessManager);

        builder = builder
                .setIoThreads(configuration.getIoThreads())
                .setWorkerThreads(configuration.getWorkerThreads())
                .setDirectBuffers(configuration.isDirectBuffers())
                .setBufferSize(configuration.getBufferSize())
                .setBuffersPerRegion(configuration.getBuffersPerRegion())
                .setHandler(shutdownHandler);

        ConfigurationHelper.setConnectionOptions(builder, configuration);

        undertowServer = builder.build();
        undertowServer.start();
// END startCoreSystem({FormalParametersInternal})//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_d5aee_38fcf\rev_rev_left_d5aee-rev_right_38fcf\src\main\java\org\restheart\Configuration.java
Different Spacing: false
Left editions: []
Right editions: [891, 892]
Merged body: 
// START Configuration({FormalParametersInternal})//public Configuration() {
        httpsListener = true;
        httpsPort = DEFAULT_HTTPS_PORT;
        httpsHost = DEFAULT_HTTPS_HOST;

        httpListener = true;
        httpPort = DEFAULT_HTTP_PORT;
        httpHost = DEFAULT_HTTP_HOST;

        ajpListener = false;
        ajpPort = DEFAULT_AJP_PORT;
        ajpHost = DEFAULT_AJP_HOST;

        instanceName = DEFAULT_INSTANCE_NAME;

        defaultRepresentationFromat = DEFAULT_REPRESENTATION_FORMAT;

        useEmbeddedKeystore = true;
        keystoreFile = null;
        keystorePassword = null;
        certPassword = null;

        mongoUri = new MongoClientURI(DEFAULT_MONGO_URI);

        mongoMounts = new ArrayList<>();
        Map<String, Object> defaultMongoMounts = new HashMap<>();
        defaultMongoMounts.put(MONGO_MOUNT_WHAT_KEY, "*");
        defaultMongoMounts.put(MONGO_MOUNT_WHERE_KEY, "/");
        mongoMounts.add(defaultMongoMounts);

        applicationLogicMounts = new ArrayList<>();

        staticResourcesMounts = new ArrayList<>();

        metadataNamedSingletons = new ArrayList<>();

        HashMap<String, Object> browserStaticResourcesMountArgs = new HashMap<>();

        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_WHAT_KEY, "browser");
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_WHERE_KEY, "/browser");
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_WELCOME_FILE_KEY, "browser.html");
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_SECURED_KEY, false);
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_EMBEDDED_KEY, true);

        staticResourcesMounts.add(browserStaticResourcesMountArgs);

        idmImpl = null;
        idmArgs = null;

// RIGHT //        authMechanismImpl = null;
// RIGHT //        authMechanismArgs = null;

        amImpl = null;
        amArgs = null;

        logFilePath = URLUtils.removeTrailingSlashes(System.getProperty("java.io.tmpdir"))
                .concat(File.separator + "restheart.log");
        logToConsole = true;
        logToFile = true;
        logLevel = Level.INFO;

        localCacheEnabled = true;
        localCacheTtl = 1000;

        schemaCacheEnabled = false;
        schemaCacheTtl = 1000;

        requestsLimit = 100;
        queryTimeLimit = 0;
        aggregationTimeLimit = 0;

        ioThreads = 2;
        workerThreads = 32;
        bufferSize = 16384;
        buffersPerRegion = 20;
        directBuffers = true;

        forceGzipEncoding = false;

        eagerPoolSize = 100;
        eagerLinearSliceWidht = 1000;
        eagerLinearSliceDelta = 100;
        eagerLinearSliceHeights = new int[]{4, 2, 1};
        eagerRndSliceMinWidht = 1000;
        eagerRndMaxCursors = 50;

        authTokenEnabled = true;
        authTokenTtl = 15; // minutes

        dbEtagCheckPolicy = DEFAULT_DB_ETAG_CHECK_POLICY;
        collEtagCheckPolicy = DEFAULT_COLL_ETAG_CHECK_POLICY;
        docEtagCheckPolicy = DEFAULT_DOC_ETAG_CHECK_POLICY;

        logExchangeDump = 0;

        connectionOptions = Maps.newHashMap();
// END Configuration({FormalParametersInternal})//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_d5aee_38fcf\rev_rev_left_d5aee-rev_right_38fcf\src\main\java\org\restheart\Configuration.java
Different Spacing: false
Left editions: [1026, 1099, 1100]
Right editions: [1066, 1072, 1073, 1074]
Merged body: 
// START Configuration(Map<String,Object>-Map<String,Object>-boolean-boolean)//public Configuration(Map<String, Object> conf, boolean silent) throws ConfigurationException {
        this.silent = silent;

        httpsListener = getAsBooleanOrDefault(conf, HTTPS_LISTENER, true);
        httpsPort = getAsIntegerOrDefault(conf, HTTPS_PORT_KEY, DEFAULT_HTTPS_PORT);
        httpsHost = getAsStringOrDefault(conf, HTTPS_HOST_KEY, DEFAULT_HTTPS_HOST);

        httpListener = getAsBooleanOrDefault(conf, HTTP_LISTENER_KEY, false);
        httpPort = getAsIntegerOrDefault(conf, HTTP_PORT_KEY, DEFAULT_HTTP_PORT);
        httpHost = getAsStringOrDefault(conf, HTTP_HOST_KEY, DEFAULT_HTTP_HOST);

        ajpListener = getAsBooleanOrDefault(conf, AJP_LISTENER_KEY, false);
        ajpPort = getAsIntegerOrDefault(conf, AJP_PORT_KEY, DEFAULT_AJP_PORT);
        ajpHost = getAsStringOrDefault(conf, AJP_HOST_KEY, DEFAULT_AJP_HOST);

        instanceName = getAsStringOrDefault(conf, INSTANCE_NAME_KEY, DEFAULT_INSTANCE_NAME);

        String _representationFormat = getAsStringOrDefault(conf,
                REPRESENTATION_FORMAT_KEY, DEFAULT_REPRESENTATION_FORMAT.name());

// LEFT //        REPRESENTATION_FORMAT rf = REPRESENTATION_FORMAT.PLAIN_JSON;

        try {
            rf = REPRESENTATION_FORMAT.valueOf(_representationFormat);
        } catch (IllegalArgumentException iar) {
            LOGGER.warn("wrong value for {}. allowed values are {}; "
                    + "setting it to {}",
                    REPRESENTATION_FORMAT_KEY,
                    REPRESENTATION_FORMAT.values(),
                    REPRESENTATION_FORMAT.PLAIN_JSON);
        } finally {
            defaultRepresentationFromat = rf;
        }

        useEmbeddedKeystore = getAsBooleanOrDefault(conf, USE_EMBEDDED_KEYSTORE_KEY, true);
        keystoreFile = getAsStringOrDefault(conf, KEYSTORE_FILE_KEY, null);
        keystorePassword = getAsStringOrDefault(conf, KEYSTORE_PASSWORD_KEY, null);
        certPassword = getAsStringOrDefault(conf, CERT_PASSWORD_KEY, null);

        try {
            mongoUri = new MongoClientURI(getAsStringOrDefault(conf, MONGO_URI_KEY, DEFAULT_MONGO_URI));
        } catch (IllegalArgumentException iae) {
            throw new ConfigurationException("wrong parameter " + MONGO_URI_KEY, iae);
        }

        List<Map<String, Object>> mongoMountsDefault = new ArrayList<>();
        Map<String, Object> defaultMongoMounts = new HashMap<>();
        defaultMongoMounts.put(MONGO_MOUNT_WHAT_KEY, "*");
        defaultMongoMounts.put(MONGO_MOUNT_WHERE_KEY, "/");
        mongoMountsDefault.add(defaultMongoMounts);

        mongoMounts = getAsListOfMaps(conf, MONGO_MOUNTS_KEY, mongoMountsDefault);

        applicationLogicMounts = getAsListOfMaps(conf, APPLICATION_LOGIC_MOUNTS_KEY, new ArrayList<>());

        staticResourcesMounts = getAsListOfMaps(conf, STATIC_RESOURCES_MOUNTS_KEY, new ArrayList<>());

        metadataNamedSingletons = getAsListOfMaps(conf, METADATA_NAMED_SINGLETONS_KEY, new ArrayList<>());

        Map<String, Object> idm = getAsMap(conf, IDM_KEY);
// RIGHT //        Map<String, Object> authMech = getAsMap(conf, AUTH_Mechanism_KEY);
        Map<String, Object> am = getAsMap(conf, ACCESS_MANAGER_KEY);

        idmImpl = getAsStringOrDefault(idm, IMPLEMENTATION_CLASS_KEY, DEFAULT_IDM_IMPLEMENTATION_CLASS);
        idmArgs = idm;

// RIGHT //        authMechanismImpl = getAsStringOrDefault(authMech, IMPLEMENTATION_CLASS_KEY, DEFAULT_AUTH_MECHANISM_IMPLEMENTATION_CLASS);
// RIGHT //        authMechanismArgs = authMech;
// RIGHT //        
        amImpl = getAsStringOrDefault(am, IMPLEMENTATION_CLASS_KEY, DEFAULT_AM_IMPLEMENTATION_CLASS);
        amArgs = am;

        logFilePath = getAsStringOrDefault(conf, LOG_FILE_PATH_KEY,
                URLUtils.removeTrailingSlashes(System.getProperty("java.io.tmpdir"))
                        .concat(File.separator + "restheart.log"));
        String _logLevel = getAsStringOrDefault(conf, LOG_LEVEL_KEY, "INFO");
        logToConsole = getAsBooleanOrDefault(conf, ENABLE_LOG_CONSOLE_KEY, true);
        logToFile = getAsBooleanOrDefault(conf, ENABLE_LOG_FILE_KEY, true);

        Level level;

        try {
            level = Level.valueOf(_logLevel);
        } catch (Exception e) {
            if (!silent) {
                LOGGER.info("wrong value for parameter {}: {}. using its default value {}", "log-level", _logLevel, "INFO");
            }
            level = Level.INFO;
        }

        logLevel = level;

        requestsLimit = getAsIntegerOrDefault(conf, REQUESTS_LIMIT_KEY, 100);
// LEFT //        queryTimeLimit = getAsLongOrDefault(conf, QUERY_TIME_LIMIT_KEY, (long) 0);
// LEFT //        aggregationTimeLimit = getAsLongOrDefault(conf, AGGREGATION_TIME_LIMIT_KEY, (long) 0);

        localCacheEnabled = getAsBooleanOrDefault(conf, LOCAL_CACHE_ENABLED_KEY, true);
        localCacheTtl = getAsLongOrDefault(conf, LOCAL_CACHE_TTL_KEY, (long) 1000);

        schemaCacheEnabled = getAsBooleanOrDefault(conf, SCHEMA_CACHE_ENABLED_KEY, true);
        schemaCacheTtl = getAsLongOrDefault(conf, SCHEMA_CACHE_TTL_KEY, (long) 1000);

        ioThreads = getAsIntegerOrDefault(conf, IO_THREADS_KEY, 2);
        workerThreads = getAsIntegerOrDefault(conf, WORKER_THREADS_KEY, 32);
        bufferSize = getAsIntegerOrDefault(conf, BUFFER_SIZE_KEY, 16384);
        buffersPerRegion = getAsIntegerOrDefault(conf, BUFFERS_PER_REGION_KEY, 20);
        directBuffers = getAsBooleanOrDefault(conf, DIRECT_BUFFERS_KEY, true);

        forceGzipEncoding = getAsBooleanOrDefault(conf, FORCE_GZIP_ENCODING_KEY, false);

        eagerPoolSize = getAsIntegerOrDefault(conf, EAGER_POOL_SIZE, 100);
        eagerLinearSliceWidht = getAsIntegerOrDefault(conf, EAGER_LINEAR_SLICE_WIDHT, 1000);
        eagerLinearSliceDelta = getAsIntegerOrDefault(conf, EAGER_LINEAR_SLICE_DELTA, 100);
        eagerLinearSliceHeights = getAsArrayOfInts(conf, EAGER_LINEAR_HEIGHTS, new int[]{4, 2, 1});
        eagerRndSliceMinWidht = getAsIntegerOrDefault(conf, EAGER_RND_SLICE_MIN_WIDHT, 1000);
        eagerRndMaxCursors = getAsIntegerOrDefault(conf, EAGER_RND_MAX_CURSORS, 50);

        authTokenEnabled = getAsBooleanOrDefault(conf, AUTH_TOKEN_ENABLED, true);
        authTokenTtl = getAsIntegerOrDefault(conf, AUTH_TOKEN_TTL, 15);

        Map<String, Object> etagCheckPolicies = getAsMap(conf, ETAG_CHECK_POLICY_KEY);

        if (etagCheckPolicies != null) {
            String _dbEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_DB_KEY,
                            DEFAULT_DB_ETAG_CHECK_POLICY.name());

            String _collEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_COLL_KEY,
                            DEFAULT_COLL_ETAG_CHECK_POLICY.name());

            String _docEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_DOC_KEY,
                            DEFAULT_DOC_ETAG_CHECK_POLICY.name());

            ETAG_CHECK_POLICY validDbValue;
            ETAG_CHECK_POLICY validCollValue;
            ETAG_CHECK_POLICY validDocValue;

            try {
                validDbValue = ETAG_CHECK_POLICY.valueOf(_dbEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_DB_KEY, DEFAULT_DB_ETAG_CHECK_POLICY);
                validDbValue = DEFAULT_DB_ETAG_CHECK_POLICY;
            }

            dbEtagCheckPolicy = validDbValue;

            try {

                validCollValue = ETAG_CHECK_POLICY.valueOf(_collEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_COLL_KEY, DEFAULT_COLL_ETAG_CHECK_POLICY);
                validCollValue = DEFAULT_COLL_ETAG_CHECK_POLICY;
            }

            collEtagCheckPolicy = validCollValue;

            try {
                validDocValue = ETAG_CHECK_POLICY.valueOf(_docEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_COLL_KEY, DEFAULT_COLL_ETAG_CHECK_POLICY);
                validDocValue = DEFAULT_DOC_ETAG_CHECK_POLICY;
            }

            docEtagCheckPolicy = validDocValue;
        } else {
            dbEtagCheckPolicy = DEFAULT_DB_ETAG_CHECK_POLICY;
            collEtagCheckPolicy = DEFAULT_COLL_ETAG_CHECK_POLICY;
            docEtagCheckPolicy = DEFAULT_DOC_ETAG_CHECK_POLICY;
        }

        logExchangeDump = getAsIntegerOrDefault(conf, LOG_REQUESTS_LEVEL_KEY, 0);

        connectionOptions = getAsMap(conf, CONNECTION_OPTIONS_KEY);
// END Configuration(Map<String,Object>-Map<String,Object>-boolean-boolean)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_020be-c37d7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9455e-5a470
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_9455e_5a470\rev_rev_left_9455e-rev_right_5a470\src\main\java\org\restheart\Configuration.java
Different Spacing: false
Left editions: [1040]
Right editions: [942, 943]
Merged body: 
// START Configuration({FormalParametersInternal})//public Configuration() {
// RIGHT //        this.configurationFileMap = null;
// RIGHT //        
        ansiConsole = true;

        httpsListener = true;
        httpsPort = DEFAULT_HTTPS_PORT;
        httpsHost = DEFAULT_HTTPS_HOST;

        httpListener = true;
        httpPort = DEFAULT_HTTP_PORT;
        httpHost = DEFAULT_HTTP_HOST;

        ajpListener = false;
        ajpPort = DEFAULT_AJP_PORT;
        ajpHost = DEFAULT_AJP_HOST;

        instanceName = DEFAULT_INSTANCE_NAME;

        defaultRepresentationFromat = DEFAULT_REPRESENTATION_FORMAT;

        useEmbeddedKeystore = true;
        keystoreFile = null;
        keystorePassword = null;
        certPassword = null;

        mongoUri = new MongoClientURI(DEFAULT_MONGO_URI);

        mongoMounts = new ArrayList<>();
        Map<String, Object> defaultMongoMounts = new HashMap<>();
        defaultMongoMounts.put(MONGO_MOUNT_WHAT_KEY, "*");
        defaultMongoMounts.put(MONGO_MOUNT_WHERE_KEY, "/");
        mongoMounts.add(defaultMongoMounts);

        applicationLogicMounts = new ArrayList<>();

        staticResourcesMounts = new ArrayList<>();

        metadataNamedSingletons = new ArrayList<>();

        HashMap<String, Object> browserStaticResourcesMountArgs = new HashMap<>();

        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_WHAT_KEY, "browser");
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_WHERE_KEY, "/browser");
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_WELCOME_FILE_KEY, "browser.html");
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_SECURED_KEY, false);
        browserStaticResourcesMountArgs.put(STATIC_RESOURCES_MOUNT_EMBEDDED_KEY, true);

        staticResourcesMounts.add(browserStaticResourcesMountArgs);

        idmImpl = null;
        idmArgs = null;

        authMechanismImpl = null;
        authMechanismArgs = null;

        amImpl = null;
        amArgs = null;

        logFilePath = URLUtils.removeTrailingSlashes(System.getProperty("java.io.tmpdir"))
                .concat(File.separator + "restheart.log");
        logToConsole = true;
        logToFile = true;
        logLevel = Level.INFO;

        localCacheEnabled = true;
        localCacheTtl = 1000;

        schemaCacheEnabled = false;
        schemaCacheTtl = 1000;

        requestsLimit = 100;

        queryTimeLimit = 0;
        aggregationTimeLimit = 0;

        ioThreads = 2;
        workerThreads = 32;
        bufferSize = 16384;
        buffersPerRegion = 20;
        directBuffers = true;

        forceGzipEncoding = false;

        eagerPoolSize = 100;
        eagerLinearSliceWidht = 1000;
        eagerLinearSliceDelta = 100;
        eagerLinearSliceHeights = new int[]{4, 2, 1};
        eagerRndSliceMinWidht = 1000;
        eagerRndMaxCursors = 50;

        authTokenEnabled = true;
        authTokenTtl = 15; // minutes

        dbEtagCheckPolicy = DEFAULT_DB_ETAG_CHECK_POLICY;
        collEtagCheckPolicy = DEFAULT_COLL_ETAG_CHECK_POLICY;
        docEtagCheckPolicy = DEFAULT_DOC_ETAG_CHECK_POLICY;

        logExchangeDump = 0;
// LEFT //        metricsGatheringLevel = METRICS_GATHERING_LEVEL.ROOT;

        connectionOptions = Maps.newHashMap();
// END Configuration({FormalParametersInternal})//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_9455e_5a470\rev_rev_left_9455e-rev_right_5a470\src\main\java\org\restheart\Configuration.java
Different Spacing: false
Left editions: [1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274]
Right editions: [1082, 1083]
Merged body: 
// START Configuration(Map<String,Object>-Map<String,Object>-boolean-boolean)//public Configuration(Map<String, Object> conf, boolean silent) throws ConfigurationException {
// RIGHT //        this.configurationFileMap = conf;
// RIGHT //        
        this.silent = silent;

        ansiConsole = getAsBooleanOrDefault(conf, ANSI_CONSOLE, true);

        httpsListener = getAsBooleanOrDefault(conf, HTTPS_LISTENER, true);
        httpsPort = getAsIntegerOrDefault(conf, HTTPS_PORT_KEY, DEFAULT_HTTPS_PORT);
        httpsHost = getAsStringOrDefault(conf, HTTPS_HOST_KEY, DEFAULT_HTTPS_HOST);

        httpListener = getAsBooleanOrDefault(conf, HTTP_LISTENER_KEY, false);
        httpPort = getAsIntegerOrDefault(conf, HTTP_PORT_KEY, DEFAULT_HTTP_PORT);
        httpHost = getAsStringOrDefault(conf, HTTP_HOST_KEY, DEFAULT_HTTP_HOST);

        ajpListener = getAsBooleanOrDefault(conf, AJP_LISTENER_KEY, false);
        ajpPort = getAsIntegerOrDefault(conf, AJP_PORT_KEY, DEFAULT_AJP_PORT);
        ajpHost = getAsStringOrDefault(conf, AJP_HOST_KEY, DEFAULT_AJP_HOST);

        instanceName = getAsStringOrDefault(conf, INSTANCE_NAME_KEY, DEFAULT_INSTANCE_NAME);

        String _representationFormat = getAsStringOrDefault(conf,
                REPRESENTATION_FORMAT_KEY, DEFAULT_REPRESENTATION_FORMAT.name());

        REPRESENTATION_FORMAT rf = REPRESENTATION_FORMAT.PLAIN_JSON;

        try {
            rf = REPRESENTATION_FORMAT.valueOf(_representationFormat);
        } catch (IllegalArgumentException iar) {
            LOGGER.warn("wrong value for {}. allowed values are {}; "
                    + "setting it to {}",
                    REPRESENTATION_FORMAT_KEY,
                    REPRESENTATION_FORMAT.values(),
                    REPRESENTATION_FORMAT.PLAIN_JSON);
        } finally {
            defaultRepresentationFromat = rf;
        }

        useEmbeddedKeystore = getAsBooleanOrDefault(conf, USE_EMBEDDED_KEYSTORE_KEY, true);
        keystoreFile = getAsStringOrDefault(conf, KEYSTORE_FILE_KEY, null);
        keystorePassword = getAsStringOrDefault(conf, KEYSTORE_PASSWORD_KEY, null);
        certPassword = getAsStringOrDefault(conf, CERT_PASSWORD_KEY, null);

        try {
            mongoUri = new MongoClientURI(getAsStringOrDefault(conf, MONGO_URI_KEY, DEFAULT_MONGO_URI));
        } catch (IllegalArgumentException iae) {
            throw new ConfigurationException("wrong parameter " + MONGO_URI_KEY, iae);
        }

        List<Map<String, Object>> mongoMountsDefault = new ArrayList<>();
        Map<String, Object> defaultMongoMounts = new HashMap<>();
        defaultMongoMounts.put(MONGO_MOUNT_WHAT_KEY, "*");
        defaultMongoMounts.put(MONGO_MOUNT_WHERE_KEY, "/");
        mongoMountsDefault.add(defaultMongoMounts);

        mongoMounts = getAsListOfMaps(conf, MONGO_MOUNTS_KEY, mongoMountsDefault);

        applicationLogicMounts = getAsListOfMaps(conf, APPLICATION_LOGIC_MOUNTS_KEY, new ArrayList<>());

        staticResourcesMounts = getAsListOfMaps(conf, STATIC_RESOURCES_MOUNTS_KEY, new ArrayList<>());

        metadataNamedSingletons = getAsListOfMaps(conf, METADATA_NAMED_SINGLETONS_KEY, new ArrayList<>());

        Map<String, Object> idm = getAsMap(conf, IDM_KEY);
        Map<String, Object> authMech = getAsMap(conf, AUTH_MECHANISM_KEY);
        Map<String, Object> am = getAsMap(conf, ACCESS_MANAGER_KEY);

        idmImpl = getAsStringOrDefault(idm, IMPLEMENTATION_CLASS_KEY, DEFAULT_IDM_IMPLEMENTATION_CLASS);
        idmArgs = idm;

        authMechanismImpl = getAsStringOrDefault(authMech, IMPLEMENTATION_CLASS_KEY, DEFAULT_AUTH_MECHANISM_IMPLEMENTATION_CLASS);
        authMechanismArgs = authMech;

        amImpl = getAsStringOrDefault(am, IMPLEMENTATION_CLASS_KEY, DEFAULT_AM_IMPLEMENTATION_CLASS);
        amArgs = am;

        logFilePath = getAsStringOrDefault(conf, LOG_FILE_PATH_KEY,
                URLUtils.removeTrailingSlashes(System.getProperty("java.io.tmpdir"))
                        .concat(File.separator + "restheart.log"));
        String _logLevel = getAsStringOrDefault(conf, LOG_LEVEL_KEY, "INFO");
        logToConsole = getAsBooleanOrDefault(conf, ENABLE_LOG_CONSOLE_KEY, true);
        logToFile = getAsBooleanOrDefault(conf, ENABLE_LOG_FILE_KEY, true);

        Level level;

        try {
            level = Level.valueOf(_logLevel);
        } catch (Exception e) {
            if (!silent) {
                LOGGER.info("wrong value for parameter {}: {}. using its default value {}", "log-level", _logLevel, "INFO");
            }
            level = Level.INFO;
        }

        logLevel = level;

        requestsLimit = getAsIntegerOrDefault(conf, REQUESTS_LIMIT_KEY, 100);

        queryTimeLimit = getAsLongOrDefault(conf, QUERY_TIME_LIMIT_KEY, (long) 0);
        aggregationTimeLimit = getAsLongOrDefault(conf, AGGREGATION_TIME_LIMIT_KEY, (long) 0);

        localCacheEnabled = getAsBooleanOrDefault(conf, LOCAL_CACHE_ENABLED_KEY, true);
        localCacheTtl = getAsLongOrDefault(conf, LOCAL_CACHE_TTL_KEY, (long) 1000);

        schemaCacheEnabled = getAsBooleanOrDefault(conf, SCHEMA_CACHE_ENABLED_KEY, true);
        schemaCacheTtl = getAsLongOrDefault(conf, SCHEMA_CACHE_TTL_KEY, (long) 1000);

        ioThreads = getAsIntegerOrDefault(conf, IO_THREADS_KEY, 2);
        workerThreads = getAsIntegerOrDefault(conf, WORKER_THREADS_KEY, 32);
        bufferSize = getAsIntegerOrDefault(conf, BUFFER_SIZE_KEY, 16384);
        buffersPerRegion = getAsIntegerOrDefault(conf, BUFFERS_PER_REGION_KEY, 20);
        directBuffers = getAsBooleanOrDefault(conf, DIRECT_BUFFERS_KEY, true);

        forceGzipEncoding = getAsBooleanOrDefault(conf, FORCE_GZIP_ENCODING_KEY, false);

        eagerPoolSize = getAsIntegerOrDefault(conf, EAGER_POOL_SIZE, 100);
        eagerLinearSliceWidht = getAsIntegerOrDefault(conf, EAGER_LINEAR_SLICE_WIDHT, 1000);
        eagerLinearSliceDelta = getAsIntegerOrDefault(conf, EAGER_LINEAR_SLICE_DELTA, 100);
        eagerLinearSliceHeights = getAsArrayOfInts(conf, EAGER_LINEAR_HEIGHTS, new int[]{4, 2, 1});
        eagerRndSliceMinWidht = getAsIntegerOrDefault(conf, EAGER_RND_SLICE_MIN_WIDHT, 1000);
        eagerRndMaxCursors = getAsIntegerOrDefault(conf, EAGER_RND_MAX_CURSORS, 50);

        authTokenEnabled = getAsBooleanOrDefault(conf, AUTH_TOKEN_ENABLED, true);
        authTokenTtl = getAsIntegerOrDefault(conf, AUTH_TOKEN_TTL, 15);

        Map<String, Object> etagCheckPolicies = getAsMap(conf, ETAG_CHECK_POLICY_KEY);

        if (etagCheckPolicies != null) {
            String _dbEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_DB_KEY,
                            DEFAULT_DB_ETAG_CHECK_POLICY.name());

            String _collEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_COLL_KEY,
                            DEFAULT_COLL_ETAG_CHECK_POLICY.name());

            String _docEtagCheckPolicy
                    = getAsStringOrDefault(etagCheckPolicies,
                            ETAG_CHECK_POLICY_DOC_KEY,
                            DEFAULT_DOC_ETAG_CHECK_POLICY.name());

            ETAG_CHECK_POLICY validDbValue;
            ETAG_CHECK_POLICY validCollValue;
            ETAG_CHECK_POLICY validDocValue;

            try {
                validDbValue = ETAG_CHECK_POLICY.valueOf(_dbEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_DB_KEY, DEFAULT_DB_ETAG_CHECK_POLICY);
                validDbValue = DEFAULT_DB_ETAG_CHECK_POLICY;
            }

            dbEtagCheckPolicy = validDbValue;

            try {

                validCollValue = ETAG_CHECK_POLICY.valueOf(_collEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_COLL_KEY, DEFAULT_COLL_ETAG_CHECK_POLICY);
                validCollValue = DEFAULT_COLL_ETAG_CHECK_POLICY;
            }

            collEtagCheckPolicy = validCollValue;

            try {
                validDocValue = ETAG_CHECK_POLICY.valueOf(_docEtagCheckPolicy);
            } catch (IllegalArgumentException iae) {
                LOGGER.warn("wrong value for parameter {} setting it to default value {}",
                        ETAG_CHECK_POLICY_COLL_KEY, DEFAULT_COLL_ETAG_CHECK_POLICY);
                validDocValue = DEFAULT_DOC_ETAG_CHECK_POLICY;
            }

            docEtagCheckPolicy = validDocValue;
        } else {
            dbEtagCheckPolicy = DEFAULT_DB_ETAG_CHECK_POLICY;
            collEtagCheckPolicy = DEFAULT_COLL_ETAG_CHECK_POLICY;
            docEtagCheckPolicy = DEFAULT_DOC_ETAG_CHECK_POLICY;
        }

        logExchangeDump = getAsIntegerOrDefault(conf, LOG_REQUESTS_LEVEL_KEY, 0);
// LEFT //        {
// LEFT //            METRICS_GATHERING_LEVEL mglevel;
// LEFT //            try {
// LEFT //                String value = getAsStringOrDefault(conf, METRICS_GATHERING_LEVEL_KEY, "ROOT");
// LEFT //                mglevel = METRICS_GATHERING_LEVEL.valueOf(value.toUpperCase());
// LEFT //            } catch (IllegalArgumentException iae) {
// LEFT //                mglevel = METRICS_GATHERING_LEVEL.ROOT;
// LEFT //            }
// LEFT //            metricsGatheringLevel = mglevel;
// LEFT //        }

        connectionOptions = getAsMap(conf, CONNECTION_OPTIONS_KEY);
// END Configuration(Map<String,Object>-Map<String,Object>-boolean-boolean)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c37d7-e90d0
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\restheart\revisions\rev_c37d7_e90d0\rev_rev_left_c37d7-rev_right_e90d0\src\main\java\org\restheart\handlers\RequestDispacherHandler.java
Different Spacing: false
Left editions: [346, 347]
Right editions: [326, 327, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373]
Merged body: 
// START defaultInit({FormalParametersInternal})//void defaultInit() {
        LOGGER.trace("Initialize default HTTP handlers:");

        // *** ROOT handlers
        putPipedHttpHandler(TYPE.ROOT, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetRootHandler(
                                new TransformerHandler(
                                        new ResponseSenderHandler(null),
                                        PHASE.RESPONSE,
                                        new PlainJsonTransformer()))));

        // *** DB handlers
        putPipedHttpHandler(TYPE.DB, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetDBHandler(
                                new TransformerHandler(
                                        new ResponseTransformerMetadataHandler(
                                                new ResponseSenderHandler(null)),
                                        PHASE.RESPONSE,
                                        new AggregationTransformer(),
                                        new PlainJsonTransformer()))));

        putPipedHttpHandler(TYPE.DB, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new RequestTransformerMetadataHandler(
                                new PutDBHandler(
                                        respTransformers()))));

        putPipedHttpHandler(TYPE.DB, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteDBHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.DB, METHOD.PATCH,
                new RequestTransformerMetadataHandler(
                        new PatchDBHandler(
                                respTransformers())));

        // *** COLLECTION handlers
        putPipedHttpHandler(TYPE.COLLECTION, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetCollectionHandler(
                                new ResponseTransformerMetadataHandler(
                                        new TransformerHandler(
                                                new HookMetadataHandler(
                                                        new ResponseSenderHandler()),
                                                PHASE.RESPONSE,
                                                new PlainJsonTransformer(),
                                                new AggregationTransformer())))));

        putPipedHttpHandler(TYPE.COLLECTION, METHOD.POST,
                new NormalOrBulkDispatcherHandler(
                        new RequestTransformerMetadataHandler(
                                new BeforeWriteCheckMetadataHandler(
                                        new PostCollectionHandler(
                                                new AfterWriteCheckMetadataHandler(
                                                        respTransformers())))),
                        new RequestTransformerMetadataHandler(
                                new BeforeWriteCheckMetadataHandler(
                                        new BulkPostCollectionHandler(
                                                respTransformers())))));

        putPipedHttpHandler(TYPE.COLLECTION, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new TransformerHandler(
                                new PutCollectionHandler(
                                        respTransformers()),
                                PHASE.REQUEST,
                                new AggregationTransformer())));

        putPipedHttpHandler(TYPE.COLLECTION, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteCollectionHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.COLLECTION, METHOD.PATCH,
                new RequestTransformerMetadataHandler(
                        new TransformerHandler(
                                new PatchCollectionHandler(
                                        respTransformers()),
                                PHASE.REQUEST,
                                new AggregationTransformer())));

        // *** DOCUMENT handlers
        putPipedHttpHandler(TYPE.DOCUMENT, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetDocumentHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.DOCUMENT, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new BeforeWriteCheckMetadataHandler(
                                new PutDocumentHandler(
                                        new AfterWriteCheckMetadataHandler(
                                                respTransformers())))));

        putPipedHttpHandler(TYPE.DOCUMENT, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteDocumentHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.DOCUMENT, METHOD.PATCH,
                new RequestTransformerMetadataHandler(
                        new BeforeWriteCheckMetadataHandler(
                                new PatchDocumentHandler(
                                        new AfterWriteCheckMetadataHandler(
                                                respTransformers())))));

        // *** BULK_DOCUMENTS handlers, i.e. bulk operations
        putPipedHttpHandler(TYPE.BULK_DOCUMENTS, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new BulkDeleteDocumentsHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.BULK_DOCUMENTS, METHOD.PATCH,
                new RequestTransformerMetadataHandler(
                        new BeforeWriteCheckMetadataHandler(
                                new BulkPatchDocumentsHandler(
                                        respTransformers()))));

        // *** COLLECTION_INDEXES handlers
        putPipedHttpHandler(TYPE.COLLECTION_INDEXES, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetIndexesHandler(
                                respTransformers())));

        // *** INDEX handlers
        putPipedHttpHandler(TYPE.INDEX, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new PutIndexHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.INDEX, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteIndexHandler(
                                respTransformers())));

        // *** FILES_BUCKET and FILE handlers
        putPipedHttpHandler(TYPE.FILES_BUCKET, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetCollectionHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.FILES_BUCKET, METHOD.POST,
                new RequestTransformerMetadataHandler(
                        new BeforeWriteCheckMetadataHandler(
                                new PostBucketHandler(
                                        respTransformers()))));

        putPipedHttpHandler(TYPE.FILE, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new BeforeWriteCheckMetadataHandler(
                                new PutFileHandler(
// RIGHT //                                        new FileMetadataHandler(
// RIGHT //                                                respTransformers())))));

        putPipedHttpHandler(TYPE.FILES_BUCKET, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new PutBucketHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.FILES_BUCKET, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteBucketHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.FILE, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetFileHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.FILE_BINARY, METHOD.GET,
                new GetFileBinaryHandler(
// LEFT //                        new HookMetadataHandler(
// LEFT //                                new ResponseSenderHandler())));

        putPipedHttpHandler(TYPE.FILE, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteFileHandler(
                                respTransformers())));

// RIGHT //        // PUTting or PATCHing a file involves updating the metadata in the
// RIGHT //        // xxx.files bucket for an _id. Although the chunks are immutable we
// RIGHT //        // can treat the metadata like a regular document.
// RIGHT //        putPipedHttpHandler(TYPE.FILE, METHOD.PATCH,
// RIGHT //                new RequestTransformerMetadataHandler(
// RIGHT //                        new BeforeWriteCheckMetadataHandler(
// RIGHT //                                new FileMetadataHandler(
// RIGHT //                                        new AfterWriteCheckMetadataHandler(
// RIGHT //                                                respTransformers())))));
// RIGHT //
// RIGHT //        /*
// RIGHT //         * TODO There's already a PUT handler that allows custom id's to be set. Need to think about how to handle PUT with no binary data
// RIGHT //        putPipedHttpHandler(TYPE.FILE, METHOD.PUT,
// RIGHT //                new RequestTransformerMetadataHandler(
// RIGHT //                        new BeforeWriteCheckMetadataHandler(
// RIGHT //                                new FileMetadataHandler(
// RIGHT //                                        new AfterWriteCheckMetadataHandler(
// RIGHT //                                                respTransformers())))));
// RIGHT //         */
// RIGHT //
        // *** AGGREGATION handler
        putPipedHttpHandler(TYPE.AGGREGATION, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetAggregationHandler(
                                respTransformers())));

        // *** SCHEMA handlers
        putPipedHttpHandler(TYPE.SCHEMA_STORE, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetCollectionHandler(
                                new TransformerHandler(
                                        respTransformers(),
                                        PHASE.RESPONSE,
                                        new JsonSchemaTransformer()))));

        putPipedHttpHandler(TYPE.SCHEMA_STORE, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new PutCollectionHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.SCHEMA_STORE, METHOD.POST,
                new RequestTransformerMetadataHandler(
                        new CheckHandler(
                                new TransformerHandler(
                                        new PostCollectionHandler(
                                                respTransformers()),
                                        PHASE.REQUEST,
                                        new JsonSchemaTransformer()),
                                new JsonMetaSchemaChecker())));

        putPipedHttpHandler(TYPE.SCHEMA_STORE, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteCollectionHandler(
                                respTransformers())));

        putPipedHttpHandler(TYPE.SCHEMA, METHOD.GET,
                new RequestTransformerMetadataHandler(
                        new GetDocumentHandler(
                                new TransformerHandler(
                                        respTransformers(),
                                        PHASE.RESPONSE,
                                        new JsonSchemaTransformer()))));

        putPipedHttpHandler(TYPE.SCHEMA, METHOD.PUT,
                new RequestTransformerMetadataHandler(
                        new CheckHandler(
                                new TransformerHandler(
                                        new PutDocumentHandler(
                                                respTransformers()),
                                        PHASE.REQUEST,
                                        new JsonSchemaTransformer()),
                                new JsonMetaSchemaChecker())));

        putPipedHttpHandler(TYPE.SCHEMA, METHOD.DELETE,
                new RequestTransformerMetadataHandler(
                        new DeleteDocumentHandler(
                                respTransformers())));
// END defaultInit({FormalParametersInternal})//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_78c64-b86b8
#MS_XXX_MS#

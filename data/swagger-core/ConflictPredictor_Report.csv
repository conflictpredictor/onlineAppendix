#MS_XXX_MS#
Merge scenario: rev_49f88-a09c2
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c3f48-a944a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a9d08-dd0fd
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f0a10-07e3a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0d567-09c2b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_685a0-ebbd5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_516b4-2ea3d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d492e-04aa2
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e8efe-6005a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4f3d1-0f668
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8adc8-500ef
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5d858-3df1e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d298d-5ca8a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_16e3c-882e1
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_560eb-58d91
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b1911-52147
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_974c9-a8280
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_08999-47703
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f018a-798d3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_52d21-0cd5a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_43668-d453e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f018a-14d08
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7d577-a7489
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4ccce-3b9a6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_bf0a4-fd46c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5369e-0b9b5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_accfa-a00dd
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3a3c6-be323
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_47fc3-e76fa
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4a0b4-f46bb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_00365-cce5c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ef9b6-d6cca
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_684b9-b2479
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_81b2b-69cdd
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3515a-d8c80
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0937e-437de
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ce421-cba9d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2fc3f-44a89
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_058bd-c98a5
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_058bd_c98a5\rev_rev_left_058bd-rev_right_c98a5\modules\swagger-models\src\main\java\com\wordnik\swagger\models\properties\PropertyBuilder.java
Different Spacing: false
Left editions: [91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
Right editions: [31, 86, 87, 88, 89]
Merged body: 
// START build(String-String-String-String-Map<String,Object>-Map<String,Object>)//public static Property build(String type, String format, Map<String, Object> args) {
    if(args == null)
        args = new HashMap<String, Object>();
    List<String> _enum = (List<String>) args.get("enum");
    String title = (String)args.get("title");
    String description = (String)args.get("description");
    String _default = (String)args.get("default");
    String pattern = (String)args.get("pattern");
    String discriminator = (String)args.get("discriminator");
    Integer minItems = (Integer)args.get("minItems");
    Integer maxItems = (Integer)args.get("maxItems");
    Integer minProperties = (Integer)args.get("minProperties");
    Integer maxProperties = (Integer)args.get("maxProperties");
    Integer minLength = (Integer)args.get("minLength");
    Integer maxLength = (Integer)args.get("maxLength");
    Double minimum = (Double)args.get("minimum");
    Double maximum = (Double)args.get("maximum");
    Double exclusiveMinimum = (Double)args.get("exclusiveMinimum");
    Double exclusiveMaximum = (Double)args.get("exclusiveMaximum");
    Boolean uniqueItems = (Boolean)args.get("uniqueItems");

// RIGHT //    AbstractProperty property = null;
    if(BooleanProperty.isType(type, format))
      property = new BooleanProperty();
    if(DateProperty.isType(type, format))
      property = new DateProperty();
    if(DateTimeProperty.isType(type, format))
      property = new DateTimeProperty();
    if(DoubleProperty.isType(type, format))
      property = new DoubleProperty()
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMinimum);
    if(FloatProperty.isType(type, format))
      property = new FloatProperty()
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMinimum);
    if(DecimalProperty.isType(type, format))
      property = new DecimalProperty()
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMinimum);
    if(IntegerProperty.isType(type, format))
      property = new IntegerProperty()
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMinimum);
    if(LongProperty.isType(type, format))
      property = new LongProperty()
        .minimum(minimum)
        .maximum(maximum)
        .exclusiveMinimum(exclusiveMinimum)
        .exclusiveMaximum(exclusiveMinimum);
    if(RefProperty.isType(type, format))
      property = new RefProperty();
    if(StringProperty.isType(type, format))
      property = new StringProperty()
        .minLength(minLength)
        .maxLength(maxLength)
        .pattern(pattern)
        ._enum(_enum);
    if(UUIDProperty.isType(type, format))
      property = new UUIDProperty()
        .minLength(minLength)
        .maxLength(maxLength)
        .pattern(pattern);
    // general properties
    if(property != null) {
      property
        .title(title)
        .description(description);
// RIGHT //      String example = (String)args.get("example");
// RIGHT //      if (example != null) {
// RIGHT //        property.setExample(example);
// RIGHT //      }
    }
// LEFT //    // fallbacks
// LEFT //    if("integer".equals(type) && format == null) {
// LEFT //        // fall back to Integer if type is integer and format is missing
// LEFT //      System.out.println("no format specified for integer type, falling back to int32");
// LEFT //      property = new IntegerProperty()
// LEFT //        .minimum(minimum)
// LEFT //        .maximum(maximum)
// LEFT //        .exclusiveMinimum(exclusiveMinimum)
// LEFT //        .exclusiveMaximum(exclusiveMinimum);
// LEFT //    }
    if(property == null)
      System.out.println("no property for " + type + ", " + format);
    return property;
// END build(String-String-String-String-Map<String,Object>-Map<String,Object>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d5ade-20cc9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e0058-a087a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_aa4ee-c4c8d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b505c-8eb19
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_22998-3b57b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_649ba-1e6f9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7042c-abbe9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_eb281-9fc50
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_218a6-e4636
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5a0f4-1485e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2e65c-566de
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_2e65c_566de\rev_rev_left_2e65c-rev_right_566de\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START getParameter(Class<?>-Class<?>-Type-Type-Annotation[]-Annotation[])//Parameter getParameter(Class<?> cls, Type type, Annotation[] annotations) {
    // look for path, query
    Parameter parameter = null;
    String defaultValue = null;
    boolean allowMultiple;
    String allowableValues;
    boolean isArray = false;
    
    // see if it's a collection type
    if(type instanceof ParameterizedType){
      ParameterizedType aType = (ParameterizedType) type;
      Type[] parameterArgTypes = aType.getActualTypeArguments();
      for(Type parameterArgType : parameterArgTypes){
      	if(cls.isAssignableFrom(List.class)){
      		isArray = true;
      	}
        Class<?> parameterArgClass = (Class<?>) parameterArgType;
        cls = parameterArgClass;
      }
    }

    boolean shouldIgnore = false;
    for(SwaggerExtension ext : EXTENSIONS) {
      shouldIgnore = ext.shouldIgnoreClass(cls);
      if(!shouldIgnore)
        parameter = ext.processParameter(annotations, cls, isArray);
    }

    if(parameter == null) {
      for(Annotation annotation : annotations) {
        if(annotation instanceof QueryParam) {
          QueryParam param = (QueryParam) annotation;
          QueryParameter qp = new QueryParameter()
            .name(param.value());
          qp.setDefaultValue(defaultValue);
          Property schema = ModelConverters.readAsProperty(cls);
          if(schema != null)
            qp.setProperty(schema);
          parameter = qp;
        }
        else if(annotation instanceof PathParam) {
          PathParam param = (PathParam) annotation;
          PathParameter pp = new PathParameter()
            .name(param.value());
          pp.setDefaultValue(defaultValue);
          Property schema = ModelConverters.readAsProperty(cls);
          if(schema != null)
            pp.setProperty(schema);
          parameter = pp;
        }
        else if(annotation instanceof HeaderParam) {
          HeaderParam param = (HeaderParam) annotation;
          HeaderParameter hp = new HeaderParameter()
            .name(param.value());
          hp.setDefaultValue(defaultValue);
          Property schema = ModelConverters.readAsProperty(cls);
          if(schema != null)
            hp.setProperty(schema);
          parameter = hp;
        }
        else if(annotation instanceof CookieParam) {
          CookieParam param = (CookieParam) annotation;
          CookieParameter cp = new CookieParameter()
            .name(param.value());
          cp.setDefaultValue(defaultValue);
          Property schema = ModelConverters.readAsProperty(cls);
          if(schema != null)
            cp.setProperty(schema);
          parameter = cp;
        }
        else if(annotation instanceof FormParam) {
          FormParam param = (FormParam) annotation;
          FormParameter fp = new FormParameter()
            .name(param.value());
          fp.setDefaultValue(defaultValue);
          Property schema = ModelConverters.readAsProperty(cls);
          if(schema != null)
            fp.setProperty(schema);
          parameter = fp;
        }
        else if(annotation instanceof DefaultValue) {
          DefaultValue defaultValueAnnotation = (DefaultValue) annotation;
          // TODO: not supported yet
          defaultValue = defaultValueAnnotation.value();
        }
      }
    }

    // lastly apply ApiParam
    for(Annotation annotation: annotations) {
      if(annotation instanceof ApiParam) {
        ApiParam param = (ApiParam) annotation;
        if(parameter != null) {
          if(!"".equals(param.defaultValue())){
            defaultValue = param.defaultValue();
          }

          // parameter.required(param.required());
          if(param.name() != null && !"".equals(param.name()))
            parameter.setName(param.name());
          parameter.setDescription(param.value());
          parameter.setAccess(param.access());
          allowMultiple = param.allowMultiple() || isArray;
          if(allowMultiple == true) {
            if(parameter instanceof PathParameter) {
              PathParameter p = (PathParameter) parameter;
              Property items = PropertyBuilder.build(p.getType(), p.getFormat(), null);
              p.items(items)
                .array(true)
                .collectionFormat("multi");
              p.setDefaultValue(defaultValue);
            }
            else if(parameter instanceof QueryParameter) {
              QueryParameter p = (QueryParameter) parameter;
              Property items = PropertyBuilder.build(p.getType(), p.getFormat(), null);
              p.items(items)
                .array(true)
                .collectionFormat("multi");
              p.setDefaultValue(defaultValue);
            }
            else if(parameter instanceof HeaderParameter) {
              HeaderParameter p = (HeaderParameter) parameter;
              Property items = PropertyBuilder.build(p.getType(), p.getFormat(), null);
              p.items(items)
                .array(true)
                .collectionFormat("multi");
              p.setDefaultValue(defaultValue);
            }
            else if(parameter instanceof CookieParameter) {
              CookieParameter p = (CookieParameter) parameter;
              Property items = PropertyBuilder.build(p.getType(), p.getFormat(), null);
              p.items(items)
                .array(true)
                .collectionFormat("multi");
              p.setDefaultValue(defaultValue);
            }
          }

          allowableValues = param.allowableValues();
        }
        else if(shouldIgnore == false) {
          // must be a body param
          BodyParameter bp = new BodyParameter();
          if(param.name() != null && !"".equals(param.name()))
            bp.setName(param.name());
          else
            bp.setName("body");
          bp.setDescription(param.value());

          if(cls.isArray()) {
            Class innerType = cls.getComponentType();
            Property innerProperty = ModelConverters.readAsProperty(innerType);
            if(innerProperty == null) {
              Map<String, Model> models = ModelConverters.read(innerType);
              if(models.size() > 0) {
                for(String name: models.keySet()) {
                  if(name.indexOf("java.util") == -1) {
                    bp.setSchema(
                      new ArrayModel().items(new RefProperty().asDefault(name))
                    );
                    swagger.addDefinition(name, models.get(name));
                  }
                }
              }
              models = ModelConverters.readAll(innerType);
              for(String key : models.keySet()) {
                swagger.model(key, models.get(key));
              }
            }
            else {
              bp.setSchema(new ArrayModel().items(innerProperty));
            }
          }
          else {
            Map<String, Model> models = ModelConverters.read(cls);
            if(models.size() > 0) {
              for(String name: models.keySet()) {
                if(name.indexOf("java.util") == -1) {
                  if(isArray)
                    bp.setSchema(new ArrayModel().items(new RefProperty().asDefault(name)));
                  else
                    bp.setSchema(new RefModel().asDefault(name));
                  swagger.addDefinition(name, models.get(name));
                }
              }
              models = ModelConverters.readAll(cls);
              for(String key : models.keySet()) {
                swagger.model(key, models.get(key));
              }
            }
            else {
              Property prop = ModelConverters.readAsProperty(cls);
              if(prop != null) {
                ModelImpl model = new ModelImpl();
                model.setType(prop.getType());
                bp.setSchema(model);
              }
            }
          }
          parameter = bp;
        }
      }
    }
    return parameter;
// END getParameter(Class<?>-Class<?>-Type-Type-Annotation[]-Annotation[])//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d9f3d-e8570
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fd6c7-935ae
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a0c7b-96e0f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b2adc-31475
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c9ff4-6fbb9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_857f4-fc45d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d9aa0-06830
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ebc2f-bfd12
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2c412-39ce9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a3258-d7920
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_98f18-d0a98
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c2113-b0909
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_20152-b7ec5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fde0f-203a4
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1d240-b5961
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0c704-4e217
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_793b7-242f2
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_81b35-96321
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b45cc-2a6ac
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f23e2-32f02
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c4260-26f9e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c5aa9-8c15d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c6eda-e9b90
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e7036-40d5e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_279a6-e9ac8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d588f-32eee
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d9607-ef141
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f7dc3-53107
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_f7dc3_53107\rev_rev_left_f7dc3-rev_right_53107\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\config\BeanConfig.java
Different Spacing: false
Left editions: [272]
Right editions: [303, 304, 305, 306]
Merged body: 
// START classes({FormalParametersInternal})//public Set<Class<?>> classes() {
    ConfigurationBuilder config = new ConfigurationBuilder();
    Set<String> acceptablePackages = new HashSet<String>();

// LEFT //    if(resourcePackage != null && !"".equals(resourcePackage)) {
      String[] parts = resourcePackage.split(",");
      for(String pkg : parts) {
        if(!"".equals(pkg)) {
          acceptablePackages.add(pkg);
          config.addUrls(ClasspathHelper.forPackage(pkg));
        }
      }
    }

    config.setScanners(new ResourcesScanner(), new TypeAnnotationsScanner(), new SubTypesScanner());

    this.info = new Info()
      .description(description)
      .title(title)
      .version(version)
      .termsOfService(termsOfServiceUrl);

    if(contact != null)
      this.info.contact(new Contact()
        .name(contact));
    if(license != null && licenseUrl != null)
      this.info.license(new License()
        .name(license)
        .url(licenseUrl));
    if(schemes != null) {
      for(String scheme : schemes)
        reader.getSwagger().scheme(Scheme.forValue(scheme));
    }

    reader.getSwagger().setInfo(info);
// RIGHT //    final Reflections reflections = new Reflections(config);
// RIGHT //	Set<Class<?>> classes = reflections.getTypesAnnotatedWith(Api.class);
// RIGHT //    classes.addAll(reflections.getTypesAnnotatedWith(javax.ws.rs.Path.class));
// RIGHT //    
    Set<Class<?>> output = new HashSet<Class<?>>();
    for(Class<?> cls : classes) {
      if(acceptablePackages.contains(cls.getPackage().getName()))
        output.add(cls);
    }
    return output;
// END classes({FormalParametersInternal})//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_070c8-cf85b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_34da0-5bad7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_eb45a-ce74c
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_eb45a_ce74c\rev_rev_left_eb45a-rev_right_ce74c\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [132, 133, 134, 136, 137, 139, 165, 179, 180, 181, 182, 187, 196, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 267, 268, 269]
Right editions: [151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 250, 259]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
    if(swagger == null)
      swagger = new Swagger();
    Api api = (Api) cls.getAnnotation(Api.class);
    Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

    javax.ws.rs.Path apiPath = (javax.ws.rs.Path) cls.getAnnotation(javax.ws.rs.Path.class);

// LEFT //    Map<String, Tag> tags = new HashMap<String, Tag>();
// LEFT //    List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
// LEFT //    
    // only read if allowing hidden apis OR api is not marked as hidden
// LEFT //    final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
// LEFT //    if(readable) {
      // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
// LEFT //      Set<String> tagStrings = extractTags(api);      
      for(String tagString : tagStrings) {
        Tag tag = new Tag().name(tagString);
        tags.put(tagString, tag);
      }
      if(parentTags != null)
        tags.putAll(parentTags);
      for(String tagName: tags.keySet()) {
        swagger.tag(tags.get(tagName));
      }

      int position = api.position();
// RIGHT //      String[] produces = new String[0];
// RIGHT //      if (!api.produces().isEmpty()) {
// RIGHT //        produces = new String[]{api.produces()};
// RIGHT //      } else if (cls.getAnnotation(Produces.class) != null) {
// RIGHT //        produces = ((Produces) cls.getAnnotation(Produces.class)).value();
// RIGHT //      }
// RIGHT //      String[] consumes = new String[0];
// RIGHT //      if (!api.consumes().isEmpty()){
// RIGHT //        consumes = new String[]{api.consumes()};
// RIGHT //      } else if (cls.getAnnotation(Consumes.class) != null){
// RIGHT //        consumes = ((Consumes)cls.getAnnotation(Consumes.class)).value();
// RIGHT //      }
      String schems = api.protocols();
      Authorization[] authorizations = api.authorizations();
// LEFT //      
      for(Authorization auth : authorizations) {
        if(auth.value() != null && !"".equals(auth.value())) {
          SecurityRequirement security = new SecurityRequirement();
          security.setName(auth.value());
          AuthorizationScope[] scopes = auth.scopes();
          for(AuthorizationScope scope : scopes) {
            if(scope.scope() != null && !"".equals(scope.scope())) {
              security.addScope(scope.scope());
            }
          }
          securities.add(security);
        }
      }
// LEFT //    }
// LEFT //    
// LEFT //    // allow reading the JAX-RS APIs without @Api annotation
// LEFT //    if (api == null || readable) {
      // merge consumes, produces

      // look for method-level annotated properties

// LEFT //      // handle sub-resources by looking at return type

      // parse the method
      Method methods[] = cls.getMethods();
      for(Method method : methods) {
        ApiOperation apiOperation = (ApiOperation) method.getAnnotation(ApiOperation.class);
        javax.ws.rs.Path methodPath = method.getAnnotation(javax.ws.rs.Path.class);

        String operationPath = getPath(apiPath, methodPath, parentPath);
// LEFT //        if(operationPath != null) {
          String [] pps = operationPath.split("/");
          String [] pathParts = new String[pps.length];
          Map<String, String> regexMap = new HashMap<String, String>();

          for(int i = 0; i < pps.length; i++) {
            String p = pps[i];
            if(p.startsWith("{")) {
              int pos = p.indexOf(":");
              if(pos > 0) {
                String left = p.substring(1, pos);
                String right = p.substring(pos + 1, p.length()-1);
                pathParts[i] = "{" + left + "}";
                regexMap.put(left, right);
              }
              else
                pathParts[i] = p;
            }
            else pathParts[i] = p;
          }
          StringBuilder pathBuilder = new StringBuilder();
          for(String p : pathParts) {
            if(!p.isEmpty())
              pathBuilder.append("/").append(p);
          }
          operationPath = pathBuilder.toString();

          String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

          Operation operation = parseMethod(method);
          if(parentParameters != null) {
            for(Parameter param : parentParameters) {
              operation.parameter(param);
            }
          }
          for(Parameter param : operation.getParameters()) {
            if(regexMap.get(param.getName()) != null) {
              String pattern = regexMap.get(param.getName());
              param.setPattern(pattern);
            }
          }

// LEFT //          if (apiOperation != null) {
// LEFT //	          String protocols = apiOperation.protocols();
// LEFT //	          if(!"".equals(protocols)) {
// LEFT //	            String[] parts = protocols.split(",");
// LEFT //	            for(String part : parts) {
// LEFT //	              String trimmed = part.trim();
// LEFT //	              if(!"".equals(trimmed))
// LEFT //	                operation.scheme(Scheme.forValue(trimmed));
// LEFT //	            }
// LEFT //	          }
          }

// RIGHT //          String[] apiConsumes = consumes;
          if(parentConsumes != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
            both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
            if(operation.getConsumes() != null)
              both.addAll(new HashSet<String>(operation.getConsumes()));
            apiConsumes = both.toArray(new String[both.size()]);
          }

// RIGHT //          String[] apiProduces = produces;
          if(parentProduces != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
            both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
            if(operation.getProduces() != null)
              both.addAll(new HashSet<String>(operation.getProduces()));
            apiProduces = both.toArray(new String[both.size()]);
          }
// LEFT //          final Class<?> subResource = getSubResource(method);
// LEFT //          if (subResource != null) {
// LEFT //            read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
          }

          // can't continue without a valid http method
          httpMethod = httpMethod == null ? parentMethod : httpMethod;
          if(httpMethod != null) {
            ApiOperation op = (ApiOperation) method.getAnnotation(ApiOperation.class);
            if(op != null) {
              boolean hasExplicitTag = false;
              for(String tag : op.tags()) {
                if(!"".equals(tag)) {
                  operation.tag(tag);
                  swagger.tag(new Tag().name(tag));
                }
              }
            }
            if(operation != null) {
              if(operation.getConsumes() == null)
                for(String mediaType: apiConsumes)
                  operation.consumes(mediaType);
              if(operation.getProduces() == null)
                for(String mediaType: apiProduces)
                  operation.produces(mediaType);

              if(operation.getTags() == null) {
                for(String tagString : tags.keySet())
                  operation.tag(tagString);
              }
              for(SecurityRequirement security : securities)
                operation.security(security);

              Path path = swagger.getPath(operationPath);
              if(path == null) {
                path = new Path();
                swagger.path(operationPath, path);
              }
              path.set(httpMethod, operation);
            }
          }
        }
      }
    }
    return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9c898-51f3b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fe1a9-02308
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_cf374-c60a9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d4426-0883e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_15c82-5c89f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5648a-b3b9f
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_5648a_b3b9f\rev_rev_left_5648a-rev_right_b3b9f\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\ParameterProcessor.java
Different Spacing: false
Left editions: [113]
Right editions: [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91, 92, 93, 94, 95, 98, 99, 100, 102, 103, 107, 110]
Merged body: 
// START applyAnnotations(Swagger-Swagger-Parameter-Parameter-Class<?>-Class<?>-Annotation[]-Annotation[]-boolean-boolean)//public static Parameter applyAnnotations(Swagger swagger, Parameter parameter, Class<?> cls, Annotation[] annotations, boolean isArray) {
    for(Annotation annotation : annotations) {
      if(annotation instanceof ApiParam) {
        ApiParam param = (ApiParam) annotation;
// RIGHT //        if (parameter instanceof AbstractSerializableParameter) {
// RIGHT //          final AbstractSerializableParameter p = (AbstractSerializableParameter) parameter;
// RIGHT //
// RIGHT //          if (param.required()) {
// RIGHT //            p.setRequired(param.required());
// RIGHT //          }
// RIGHT //          final String name = param.name();
// RIGHT //          if (StringUtils.isNotEmpty(name)) {
// RIGHT //            p.setName(name);
// RIGHT //          }
// RIGHT //          p.setDescription(param.value());
// RIGHT //          p.setAccess(param.access());
// RIGHT //
// RIGHT //          AllowableValues allowableValues = null;
// RIGHT //          final String allowableValuesString = param.allowableValues();
// RIGHT //          if (allowableValuesString != null) {
// RIGHT //            allowableValues = AllowableRangeValues.create(allowableValuesString);
// RIGHT //            if (allowableValues == null) {
// RIGHT //              allowableValues = AllowableEnumValues.create(allowableValuesString);
// RIGHT //            }
          }

// RIGHT //          final String defaultValue = param.defaultValue();
// RIGHT //          if (param.allowMultiple() || isArray) {
// RIGHT //            final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
// RIGHT //            if (!defaultValue.isEmpty()) {
// RIGHT //              args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
// RIGHT //            }
// RIGHT //            if (allowableValues != null) {
// RIGHT //              allowableValuesProcessors.get(allowableValues.getClass(), true).process(args, allowableValues);
          }

// RIGHT //            p.items(PropertyBuilder.build(p.getType(), p.getFormat(), args))
// RIGHT //              .type(ArrayProperty.TYPE)
// RIGHT //              .format(null)
                .collectionFormat("multi");
// RIGHT //          } else {
// RIGHT //            if (!defaultValue.isEmpty()) {
              p.setDefaultValue(defaultValue);
          }
          if(allowableValues != null) {
// RIGHT //              allowableValuesProcessors.get(allowableValues.getClass(), false).process(p, allowableValues);
          }
        }
// RIGHT //        } else {
          // must be a body param
          BodyParameter bp = new BodyParameter();
// LEFT //          bp.setRequired(param.required());
          if(param.name() != null && !"".equals(param.name()))
            bp.setName(param.name());
          else
            bp.setName("body");
          bp.setDescription(param.value());

          if(cls.isArray() || isArray) {
            Class<?> innerType;
            if(isArray) {// array has already been detected
              innerType = cls;
            }
            else
              innerType = cls.getComponentType();
            LOGGER.debug("inner type: " + innerType + " from " + cls);
            Property innerProperty = ModelConverters.getInstance().readAsProperty(innerType);
            if(innerProperty == null) {
              Map<String, Model> models = ModelConverters.getInstance().read(innerType);
              if(models.size() > 0) {
                for(String name: models.keySet()) {
                  if(name.indexOf("java.util") == -1) {
                    bp.setSchema(
                      new ArrayModel().items(new RefProperty().asDefault(name)));
                    if(swagger != null)
                      swagger.addDefinition(name, models.get(name));
                  }
                }
              }
              models = ModelConverters.getInstance().readAll(innerType);
              if(swagger != null) {
                for(String key : models.keySet()) {
                  swagger.model(key, models.get(key));
                }
              }
            }
            else {
              LOGGER.debug("found inner property " + innerProperty);
              bp.setSchema(new ArrayModel().items(innerProperty));

              // creation of ref property doesn't add model to definitions - do it now instead
              if( innerProperty instanceof RefProperty && swagger != null) {
                  Map<String, Model> models = ModelConverters.getInstance().read(innerType);
                  String name = ((RefProperty)innerProperty).getSimpleRef();
                  swagger.addDefinition(name, models.get(name));

                  LOGGER.debug( "added model definition for RefProperty " + name );
              }
            }
          }
          else {
            Map<String, Model> models = ModelConverters.getInstance().read(cls);
            if(models.size() > 0) {
              for(String name: models.keySet()) {
                if(name.indexOf("java.util") == -1) {
                  if(isArray)
                    bp.setSchema(new ArrayModel().items(new RefProperty().asDefault(name)));
                  else
                    bp.setSchema(new RefModel().asDefault(name));
                  if(swagger != null)
                    swagger.addDefinition(name, models.get(name));
                }
              }
              models = ModelConverters.getInstance().readAll(cls);
              if(swagger != null) {
                for(String key : models.keySet()) {
                  swagger.model(key, models.get(key));
                }
              }
            }
            else {
              Property prop = ModelConverters.getInstance().readAsProperty(cls);
              if(prop != null) {
                ModelImpl model = new ModelImpl();
                model.setType(prop.getType());
                bp.setSchema(model);
              }
            }
          }
          parameter = bp;
        }
      }
    }
    return parameter;
// END applyAnnotations(Swagger-Swagger-Parameter-Parameter-Class<?>-Class<?>-Annotation[]-Annotation[]-boolean-boolean)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_53525-57d18
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6c17c-ef40d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_96c46-7268e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_60518-b7719
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_60518_b7719\rev_rev_left_60518-rev_right_b7719\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [206, 239]
Right editions: [152, 179, 256, 257, 260, 261, 262, 263, 264]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
    if(swagger == null)
      swagger = new Swagger();
    Api api = (Api) cls.getAnnotation(Api.class);
    Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

    Map<String, Tag> tags = new HashMap<String, Tag>();
    List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
    
    String[] consumes = new String[0];
    String[] produces = new String[0];
// RIGHT //    final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

    // only read if allowing hidden apis OR api is not marked as hidden
    final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
    if(readable) {
      // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
      Set<String> tagStrings = extractTags(api);      
      for(String tagString : tagStrings) {
        Tag tag = new Tag().name(tagString);
        tags.put(tagString, tag);
      }
      if(parentTags != null)
        tags.putAll(parentTags);
      for(String tagName: tags.keySet()) {
        swagger.tag(tags.get(tagName));
      }

      if (!api.produces().isEmpty()) {
        produces = new String[]{api.produces()};
      } else if (cls.getAnnotation(Produces.class) != null) {
        produces = ((Produces) cls.getAnnotation(Produces.class)).value();
      }
      if (!api.consumes().isEmpty()){
        consumes = new String[]{api.consumes()};
      } else if (cls.getAnnotation(Consumes.class) != null){
        consumes = ((Consumes)cls.getAnnotation(Consumes.class)).value();
      }
// RIGHT //      globalSchemes.addAll(parseSchemes(api.protocols()));
      Authorization[] authorizations = api.authorizations();
      
      for(Authorization auth : authorizations) {
        if(auth.value() != null && !"".equals(auth.value())) {
          SecurityRequirement security = new SecurityRequirement();
          security.setName(auth.value());
          AuthorizationScope[] scopes = auth.scopes();
          for(AuthorizationScope scope : scopes) {
            if(scope.scope() != null && !"".equals(scope.scope())) {
              security.addScope(scope.scope());
            }
          }
          securities.add(security);
        }
      }
    }
    
    // allow reading the JAX-RS APIs without @Api annotation
    if (api == null || readable) {
      // merge consumes, produces

      // look for method-level annotated properties

      // handle sub-resources by looking at return type

      // parse the method
// LEFT //      final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
      Method methods[] = cls.getMethods();
      for(Method method : methods) {
        javax.ws.rs.Path methodPath = method.getAnnotation(javax.ws.rs.Path.class);

        String operationPath = getPath(apiPath, methodPath, parentPath);
        if(operationPath != null) {
          String [] pps = operationPath.split("/");
          String [] pathParts = new String[pps.length];
          Map<String, String> regexMap = new HashMap<String, String>();

          for(int i = 0; i < pps.length; i++) {
            String p = pps[i];
            if(p.startsWith("{")) {
              int pos = p.indexOf(":");
              if(pos > 0) {
                String left = p.substring(1, pos);
                String right = p.substring(pos + 1, p.length()-1);
                pathParts[i] = "{" + left + "}";
                regexMap.put(left, right);
              }
              else
                pathParts[i] = p;
            }
            else pathParts[i] = p;
          }
          StringBuilder pathBuilder = new StringBuilder();
          for(String p : pathParts) {
            if(!p.isEmpty())
              pathBuilder.append("/").append(p);
          }
          operationPath = pathBuilder.toString();

// LEFT //          final ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);
          String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

          Operation operation = parseMethod(method);
          if(parentParameters != null) {
            for(Parameter param : parentParameters) {
              operation.parameter(param);
            }
          }
          for(Parameter param : operation.getParameters()) {
            if(regexMap.get(param.getName()) != null) {
              String pattern = regexMap.get(param.getName());
              param.setPattern(pattern);
            }
          }

          if (apiOperation != null) {
// RIGHT //            for (Scheme scheme: parseSchemes(apiOperation.protocols())) {
// RIGHT //              operation.scheme(scheme);
	            }
	          }
// RIGHT //
// RIGHT //          if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
// RIGHT //            for (Scheme scheme: globalSchemes) {
// RIGHT //              operation.scheme(scheme);
// RIGHT //            }
          }

          String[] apiConsumes = consumes;
          if(parentConsumes != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
            both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
            if(operation.getConsumes() != null)
              both.addAll(new HashSet<String>(operation.getConsumes()));
            apiConsumes = both.toArray(new String[both.size()]);
          }

          String[] apiProduces = produces;
          if(parentProduces != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
            both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
            if(operation.getProduces() != null)
              both.addAll(new HashSet<String>(operation.getProduces()));
            apiProduces = both.toArray(new String[both.size()]);
          }
          final Class<?> subResource = getSubResource(method);
          if (subResource != null) {
            read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
          }

          // can't continue without a valid http method
          httpMethod = httpMethod == null ? parentMethod : httpMethod;
          if(httpMethod != null) {
            ApiOperation op = (ApiOperation) method.getAnnotation(ApiOperation.class);
            if(op != null) {
              boolean hasExplicitTag = false;
              for(String tag : op.tags()) {
                if(!"".equals(tag)) {
                  operation.tag(tag);
                  swagger.tag(new Tag().name(tag));
                }
              }
            }
            if(operation != null) {
              if(operation.getConsumes() == null)
                for(String mediaType: apiConsumes)
                  operation.consumes(mediaType);
              if(operation.getProduces() == null)
                for(String mediaType: apiProduces)
                  operation.produces(mediaType);

              if(operation.getTags() == null) {
                for(String tagString : tags.keySet())
                  operation.tag(tagString);
              }
              for(SecurityRequirement security : securities)
                operation.security(security);

              Path path = swagger.getPath(operationPath);
              if(path == null) {
                path = new Path();
                swagger.path(operationPath, path);
              }
              path.set(httpMethod, operation);
            }
          }
        }
      }
    }
    return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8d84e-12768
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8bc08-bd2bc
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_afd26-203df
#CP_===_CP#
Type: EditDiffMC
File: C:\download\ssmerge\swagger-core\revisions\rev_afd26_203df\rev_rev_left_afd26-rev_right_203df\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [441]
Right editions: []
Merged body: 
// START parseResponseHeaders(com.wordnik.swagger.annotations.ResponseHeader[]-com.wordnik.swagger.annotations.ResponseHeader[])//public Map<String, Property> parseResponseHeaders(com.wordnik.swagger.annotations.ResponseHeader[] headers) {
    Map<String,Property> responseHeaders = null;
    if(headers != null && headers.length > 0) {
      for(com.wordnik.swagger.annotations.ResponseHeader header : headers) {
        String name = header.name();
        if(!"".equals(name)) {
          if(responseHeaders == null)
            responseHeaders = new HashMap<String, Property>();
          String description = header.description();
          Class<?> cls = header.response();

          if(!cls.equals(java.lang.Void.class) && !"void".equals(cls.toString())) {
            Property property = ModelConverters.getInstance().readAsProperty(cls);
            if(property != null) {
// LEFT //              Property responseProperty = wrapContainer(header.responseContainer(), property);
              responseProperty.setDescription(description);
              responseHeaders.put(name, responseProperty);
            }
          }
        }
      }
    }
    return responseHeaders;
// END parseResponseHeaders(com.wordnik.swagger.annotations.ResponseHeader[]-com.wordnik.swagger.annotations.ResponseHeader[])//  }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_afd26_203df\rev_rev_left_afd26-rev_right_203df\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [523, 524, 525, 526, 530, 531, 532, 541, 542, 547, 548, 549, 550, 601, 602, 603, 638]
Right editions: []
Merged body: 
// START parseMethod(Method-Method)//public Operation parseMethod(Method method) {
    Operation operation = new Operation();

    ApiOperation apiOperation = (ApiOperation) method.getAnnotation(ApiOperation.class);
    ApiResponses responseAnnotation = method.getAnnotation(ApiResponses.class);

    String operationId = method.getName();
    String responseContainer = null;

    Class<?> responseClass = null;
    Map<String,Property> defaultResponseHeaders = new HashMap<String, Property>();

    if(apiOperation != null) {
      if(apiOperation.hidden())
        return null;
      if(!"".equals(apiOperation.nickname()))
        operationId = method.getName();

      defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());

      operation
        .summary(apiOperation.value())
        .description(apiOperation.notes());

      if(apiOperation.response() != null && !Void.class.equals(apiOperation.response()))
        responseClass = apiOperation.response();
      if(!"".equals(apiOperation.responseContainer()))
        responseContainer = apiOperation.responseContainer();
      if(apiOperation.authorizations()!= null) {
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
        for(Authorization auth : apiOperation.authorizations()) {
          if(auth.value() != null && !"".equals(auth.value())) {
            SecurityRequirement security = new SecurityRequirement();
            security.setName(auth.value());
            AuthorizationScope[] scopes = auth.scopes();
            for(AuthorizationScope scope : scopes) {
              if(scope.scope() != null && !"".equals(scope.scope())) {
                security.addScope(scope.scope());
              }
            }
            securities.add(security);
          }
        }
        if(securities.size() > 0) {
          for(SecurityRequirement sec : securities)
            operation.security(sec);
        }
      }
      if (apiOperation.consumes() != null && !apiOperation.consumes().isEmpty()) {
        operation.consumes(apiOperation.consumes());
      }
      if (apiOperation.produces() != null && !apiOperation.produces().isEmpty()) {
        operation.produces(apiOperation.produces());
      }
    }

    if(responseClass == null) {
      // pick out response from method declaration
      LOGGER.debug("picking up response class from method " + method);
      Type t = method.getGenericReturnType();
      responseClass = method.getReturnType();
      if(!responseClass.equals(java.lang.Void.class) && !"void".equals(responseClass.toString()) && responseClass.getAnnotation(Api.class) == null) {
        LOGGER.debug("reading model " + responseClass);
        Map<String, Model> models = ModelConverters.getInstance().readAll(t);
      }
    }
    if(responseClass != null
      && !responseClass.equals(java.lang.Void.class)
      && !responseClass.equals(javax.ws.rs.core.Response.class)
      && responseClass.getAnnotation(Api.class) == null) {
// LEFT //      int responseCode = 200;
// LEFT //      if (apiOperation != null) {
// LEFT //        responseCode = apiOperation.code();
// LEFT //      }
      if(isPrimitive(responseClass)) {
        Property property = ModelConverters.getInstance().readAsProperty(responseClass);
        if(property != null) {
// LEFT //          Property responseProperty = wrapContainer(responseContainer, property);
// LEFT //          operation.response(responseCode, new Response()
// LEFT //            .description(SUCCESSFUL_OPERATION)
            .schema(responseProperty)
            .headers(defaultResponseHeaders));
        }
      }
      else if(!responseClass.equals(java.lang.Void.class) && !"void".equals(responseClass.toString())) {
        Map<String, Model> models = ModelConverters.getInstance().read(responseClass);
        if(models.size() == 0) {
          Property p = ModelConverters.getInstance().readAsProperty(responseClass);
// LEFT //          operation.response(responseCode, new Response()
// LEFT //            .description(SUCCESSFUL_OPERATION)
            .schema(p)
            .headers(defaultResponseHeaders));
        }
        for(String key: models.keySet()) {
// LEFT //          Property property = new RefProperty().asDefault(key);
// LEFT //          Property responseProperty = wrapContainer(responseContainer, property);
// LEFT //          operation.response(responseCode, new Response()
// LEFT //            .description(SUCCESSFUL_OPERATION)
            .schema(responseProperty)
            .headers(defaultResponseHeaders));
          swagger.model(key, models.get(key));
        }
        models = ModelConverters.getInstance().readAll(responseClass);
        for(String key: models.keySet()) {
          swagger.model(key, models.get(key));
        }
      }
    }

    operation.operationId(operationId);

    Annotation annotation;
    if (apiOperation != null && apiOperation.consumes() != null && apiOperation.consumes().isEmpty()) {
      annotation = method.getAnnotation(Consumes.class);
      if(annotation != null) {
        String[] apiConsumes = ((Consumes)annotation).value();
        for(String mediaType: apiConsumes)
          operation.consumes(mediaType);
      }
    }

    if (apiOperation != null && apiOperation.produces() != null && apiOperation.produces().isEmpty()) {
      annotation = method.getAnnotation(Produces.class);
      if(annotation != null) {
        String[] apiProduces = ((Produces)annotation).value();
        for(String mediaType: apiProduces)
          operation.produces(mediaType);
      }
    }

    List<ApiResponse> apiResponses = new ArrayList<ApiResponse>();
    if(responseAnnotation != null) {
      for(ApiResponse apiResponse: responseAnnotation.value()) {
        Map<String,Property> responseHeaders = parseResponseHeaders(apiResponse.responseHeaders());

        Response response = new Response()
          .description(apiResponse.message())
          .headers(responseHeaders);

        if(apiResponse.code() == 0)
          operation.defaultResponse(response);
        else
          operation.response(apiResponse.code(), response);

        responseClass = apiResponse.response();
        if(responseClass != null && !responseClass.equals(java.lang.Void.class)) {
          Map<String, Model> models = ModelConverters.getInstance().read(responseClass);
          for(String key: models.keySet()) {
// LEFT //            Property property =  new RefProperty().asDefault(key);
// LEFT //            Property responseProperty = wrapContainer(apiResponse.responseContainer(), property);
// LEFT //            response.schema(responseProperty);
            swagger.model(key, models.get(key));
          }
          models = ModelConverters.getInstance().readAll(responseClass);
          for(String key: models.keySet()) {
            swagger.model(key, models.get(key));
          }
        }
      }
    }
    boolean isDeprecated = false;
    annotation = method.getAnnotation(Deprecated.class);
    if(annotation != null)
      isDeprecated = true;

    boolean hidden = false;
    if(apiOperation != null)
      hidden = apiOperation.hidden();

    // process parameters
    Class[] parameterTypes = method.getParameterTypes();
    Type[] genericParameterTypes = method.getGenericParameterTypes();
    Annotation[][] paramAnnotations = method.getParameterAnnotations();
    // paramTypes = method.getParameterTypes
    // genericParamTypes = method.getGenericParameterTypes
    for(int i = 0; i < parameterTypes.length; i++) {
    	Class<?> cls = parameterTypes[i];
      	Type type = genericParameterTypes[i];
    	List<Parameter> parameters = getParameters(cls, type, paramAnnotations[i]);

      for(Parameter parameter : parameters) {
        operation.parameter(parameter);
      }
    }
    if(operation.getResponses() == null) {
// LEFT //      operation.defaultResponse(new Response().description(SUCCESSFUL_OPERATION));
    }
    return operation;
// END parseMethod(Method-Method)//  }
Edition adds call: 0
#HAS_***REFERENCE_#

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_afd26_203df\rev_rev_left_afd26-rev_right_203df\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [523, 524, 525, 526, 530, 531, 532, 541, 542, 547, 548, 549, 550, 601, 602, 603, 638]
Right editions: []
Merged body: 
// START parseMethod(Method-Method)//public Operation parseMethod(Method method) {
    Operation operation = new Operation();

    ApiOperation apiOperation = (ApiOperation) method.getAnnotation(ApiOperation.class);
    ApiResponses responseAnnotation = method.getAnnotation(ApiResponses.class);

    String operationId = method.getName();
    String responseContainer = null;

    Class<?> responseClass = null;
    Map<String,Property> defaultResponseHeaders = new HashMap<String, Property>();

    if(apiOperation != null) {
      if(apiOperation.hidden())
        return null;
      if(!"".equals(apiOperation.nickname()))
        operationId = method.getName();

      defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());

      operation
        .summary(apiOperation.value())
        .description(apiOperation.notes());

      if(apiOperation.response() != null && !Void.class.equals(apiOperation.response()))
        responseClass = apiOperation.response();
      if(!"".equals(apiOperation.responseContainer()))
        responseContainer = apiOperation.responseContainer();
      if(apiOperation.authorizations()!= null) {
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
        for(Authorization auth : apiOperation.authorizations()) {
          if(auth.value() != null && !"".equals(auth.value())) {
            SecurityRequirement security = new SecurityRequirement();
            security.setName(auth.value());
            AuthorizationScope[] scopes = auth.scopes();
            for(AuthorizationScope scope : scopes) {
              if(scope.scope() != null && !"".equals(scope.scope())) {
                security.addScope(scope.scope());
              }
            }
            securities.add(security);
          }
        }
        if(securities.size() > 0) {
          for(SecurityRequirement sec : securities)
            operation.security(sec);
        }
      }
      if (apiOperation.consumes() != null && !apiOperation.consumes().isEmpty()) {
        operation.consumes(apiOperation.consumes());
      }
      if (apiOperation.produces() != null && !apiOperation.produces().isEmpty()) {
        operation.produces(apiOperation.produces());
      }
    }

    if(responseClass == null) {
      // pick out response from method declaration
      LOGGER.debug("picking up response class from method " + method);
      Type t = method.getGenericReturnType();
      responseClass = method.getReturnType();
      if(!responseClass.equals(java.lang.Void.class) && !"void".equals(responseClass.toString()) && responseClass.getAnnotation(Api.class) == null) {
        LOGGER.debug("reading model " + responseClass);
        Map<String, Model> models = ModelConverters.getInstance().readAll(t);
      }
    }
    if(responseClass != null
      && !responseClass.equals(java.lang.Void.class)
      && !responseClass.equals(javax.ws.rs.core.Response.class)
      && responseClass.getAnnotation(Api.class) == null) {
// LEFT //      int responseCode = 200;
// LEFT //      if (apiOperation != null) {
// LEFT //        responseCode = apiOperation.code();
// LEFT //      }
      if(isPrimitive(responseClass)) {
        Property property = ModelConverters.getInstance().readAsProperty(responseClass);
        if(property != null) {
// LEFT //          Property responseProperty = wrapContainer(responseContainer, property);
// LEFT //          operation.response(responseCode, new Response()
// LEFT //            .description(SUCCESSFUL_OPERATION)
            .schema(responseProperty)
            .headers(defaultResponseHeaders));
        }
      }
      else if(!responseClass.equals(java.lang.Void.class) && !"void".equals(responseClass.toString())) {
        Map<String, Model> models = ModelConverters.getInstance().read(responseClass);
        if(models.size() == 0) {
          Property p = ModelConverters.getInstance().readAsProperty(responseClass);
// LEFT //          operation.response(responseCode, new Response()
// LEFT //            .description(SUCCESSFUL_OPERATION)
            .schema(p)
            .headers(defaultResponseHeaders));
        }
        for(String key: models.keySet()) {
// LEFT //          Property property = new RefProperty().asDefault(key);
// LEFT //          Property responseProperty = wrapContainer(responseContainer, property);
// LEFT //          operation.response(responseCode, new Response()
// LEFT //            .description(SUCCESSFUL_OPERATION)
            .schema(responseProperty)
            .headers(defaultResponseHeaders));
          swagger.model(key, models.get(key));
        }
        models = ModelConverters.getInstance().readAll(responseClass);
        for(String key: models.keySet()) {
          swagger.model(key, models.get(key));
        }
      }
    }

    operation.operationId(operationId);

    Annotation annotation;
    if (apiOperation != null && apiOperation.consumes() != null && apiOperation.consumes().isEmpty()) {
      annotation = method.getAnnotation(Consumes.class);
      if(annotation != null) {
        String[] apiConsumes = ((Consumes)annotation).value();
        for(String mediaType: apiConsumes)
          operation.consumes(mediaType);
      }
    }

    if (apiOperation != null && apiOperation.produces() != null && apiOperation.produces().isEmpty()) {
      annotation = method.getAnnotation(Produces.class);
      if(annotation != null) {
        String[] apiProduces = ((Produces)annotation).value();
        for(String mediaType: apiProduces)
          operation.produces(mediaType);
      }
    }

    List<ApiResponse> apiResponses = new ArrayList<ApiResponse>();
    if(responseAnnotation != null) {
      for(ApiResponse apiResponse: responseAnnotation.value()) {
        Map<String,Property> responseHeaders = parseResponseHeaders(apiResponse.responseHeaders());

        Response response = new Response()
          .description(apiResponse.message())
          .headers(responseHeaders);

        if(apiResponse.code() == 0)
          operation.defaultResponse(response);
        else
          operation.response(apiResponse.code(), response);

        responseClass = apiResponse.response();
        if(responseClass != null && !responseClass.equals(java.lang.Void.class)) {
          Map<String, Model> models = ModelConverters.getInstance().read(responseClass);
          for(String key: models.keySet()) {
// LEFT //            Property property =  new RefProperty().asDefault(key);
// LEFT //            Property responseProperty = wrapContainer(apiResponse.responseContainer(), property);
// LEFT //            response.schema(responseProperty);
            swagger.model(key, models.get(key));
          }
          models = ModelConverters.getInstance().readAll(responseClass);
          for(String key: models.keySet()) {
            swagger.model(key, models.get(key));
          }
        }
      }
    }
    boolean isDeprecated = false;
    annotation = method.getAnnotation(Deprecated.class);
    if(annotation != null)
      isDeprecated = true;

    boolean hidden = false;
    if(apiOperation != null)
      hidden = apiOperation.hidden();

    // process parameters
    Class[] parameterTypes = method.getParameterTypes();
    Type[] genericParameterTypes = method.getGenericParameterTypes();
    Annotation[][] paramAnnotations = method.getParameterAnnotations();
    // paramTypes = method.getParameterTypes
    // genericParamTypes = method.getGenericParameterTypes
    for(int i = 0; i < parameterTypes.length; i++) {
    	Class<?> cls = parameterTypes[i];
      	Type type = genericParameterTypes[i];
    	List<Parameter> parameters = getParameters(cls, type, paramAnnotations[i]);

      for(Parameter parameter : parameters) {
        operation.parameter(parameter);
      }
    }
    if(operation.getResponses() == null) {
// LEFT //      operation.defaultResponse(new Response().description(SUCCESSFUL_OPERATION));
    }
    return operation;
// END parseMethod(Method-Method)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f3b17-2dcdd
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_acbb9-e2e45
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f5af3-15020
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5d8ff-4cee5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4bcae-a005a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4b1dd-c6683
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a7c7d-52171
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_a7c7d_52171\rev_rev_left_a7c7d-rev_right_52171\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [199, 240, 241, 242, 243, 248, 249]
Right editions: [321, 322, 323, 325, 326]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
    Api api = (Api) cls.getAnnotation(Api.class);
    Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

    Map<String, Tag> tags = new HashMap<String, Tag>();
    List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
    
    String[] consumes = new String[0];
    String[] produces = new String[0];
    final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

    // only read if allowing hidden apis OR api is not marked as hidden
    final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
    if(readable) {
      // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
      Set<String> tagStrings = extractTags(api);      
      for(String tagString : tagStrings) {
        Tag tag = new Tag().name(tagString);
        tags.put(tagString, tag);
      }
      if(parentTags != null)
        tags.putAll(parentTags);
      for(String tagName: tags.keySet()) {
        swagger.tag(tags.get(tagName));
      }

      if (!api.produces().isEmpty()) {
        produces = new String[]{api.produces()};
      } else if (cls.getAnnotation(Produces.class) != null) {
        produces = ((Produces) cls.getAnnotation(Produces.class)).value();
      }
      if (!api.consumes().isEmpty()){
        consumes = new String[]{api.consumes()};
      } else if (cls.getAnnotation(Consumes.class) != null){
        consumes = ((Consumes)cls.getAnnotation(Consumes.class)).value();
      }
      globalSchemes.addAll(parseSchemes(api.protocols()));
      Authorization[] authorizations = api.authorizations();
      
      for(Authorization auth : authorizations) {
        if(auth.value() != null && !"".equals(auth.value())) {
          SecurityRequirement security = new SecurityRequirement();
          security.setName(auth.value());
          AuthorizationScope[] scopes = auth.scopes();
          for(AuthorizationScope scope : scopes) {
            if(scope.scope() != null && !"".equals(scope.scope())) {
              security.addScope(scope.scope());
            }
          }
          securities.add(security);
        }
      }
    }
    
    // allow reading the JAX-RS APIs without @Api annotation
// LEFT //    if (readable || (api == null && config.isScanAllResources())) {
      // merge consumes, produces

      // look for method-level annotated properties

      // handle sub-resources by looking at return type

      // parse the method
      final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
      Method methods[] = cls.getMethods();
      for(Method method : methods) {
        javax.ws.rs.Path methodPath = method.getAnnotation(javax.ws.rs.Path.class);

        String operationPath = getPath(apiPath, methodPath, parentPath);
        if(operationPath != null) {
          String [] pps = operationPath.split("/");
          String [] pathParts = new String[pps.length];
          Map<String, String> regexMap = new HashMap<String, String>();

          for(int i = 0; i < pps.length; i++) {
            String p = pps[i];
            if(p.startsWith("{")) {
              int pos = p.indexOf(":");
              if(pos > 0) {
                String left = p.substring(1, pos);
                String right = p.substring(pos + 1, p.length()-1);
                pathParts[i] = "{" + left + "}";
                regexMap.put(left, right);
              }
              else
                pathParts[i] = p;
            }
            else pathParts[i] = p;
          }
          StringBuilder pathBuilder = new StringBuilder();
          for(String p : pathParts) {
            if(!p.isEmpty())
              pathBuilder.append("/").append(p);
          }
          operationPath = pathBuilder.toString();

// LEFT //          if (isIgnored(operationPath)) {
// LEFT //            continue;
// LEFT //          }
// LEFT //
          final ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);
          String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

          Operation operation = parseMethod(method);
// LEFT //          if(operation == null) 
// LEFT //            continue;
          if(parentParameters != null) {
            for(Parameter param : parentParameters) {
              operation.parameter(param);
            }
          }
          for(Parameter param : operation.getParameters()) {
            if(regexMap.get(param.getName()) != null) {
              String pattern = regexMap.get(param.getName());
              param.setPattern(pattern);
            }
          }

          if (apiOperation != null) {
            for (Scheme scheme: parseSchemes(apiOperation.protocols())) {
              operation.scheme(scheme);
            }
          }

          if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
            for (Scheme scheme: globalSchemes) {
              operation.scheme(scheme);
            }
          }

          String[] apiConsumes = consumes;
          if(parentConsumes != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
            both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
            if(operation.getConsumes() != null)
              both.addAll(new HashSet<String>(operation.getConsumes()));
            apiConsumes = both.toArray(new String[both.size()]);
          }

          String[] apiProduces = produces;
          if(parentProduces != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
            both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
            if(operation.getProduces() != null)
              both.addAll(new HashSet<String>(operation.getProduces()));
            apiProduces = both.toArray(new String[both.size()]);
          }
          final Class<?> subResource = getSubResource(method);
          if (subResource != null) {
            read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
          }

          // can't continue without a valid http method
          httpMethod = httpMethod == null ? parentMethod : httpMethod;
          if(httpMethod != null) {
            ApiOperation op = (ApiOperation) method.getAnnotation(ApiOperation.class);
            if(op != null) {
              boolean hasExplicitTag = false;
              for(String tag : op.tags()) {
                if(!"".equals(tag)) {
                  operation.tag(tag);
                  swagger.tag(new Tag().name(tag));
                }
              }
            }
            if(operation != null) {
              if(operation.getConsumes() == null)
                for(String mediaType: apiConsumes)
                  operation.consumes(mediaType);
              if(operation.getProduces() == null)
                for(String mediaType: apiProduces)
                  operation.produces(mediaType);

              if(operation.getTags() == null) {
                for(String tagString : tags.keySet())
                  operation.tag(tagString);
              }
// RIGHT //              // Only add global @Api securities if operation doesn't already have more specific securities
// RIGHT //              if (operation.getSecurity() == null) {
// RIGHT //                for(SecurityRequirement security : securities) {
                operation.security(security);
// RIGHT //                }
// RIGHT //              }  

              Path path = swagger.getPath(operationPath);
              if(path == null) {
                path = new Path();
                swagger.path(operationPath, path);
              }
              path.set(httpMethod, operation);
            }
          }
        }
      }
    }
    return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_da48a-b0b15
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_132d9-d1318
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c85de-428b8
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_c85de_428b8\rev_rev_left_c85de-rev_right_428b8\modules\swagger-core\src\main\java\com\wordnik\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [282, 283]
Right editions: [444, 445, 446, 447]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
    final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
    if (type.isEnumType()) {
      // TODO how to handle if model provided is simply an enum
    }

    // Couple of possibilities for defining
    String name = _typeName(type, beanDesc);

    if("Object".equals(name)) {
      return new ModelImpl();
    }
    if(type.isMapLikeType()) {
      return null;
    }

// LEFT //    final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
// LEFT //        .description(_description(beanDesc.getClassInfo()));

    // if XmlRootElement annotation, construct an Xml object and attach it to the model
    XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
    if(rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
      LOGGER.debug(rootAnnotation.toString());
      Xml xml = new Xml()
        .name(rootAnnotation.name());
      if(rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace()))
        xml.namespace(rootAnnotation.namespace());
      model.xml(xml);
    }

    ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
    // TODO
    if (apiModel != null) {
      if(apiModel.value() != null && !"".equals(apiModel.value())) {
        name = apiModel.value();
        model.setName(name);
      }
      Class<?> parent = apiModel.parent();
      if (parent != Void.class) {
        // model.setBaseModel(_typeName(_mapper.constructType(parent)));
      }
    }

    // see if @JsonIgnoreProperties exist
    Set<String> propertiesToIgnore = new HashSet<String>();
    JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
    if(ignoreProperties != null) {
      propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
    }

    String disc = (apiModel == null) ? "" : apiModel.discriminator();
    if (disc.isEmpty()) {
      // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
      JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
      if (typeInfo != null) {
        disc = typeInfo.property();
      }
    }
    if (!disc.isEmpty()) {
      model.setDiscriminator(disc);
    }

    List<Property> props = new ArrayList<Property>();
    for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
      Property property = null;
      String propName = propDef.getName();
      Annotation[] annotations = null;

      // hack to avoid clobbering properties with get/is names
      // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
      if(propDef.getPrimaryMember() != null) {
        java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
        if(member != null) {
          String altName = member.getName();
          if(altName != null) {
            if(altName.startsWith("get")) {
              if(!Character.isUpperCase(altName.charAt(3))) {
                propName = altName;
              }
            }
            else if (altName.startsWith("is")) {
              if(!Character.isUpperCase(altName.charAt(2))) {
                propName = altName;
              }
            }
          }
        }
      }

      PropertyMetadata md = propDef.getMetadata();

      boolean hasSetter = false, hasGetter = false;
      if(propDef.getSetter() == null)
        hasSetter = false;
      else
        hasSetter = true;
      if(propDef.getGetter() != null) {
        JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
        if(pd != null)
          hasGetter = true;
      }
      Boolean isReadOnly = null;
      if(!hasSetter & hasGetter)
        isReadOnly = Boolean.TRUE;
      else
        isReadOnly = Boolean.FALSE;

      final AnnotatedMember member = propDef.getPrimaryMember();

      if(member != null && !propertiesToIgnore.contains(propName)) {
        List<Annotation> annotationList = new ArrayList<Annotation>();
        for(Annotation a : member.annotations())
          annotationList.add(a);

        annotations = annotationList.toArray(new Annotation[annotationList.size()]);

        ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

        JavaType propType = member.getType(beanDesc.bindingsForBeanType());

        // allow override of name from annotation
        if(mp != null && !mp.name().isEmpty())
          propName = mp.name();

        if(mp != null && !mp.dataType().isEmpty()) {
          String or = mp.dataType();

          JavaType innerJavaType = null;
          LOGGER.debug("overriding datatype from " + propType + " to " + or);

          if(or.toLowerCase().startsWith("list[")) {
            String innerType = or.substring(5, or.length() - 1);
            ArrayProperty p = new ArrayProperty();
            Property primitiveProperty = getPrimitiveProperty(innerType);
            if(primitiveProperty != null)
              p.setItems(primitiveProperty);
            else {
              innerJavaType = getInnerType(innerType);
              p.setItems(context.resolveProperty(innerJavaType, annotations));
            }
            property = p;
          }
          else if(or.toLowerCase().startsWith("map[")) {
            int pos = or.indexOf(",");
            if(pos > 0) {
              String innerType = or.substring(pos + 1, or.length() - 1);
              MapProperty p = new MapProperty();
              Property primitiveProperty = getPrimitiveProperty(innerType);
              if(primitiveProperty != null)
                p.setAdditionalProperties(primitiveProperty);
              else {
                innerJavaType = getInnerType(innerType);
                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
              }
              property = p;
            }
          }
          else {
            Property primitiveProperty = getPrimitiveProperty(or);
            if(primitiveProperty != null)
              property = primitiveProperty;
            else {
              innerJavaType = getInnerType(or);
              property = context.resolveProperty(innerJavaType, annotations);
            }
          }
          if(innerJavaType != null) {
            context.resolve(innerJavaType);
          }
        }

        // no property from override, construct from propType
        if(property == null)
          property = context.resolveProperty(propType, annotations);

        if(property != null) {
          property.setName(propName);

// RIGHT //          if (mp != null && !mp.access().isEmpty()) {
// RIGHT //            property.setAccess(mp.access());
// RIGHT //          }
// RIGHT //
          Boolean required = md.getRequired();
          if(required != null)
            property.setRequired(required);

          String description = _intr.findPropertyDescription(member);
          if(description != null && !"".equals(description))
            property.setDescription(description);

          Integer index = _intr.findPropertyIndex(member);
          if (index != null) {
            property.setPosition(index);
          }
          property.setDefault(_findDefaultValue(member));
          property.setExample(_findExampleValue(member));
          property.setReadOnly(_findReadOnly(member));
          
          if(property.getReadOnly() == null) {
            if(isReadOnly)
              property.setReadOnly(isReadOnly);
          }

          if(property instanceof StringProperty) {
            if(mp != null) {
              String allowableValues = mp.allowableValues();
              LOGGER.debug("allowableValues " + allowableValues);
              if(!"".equals(allowableValues)) {
                String[] parts = allowableValues.split(",");
                LOGGER.debug("found " + parts.length + " parts");
                for(String part : parts) {
                  if(property instanceof StringProperty) {
                    StringProperty sp = (StringProperty) property;
                    sp._enum(part.trim());
                    LOGGER.debug("added enum value " + part);
                  }          
                }
              }
            }
          }

          if(property != null) {
            // check for XML annotations
            XmlElementWrapper wrapper = member.getAnnotation(XmlElementWrapper.class);

            if(wrapper != null) {
              Xml xml = new Xml();
              xml.setWrapped(true);

              if(wrapper.name() != null) {
                if("##default".equals(wrapper.name()))
                  xml.setName(propName);
                else if(!"".equals(wrapper.name()))
                  xml.setName(wrapper.name());
              }
              if(wrapper.namespace() != null && !"".equals(wrapper.namespace()) && !"##default".equals(wrapper.namespace()))
                xml.setNamespace(wrapper.namespace());

              property.setXml(xml);
            }

            XmlElement element = member.getAnnotation(XmlElement.class);
            if(element != null) {
              if(!element.name().isEmpty()) {
                // don't set Xml object if name is same
                if(!element.name().equals(propName) && !"##default".equals(element.name())) {
                  Xml xml = property.getXml();
                  if(xml == null) {
                    xml = new Xml();
                    property.setXml(xml);
                  }
                  xml.setName(element.name());
                }
              }
            }
            XmlAttribute attr = member.getAnnotation(XmlAttribute.class);
            if(attr != null) {
              if(!"".equals(attr.name())) {
                // don't set Xml object if name is same
                if(!attr.name().equals(propName) && !"##default".equals(attr.name())) {
                  Xml xml = property.getXml();
                  if(xml == null) {
                    xml = new Xml();
                    property.setXml(xml);
                  }
                  xml.setName(attr.name());
                }
              }
            }
            
          }
          applyBeanValidatorAnnotations(property, annotations);
          props.add(property);
        }
      }
    }

    if (!resolveSubtypes(model, beanDesc, context)) {
      model.setDiscriminator(null);
    }

    Collections.sort(props, getPropertyComparator());

    Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
    for (Property prop : props) {
      modelProps.put(prop.getName(), prop);
    }
    model.setProperties(modelProps);
    return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5e4e1-723da
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c7848-eaf37
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7222e-ee0b6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3cd4c-a084c
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_3cd4c_a084c\rev_rev_left_3cd4c-rev_right_a084c\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [208, 209, 210, 211, 212, 376, 377, 378, 379, 411]
Right editions: [267, 308, 309, 310, 311, 316, 317, 393, 394, 395, 397, 398]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
// LEFT //    SwaggerConfig config = cls.getAnnotation(SwaggerConfig.class);
// LEFT //    if( config != null ){
// LEFT //      readSwaggerConfig( cls, config );
// LEFT //    }
// LEFT //
    Api api = (Api) cls.getAnnotation(Api.class);
    Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

    Map<String, Tag> tags = new HashMap<String, Tag>();
    List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
    
    String[] consumes = new String[0];
    String[] produces = new String[0];
    final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

    // only read if allowing hidden apis OR api is not marked as hidden
    final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
    if(readable) {
      // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
      Set<String> tagStrings = extractTags(api);      
      for(String tagString : tagStrings) {
        Tag tag = new Tag().name(tagString);
        tags.put(tagString, tag);
      }
      if(parentTags != null)
        tags.putAll(parentTags);
      for(String tagName: tags.keySet()) {
        swagger.tag(tags.get(tagName));
      }

      if (!api.produces().isEmpty()) {
        produces = new String[]{api.produces()};
      } else if (cls.getAnnotation(Produces.class) != null) {
        produces = ((Produces) cls.getAnnotation(Produces.class)).value();
      }
      if (!api.consumes().isEmpty()){
        consumes = new String[]{api.consumes()};
      } else if (cls.getAnnotation(Consumes.class) != null){
        consumes = ((Consumes)cls.getAnnotation(Consumes.class)).value();
      }
      globalSchemes.addAll(parseSchemes(api.protocols()));
      Authorization[] authorizations = api.authorizations();
      
      for(Authorization auth : authorizations) {
        if(auth.value() != null && !"".equals(auth.value())) {
          SecurityRequirement security = new SecurityRequirement();
          security.setName(auth.value());
          AuthorizationScope[] scopes = auth.scopes();
          for(AuthorizationScope scope : scopes) {
            if(scope.scope() != null && !"".equals(scope.scope())) {
              security.addScope(scope.scope());
            }
          }
          securities.add(security);
        }
      }
    }
    
    // allow reading the JAX-RS APIs without @Api annotation
// RIGHT //    if (readable || (api == null && config.isScanAllResources())) {
      // merge consumes, produces

      // look for method-level annotated properties

      // handle sub-resources by looking at return type

      // parse the method
      final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
      Method methods[] = cls.getMethods();
      for(Method method : methods) {
        javax.ws.rs.Path methodPath = method.getAnnotation(javax.ws.rs.Path.class);

        String operationPath = getPath(apiPath, methodPath, parentPath);
        if(operationPath != null) {
          String [] pps = operationPath.split("/");
          String [] pathParts = new String[pps.length];
          Map<String, String> regexMap = new HashMap<String, String>();

          for(int i = 0; i < pps.length; i++) {
            String p = pps[i];
            if(p.startsWith("{")) {
              int pos = p.indexOf(":");
              if(pos > 0) {
                String left = p.substring(1, pos);
                String right = p.substring(pos + 1, p.length()-1);
                pathParts[i] = "{" + left + "}";
                regexMap.put(left, right);
              }
              else
                pathParts[i] = p;
            }
            else pathParts[i] = p;
          }
          StringBuilder pathBuilder = new StringBuilder();
          for(String p : pathParts) {
            if(!p.isEmpty())
              pathBuilder.append("/").append(p);
          }
          operationPath = pathBuilder.toString();

// RIGHT //          if (isIgnored(operationPath)) {
// RIGHT //            continue;
// RIGHT //          }
// RIGHT //
          final ApiOperation apiOperation = method.getAnnotation(ApiOperation.class);
          String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

          Operation operation = parseMethod(method);
// RIGHT //          if(operation == null) 
// RIGHT //            continue;
          if(parentParameters != null) {
            for(Parameter param : parentParameters) {
              operation.parameter(param);
            }
          }
          for(Parameter param : operation.getParameters()) {
            if(regexMap.get(param.getName()) != null) {
              String pattern = regexMap.get(param.getName());
              param.setPattern(pattern);
            }
          }

          if (apiOperation != null) {
            for (Scheme scheme: parseSchemes(apiOperation.protocols())) {
              operation.scheme(scheme);
            }
          }

          if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
            for (Scheme scheme: globalSchemes) {
              operation.scheme(scheme);
            }
          }

          String[] apiConsumes = consumes;
          if(parentConsumes != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
            both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
            if(operation.getConsumes() != null)
              both.addAll(new HashSet<String>(operation.getConsumes()));
            apiConsumes = both.toArray(new String[both.size()]);
          }

          String[] apiProduces = produces;
          if(parentProduces != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
            both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
            if(operation.getProduces() != null)
              both.addAll(new HashSet<String>(operation.getProduces()));
            apiProduces = both.toArray(new String[both.size()]);
          }
          final Class<?> subResource = getSubResource(method);
          if (subResource != null) {
            read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
          }

          // can't continue without a valid http method
          httpMethod = httpMethod == null ? parentMethod : httpMethod;
          if(httpMethod != null) {
            ApiOperation op = (ApiOperation) method.getAnnotation(ApiOperation.class);
            if(op != null) {
              boolean hasExplicitTag = false;
              for(String tag : op.tags()) {
                if(!"".equals(tag)) {
                  operation.tag(tag);
                  swagger.tag(new Tag().name(tag));
                }
              }
// LEFT //
// LEFT //              if( operation != null ){
// LEFT //                addExtensionProperties( op.extensions(), operation.getVendorExtensions());
// LEFT //              }
            }
            if(operation != null) {
              if(operation.getConsumes() == null)
                for(String mediaType: apiConsumes)
                  operation.consumes(mediaType);
              if(operation.getProduces() == null)
                for(String mediaType: apiProduces)
                  operation.produces(mediaType);

              if(operation.getTags() == null) {
                for(String tagString : tags.keySet())
                  operation.tag(tagString);
              }
// RIGHT //              // Only add global @Api securities if operation doesn't already have more specific securities
// RIGHT //              if (operation.getSecurity() == null) {
// RIGHT //                for(SecurityRequirement security : securities) {
                operation.security(security);
// RIGHT //                }
// RIGHT //              }  

              Path path = swagger.getPath(operationPath);
              if(path == null) {
                path = new Path();
                swagger.path(operationPath, path);
              }
              path.set(httpMethod, operation);
            }
          }
        }
      }
    }
// LEFT //
    return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6440c-cfe4e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_45f02-acfe8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c497e-a4484
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7a956-fa590
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2d26f-a5ea4
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_2d26f_a5ea4\rev_rev_left_2d26f-rev_right_a5ea4\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [232, 233, 234, 235, 236, 343, 402, 403, 404, 405, 424, 437]
Right editions: [302, 303, 304, 305, 339, 394, 396]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
// LEFT //    SwaggerDefinition swaggerDefinition = cls.getAnnotation(SwaggerDefinition.class);
// LEFT //    if( swaggerDefinition != null ){
// LEFT //      readSwaggerConfig( cls, swaggerDefinition);
// LEFT //    }
// LEFT //
    Api api = (Api) cls.getAnnotation(Api.class);
    Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

    Map<String, Tag> tags = new HashMap<String, Tag>();
    List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
    
    String[] consumes = new String[0];
    String[] produces = new String[0];
    final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

    // only read if allowing hidden apis OR api is not marked as hidden
    final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
    if(readable) {
      // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
      Set<String> tagStrings = extractTags(api);      
      for(String tagString : tagStrings) {
        Tag tag = new Tag().name(tagString);
        tags.put(tagString, tag);
      }
      if(parentTags != null)
        tags.putAll(parentTags);
      for(String tagName: tags.keySet()) {
        swagger.tag(tags.get(tagName));
      }

      if (!api.produces().isEmpty()) {
        produces = new String[]{api.produces()};
      } else if (cls.getAnnotation(Produces.class) != null) {
        produces = ((Produces) cls.getAnnotation(Produces.class)).value();
      }
      if (!api.consumes().isEmpty()){
        consumes = new String[]{api.consumes()};
      } else if (cls.getAnnotation(Consumes.class) != null){
        consumes = ((Consumes)cls.getAnnotation(Consumes.class)).value();
      }
      globalSchemes.addAll(parseSchemes(api.protocols()));
      Authorization[] authorizations = api.authorizations();
      
      for(Authorization auth : authorizations) {
        if(auth.value() != null && !"".equals(auth.value())) {
          SecurityRequirement security = new SecurityRequirement();
          security.setName(auth.value());
          AuthorizationScope[] scopes = auth.scopes();
          for(AuthorizationScope scope : scopes) {
            if(scope.scope() != null && !"".equals(scope.scope())) {
              security.addScope(scope.scope());
            }
          }
          securities.add(security);
        }
      }
    }
    
    // allow reading the JAX-RS APIs without @Api annotation
    if (readable || (api == null && config.isScanAllResources())) {
      // merge consumes, produces

      // look for method-level annotated properties

      // handle sub-resources by looking at return type

      // parse the method
      final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
      Method methods[] = cls.getMethods();
      for(Method method : methods) {
// RIGHT //        if (ReflectionUtils.isOverriddenMethod(method, cls)) {
// RIGHT //          continue;
// RIGHT //        }
// RIGHT //        javax.ws.rs.Path methodPath = getAnnotation(method, javax.ws.rs.Path.class);

        String operationPath = getPath(apiPath, methodPath, parentPath);
        if(operationPath != null) {
          String [] pps = operationPath.split("/");
          String [] pathParts = new String[pps.length];
          Map<String, String> regexMap = new HashMap<String, String>();

          for(int i = 0; i < pps.length; i++) {
            String p = pps[i];
            if(p.startsWith("{")) {
              int pos = p.indexOf(":");
              if(pos > 0) {
                String left = p.substring(1, pos);
                String right = p.substring(pos + 1, p.length()-1);
                pathParts[i] = "{" + left + "}";
                regexMap.put(left, right);
              }
              else
                pathParts[i] = p;
            }
            else pathParts[i] = p;
          }
          StringBuilder pathBuilder = new StringBuilder();
          for(String p : pathParts) {
            if(!p.isEmpty())
              pathBuilder.append("/").append(p);
          }
          operationPath = pathBuilder.toString();

          if (isIgnored(operationPath)) {
            continue;
          }

// RIGHT //          final ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
          String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

          Operation operation = parseMethod(method);
// LEFT //          if(operation == null)
            continue;
          if(parentParameters != null) {
            for(Parameter param : parentParameters) {
              operation.parameter(param);
            }
          }
          for(Parameter param : operation.getParameters()) {
            if(regexMap.get(param.getName()) != null) {
              String pattern = regexMap.get(param.getName());
              param.setPattern(pattern);
            }
          }

          if (apiOperation != null) {
            for (Scheme scheme: parseSchemes(apiOperation.protocols())) {
              operation.scheme(scheme);
            }
          }

          if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
            for (Scheme scheme: globalSchemes) {
              operation.scheme(scheme);
            }
          }

          String[] apiConsumes = consumes;
          if(parentConsumes != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
            both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
            if(operation.getConsumes() != null)
              both.addAll(new HashSet<String>(operation.getConsumes()));
            apiConsumes = both.toArray(new String[both.size()]);
          }

          String[] apiProduces = produces;
          if(parentProduces != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
            both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
            if(operation.getProduces() != null)
              both.addAll(new HashSet<String>(operation.getProduces()));
            apiProduces = both.toArray(new String[both.size()]);
          }
          final Class<?> subResource = getSubResource(method);
          if (subResource != null) {
            read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
          }

          // can't continue without a valid http method
          httpMethod = httpMethod == null ? parentMethod : httpMethod;
          if(httpMethod != null) {
// RIGHT //            if(apiOperation != null) {
              boolean hasExplicitTag = false;
// RIGHT //              for(String tag : apiOperation.tags()) {
                if(!"".equals(tag)) {
                  operation.tag(tag);
                  swagger.tag(new Tag().name(tag));
                }
              }
// LEFT //
// LEFT //              if( operation != null ){
// LEFT //                addExtensionProperties( op.extensions(), operation.getVendorExtensions());
// LEFT //              }
            }
            if(operation != null) {
              if(operation.getConsumes() == null)
                for(String mediaType: apiConsumes)
                  operation.consumes(mediaType);
              if(operation.getProduces() == null)
                for(String mediaType: apiProduces)
                  operation.produces(mediaType);

              if(operation.getTags() == null) {
                for(String tagString : tags.keySet())
                  operation.tag(tagString);
              }
              // Only add global @Api securities if operation doesn't already have more specific securities
              if (operation.getSecurity() == null) {
                for(SecurityRequirement security : securities) {
                  operation.security(security);
                }
// LEFT //              }

              Path path = swagger.getPath(operationPath);
              if(path == null) {
                path = new Path();
                swagger.path(operationPath, path);
              }
              path.set(httpMethod, operation);
            }
          }
        }
      }
    }
// LEFT //
    return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_62f91-a5ea4
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_297dd-66d92
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4cc76-66d92
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_4cc76_66d92\rev_rev_left_4cc76-rev_right_66d92\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [362, 363]
Right editions: [236, 237, 238, 239, 273, 328, 330]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
    Api api = (Api) cls.getAnnotation(Api.class);
    Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

    Map<String, Tag> tags = new HashMap<String, Tag>();
    List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
    
    String[] consumes = new String[0];
    String[] produces = new String[0];
    final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

    // only read if allowing hidden apis OR api is not marked as hidden
    final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
    if(readable) {
      // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
      Set<String> tagStrings = extractTags(api);      
      for(String tagString : tagStrings) {
        Tag tag = new Tag().name(tagString);
        tags.put(tagString, tag);
      }
      if(parentTags != null)
        tags.putAll(parentTags);
      for(String tagName: tags.keySet()) {
        swagger.tag(tags.get(tagName));
      }

      if (!api.produces().isEmpty()) {
        produces = new String[]{api.produces()};
      } else if (cls.getAnnotation(Produces.class) != null) {
        produces = ((Produces) cls.getAnnotation(Produces.class)).value();
      }
      if (!api.consumes().isEmpty()){
        consumes = new String[]{api.consumes()};
      } else if (cls.getAnnotation(Consumes.class) != null){
        consumes = ((Consumes)cls.getAnnotation(Consumes.class)).value();
      }
      globalSchemes.addAll(parseSchemes(api.protocols()));
      Authorization[] authorizations = api.authorizations();
      
      for(Authorization auth : authorizations) {
        if(auth.value() != null && !"".equals(auth.value())) {
          SecurityRequirement security = new SecurityRequirement();
          security.setName(auth.value());
          AuthorizationScope[] scopes = auth.scopes();
          for(AuthorizationScope scope : scopes) {
            if(scope.scope() != null && !"".equals(scope.scope())) {
              security.addScope(scope.scope());
            }
          }
          securities.add(security);
        }
      }
    }
    
    // allow reading the JAX-RS APIs without @Api annotation
    if (readable || (api == null && config.isScanAllResources())) {
      // merge consumes, produces

      // look for method-level annotated properties

      // handle sub-resources by looking at return type

      // parse the method
      final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
      Method methods[] = cls.getMethods();
      for(Method method : methods) {
// RIGHT //        if (ReflectionUtils.isOverriddenMethod(method, cls)) {
// RIGHT //          continue;
// RIGHT //        }
// RIGHT //        javax.ws.rs.Path methodPath = getAnnotation(method, javax.ws.rs.Path.class);

        String operationPath = getPath(apiPath, methodPath, parentPath);
        if(operationPath != null) {
          String [] pps = operationPath.split("/");
          String [] pathParts = new String[pps.length];
          Map<String, String> regexMap = new HashMap<String, String>();

          for(int i = 0; i < pps.length; i++) {
            String p = pps[i];
            if(p.startsWith("{")) {
              int pos = p.indexOf(":");
              if(pos > 0) {
                String left = p.substring(1, pos);
                String right = p.substring(pos + 1, p.length()-1);
                pathParts[i] = "{" + left + "}";
                regexMap.put(left, right);
              }
              else
                pathParts[i] = p;
            }
            else pathParts[i] = p;
          }
          StringBuilder pathBuilder = new StringBuilder();
          for(String p : pathParts) {
            if(!p.isEmpty())
              pathBuilder.append("/").append(p);
          }
          operationPath = pathBuilder.toString();

          if (isIgnored(operationPath)) {
            continue;
          }

// RIGHT //          final ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
          String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

          Operation operation = parseMethod(method);
          if(operation == null) 
            continue;
          if(parentParameters != null) {
            for(Parameter param : parentParameters) {
              operation.parameter(param);
            }
          }
          for(Parameter param : operation.getParameters()) {
            if(regexMap.get(param.getName()) != null) {
              String pattern = regexMap.get(param.getName());
              param.setPattern(pattern);
            }
          }

          if (apiOperation != null) {
            for (Scheme scheme: parseSchemes(apiOperation.protocols())) {
              operation.scheme(scheme);
            }
          }

          if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
            for (Scheme scheme: globalSchemes) {
              operation.scheme(scheme);
            }
          }

          String[] apiConsumes = consumes;
          if(parentConsumes != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
            both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
            if(operation.getConsumes() != null)
              both.addAll(new HashSet<String>(operation.getConsumes()));
            apiConsumes = both.toArray(new String[both.size()]);
          }

          String[] apiProduces = produces;
          if(parentProduces != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
            both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
            if(operation.getProduces() != null)
              both.addAll(new HashSet<String>(operation.getProduces()));
            apiProduces = both.toArray(new String[both.size()]);
          }
          final Class<?> subResource = getSubResource(method);
          if (subResource != null) {
            read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
          }

          // can't continue without a valid http method
          httpMethod = httpMethod == null ? parentMethod : httpMethod;
          if(httpMethod != null) {
// RIGHT //            if(apiOperation != null) {
              boolean hasExplicitTag = false;
// RIGHT //              for(String tag : apiOperation.tags()) {
                if(!"".equals(tag)) {
                  operation.tag(tag);
                  swagger.tag(new Tag().name(tag));
                }
              }
            }
            if(operation != null) {
              if(operation.getConsumes() == null)
                for(String mediaType: apiConsumes)
                  operation.consumes(mediaType);
              if(operation.getProduces() == null)
                for(String mediaType: apiProduces)
                  operation.produces(mediaType);

              if(operation.getTags() == null) {
                for(String tagString : tags.keySet())
                  operation.tag(tagString);
              }
              // Only add global @Api securities if operation doesn't already have more specific securities
              if (operation.getSecurity() == null) {
                for(SecurityRequirement security : securities) {
                  operation.security(security);
                }
              }  

              Path path = swagger.getPath(operationPath);
              if(path == null) {
                path = new Path();
                swagger.path(operationPath, path);
              }
              path.set(httpMethod, operation);
// LEFT //
// LEFT //              readImplicitParameters(method, operation);
            }
          }
        }
      }
    }
    return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_255f9-b44b3
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_255f9_b44b3\rev_rev_left_255f9-rev_right_b44b3\modules\swagger-jaxrs\src\main\java\com\wordnik\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [240, 241, 242, 243, 244, 351, 410, 411, 412, 413, 432, 447]
Right editions: [440, 441]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
// LEFT //    SwaggerDefinition swaggerDefinition = cls.getAnnotation(SwaggerDefinition.class);
// LEFT //    if( swaggerDefinition != null ){
// LEFT //      readSwaggerConfig( cls, swaggerDefinition);
// LEFT //    }
// LEFT //
    Api api = (Api) cls.getAnnotation(Api.class);
    Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

    Map<String, Tag> tags = new HashMap<String, Tag>();
    List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
    
    String[] consumes = new String[0];
    String[] produces = new String[0];
    final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

    // only read if allowing hidden apis OR api is not marked as hidden
    final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
    if(readable) {
      // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
      Set<String> tagStrings = extractTags(api);      
      for(String tagString : tagStrings) {
        Tag tag = new Tag().name(tagString);
        tags.put(tagString, tag);
      }
      if(parentTags != null)
        tags.putAll(parentTags);
      for(String tagName: tags.keySet()) {
        swagger.tag(tags.get(tagName));
      }

      if (!api.produces().isEmpty()) {
        produces = new String[]{api.produces()};
      } else if (cls.getAnnotation(Produces.class) != null) {
        produces = ((Produces) cls.getAnnotation(Produces.class)).value();
      }
      if (!api.consumes().isEmpty()){
        consumes = new String[]{api.consumes()};
      } else if (cls.getAnnotation(Consumes.class) != null){
        consumes = ((Consumes)cls.getAnnotation(Consumes.class)).value();
      }
      globalSchemes.addAll(parseSchemes(api.protocols()));
      Authorization[] authorizations = api.authorizations();
      
      for(Authorization auth : authorizations) {
        if(auth.value() != null && !"".equals(auth.value())) {
          SecurityRequirement security = new SecurityRequirement();
          security.setName(auth.value());
          AuthorizationScope[] scopes = auth.scopes();
          for(AuthorizationScope scope : scopes) {
            if(scope.scope() != null && !"".equals(scope.scope())) {
              security.addScope(scope.scope());
            }
          }
          securities.add(security);
        }
      }
    }
    
    // allow reading the JAX-RS APIs without @Api annotation
    if (readable || (api == null && config.isScanAllResources())) {
      // merge consumes, produces

      // look for method-level annotated properties

      // handle sub-resources by looking at return type

      // parse the method
      final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
      Method methods[] = cls.getMethods();
      for(Method method : methods) {
        if (ReflectionUtils.isOverriddenMethod(method, cls)) {
          continue;
        }
        javax.ws.rs.Path methodPath = getAnnotation(method, javax.ws.rs.Path.class);

        String operationPath = getPath(apiPath, methodPath, parentPath);
        if(operationPath != null) {
          String [] pps = operationPath.split("/");
          String [] pathParts = new String[pps.length];
          Map<String, String> regexMap = new HashMap<String, String>();

          for(int i = 0; i < pps.length; i++) {
            String p = pps[i];
            if(p.startsWith("{")) {
              int pos = p.indexOf(":");
              if(pos > 0) {
                String left = p.substring(1, pos);
                String right = p.substring(pos + 1, p.length()-1);
                pathParts[i] = "{" + left + "}";
                regexMap.put(left, right);
              }
              else
                pathParts[i] = p;
            }
            else pathParts[i] = p;
          }
          StringBuilder pathBuilder = new StringBuilder();
          for(String p : pathParts) {
            if(!p.isEmpty())
              pathBuilder.append("/").append(p);
          }
          operationPath = pathBuilder.toString();

          if (isIgnored(operationPath)) {
            continue;
          }

          final ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
          String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

          Operation operation = parseMethod(method);
// LEFT //          if(operation == null)
            continue;
          if(parentParameters != null) {
            for(Parameter param : parentParameters) {
              operation.parameter(param);
            }
          }
          for(Parameter param : operation.getParameters()) {
            if(regexMap.get(param.getName()) != null) {
              String pattern = regexMap.get(param.getName());
              param.setPattern(pattern);
            }
          }

          if (apiOperation != null) {
            for (Scheme scheme: parseSchemes(apiOperation.protocols())) {
              operation.scheme(scheme);
            }
          }

          if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
            for (Scheme scheme: globalSchemes) {
              operation.scheme(scheme);
            }
          }

          String[] apiConsumes = consumes;
          if(parentConsumes != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
            both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
            if(operation.getConsumes() != null)
              both.addAll(new HashSet<String>(operation.getConsumes()));
            apiConsumes = both.toArray(new String[both.size()]);
          }

          String[] apiProduces = produces;
          if(parentProduces != null) {
            Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
            both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
            if(operation.getProduces() != null)
              both.addAll(new HashSet<String>(operation.getProduces()));
            apiProduces = both.toArray(new String[both.size()]);
          }
          final Class<?> subResource = getSubResource(method);
          if (subResource != null) {
            read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
          }

          // can't continue without a valid http method
          httpMethod = httpMethod == null ? parentMethod : httpMethod;
          if(httpMethod != null) {
            if(apiOperation != null) {
              boolean hasExplicitTag = false;
              for(String tag : apiOperation.tags()) {
                if(!"".equals(tag)) {
                  operation.tag(tag);
                  swagger.tag(new Tag().name(tag));
                }
              }
// LEFT //
// LEFT //              if( operation != null ){
// LEFT //                addExtensionProperties( apiOperation.extensions(), operation.getVendorExtensions());
// LEFT //              }
            }
            if(operation != null) {
              if(operation.getConsumes() == null)
                for(String mediaType: apiConsumes)
                  operation.consumes(mediaType);
              if(operation.getProduces() == null)
                for(String mediaType: apiProduces)
                  operation.produces(mediaType);

              if(operation.getTags() == null) {
                for(String tagString : tags.keySet())
                  operation.tag(tagString);
              }
              // Only add global @Api securities if operation doesn't already have more specific securities
              if (operation.getSecurity() == null) {
                for(SecurityRequirement security : securities) {
                  operation.security(security);
                }
// LEFT //              }

              Path path = swagger.getPath(operationPath);
              if(path == null) {
                path = new Path();
                swagger.path(operationPath, path);
              }
              path.set(httpMethod, operation);
// RIGHT //
// RIGHT //              readImplicitParameters(method, operation);
            }
          }
        }
      }
    }
// LEFT //
    return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//  }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_44205-3b2c4
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fbc78-3b06d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_13e8b-377ad
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_71a04-06cfb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_33f1e-0a966
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8de27-42abc
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_42abc-819bb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7ab94-69409
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_7ab94_69409\rev_rev_left_7ab94-rev_right_69409\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [481]
Right editions: [375]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
        SwaggerDefinition swaggerDefinition = cls.getAnnotation(SwaggerDefinition.class);
        if (swaggerDefinition != null) {
            readSwaggerConfig(cls, swaggerDefinition);
        }

        Api api = (Api) cls.getAnnotation(Api.class);
        Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        // only read if allowing hidden apis OR api is not marked as hidden
        final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
        if (readable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            if (parentTags != null) {
                tags.putAll(parentTags);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
                produces = new String[]{api.produces()};
            } else if (cls.getAnnotation(Produces.class) != null) {
                produces = ((Produces) cls.getAnnotation(Produces.class)).value();
            }
            if (!api.consumes().isEmpty()) {
                consumes = new String[]{api.consumes()};
            } else if (cls.getAnnotation(Consumes.class) != null) {
                consumes = ((Consumes) cls.getAnnotation(Consumes.class)).value();
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));
            Authorization[] authorizations = api.authorizations();

            for (Authorization auth : authorizations) {
                if (auth.value() != null && !"".equals(auth.value())) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    AuthorizationScope[] scopes = auth.scopes();
                    for (AuthorizationScope scope : scopes) {
                        if (scope.scope() != null && !"".equals(scope.scope())) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        // allow reading the JAX-RS APIs without @Api annotation
        if (readable || (api == null && config.isScanAllResources())) {
            // merge consumes, produces

            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            // parse the method
            final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                if (operationPath != null) {
                    String[] pps = operationPath.split("/");
                    String[] pathParts = new String[pps.length];
                    Map<String, String> regexMap = new HashMap<String, String>();

                    for (int i = 0; i < pps.length; i++) {
                        String p = pps[i];
                        if (p.startsWith("{")) {
                            int pos = p.indexOf(":");
                            if (pos > 0) {
                                String left = p.substring(1, pos);
                                String right = p.substring(pos + 1, p.length() - 1);
                                pathParts[i] = "{" + left + "}";
                                regexMap.put(left, right);
                            } else {
                                pathParts[i] = p;
                            }
                        } else {
                            pathParts[i] = p;
                        }
                    }
                    StringBuilder pathBuilder = new StringBuilder();
                    for (String p : pathParts) {
                        if (!p.isEmpty()) {
                            pathBuilder.append("/").append(p);
                        }
                    }
// RIGHT //                    operationPath = pathBuilder.length() > 0 ? pathBuilder.toString() : PATH_DELIMITER;

                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

                    Operation operation = parseMethod(method, collectGlobalParameters(cls));
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new HashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new HashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResource(method);
                    if (subResource != null) {
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
                    }

                    // can't continue without a valid http method
                    httpMethod = httpMethod == null ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            boolean hasExplicitTag = false;
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            if (operation != null) {
                                addExtensionProperties(apiOperation.extensions(), operation.getVendorExtensions());
                            }
                        }
                        if (operation != null) {
                            if (operation.getConsumes() == null) {
                                for (String mediaType : apiConsumes) {
                                    operation.consumes(mediaType);
                                }
                            }
                            if (operation.getProduces() == null) {
                                for (String mediaType : apiProduces) {
                                    operation.produces(mediaType);
                                }
                            }

                            if (operation.getTags() == null) {
                                for (String tagString : tags.keySet()) {
                                    operation.tag(tagString);
                                }
                            }
                            // Only add global @Api securities if operation doesn't already have more specific securities
                            if (operation.getSecurity() == null) {
                                for (SecurityRequirement security : securities) {
                                    operation.security(security);
                                }
                            }

                            Path path = swagger.getPath(operationPath);
                            if (path == null) {
                                path = new Path();
                                swagger.path(operationPath, path);
                            }
// LEFT //                            path.setOrMerge(httpMethod, operation);

                            readImplicitParameters(method, operation);
                        }
                    }
                }
            }
        }

        return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_12b1b-69409
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_69409-3ceac
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b0a95-80f88
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_437ad-aebb8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3eb3e-9ef65
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9ef65-0028c
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_9ef65_0028c\rev_rev_left_9ef65-rev_right_0028c\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [253, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274]
Right editions: [481]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || _typeNameResolver.isStdType(type)) {
            // We don't build models for primitive types
            return null;
        }
// LEFT //
        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

// LEFT //        if(!type.isContainerType()) {
// LEFT //            // define the model here to support self/cyclic referencing of models
// LEFT //            context.defineModel(name, model, type, null);
// LEFT //        }
// LEFT //
// LEFT //        if (type.isContainerType()) {
// LEFT //            // We treat collections as primitive types, just need to add models for values (if any)
// LEFT //            context.resolve(type.getContentType());
// LEFT //            return null;
// LEFT //        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        if (altName.startsWith("get")) {
                            if (!Character.isUpperCase(altName.charAt(3))) {
                                propName = altName;
                            }
                        } else if (altName.startsWith("is")) {
                            if (!Character.isUpperCase(altName.charAt(2))) {
                                propName = altName;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
            if (propDef.getSetter() == null) {
                hasSetter = false;
            } else {
                hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();

            if (member != null && !propertiesToIgnore.contains(propName)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = getPrimitiveProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = getPrimitiveProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = getPrimitiveProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else {
                        property = context.resolveProperty(propType, annotations);
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }

                    if (property instanceof StringProperty) {
                        if (mp != null) {
                            String allowableValues = mp.allowableValues();
                            LOGGER.debug("allowableValues " + allowableValues);
                            if (!"".equals(allowableValues)) {
                                String[] parts = allowableValues.split(",");
                                LOGGER.debug("found " + parts.length + " parts");
                                for (String part : parts) {
                                    if (property instanceof StringProperty) {
                                        StringProperty sp = (StringProperty) property;
                                        sp._enum(part.trim());
                                        LOGGER.debug("added enum value " + part);
                                    }
                                }
                            }
                        }
                    }

// RIGHT //                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);
        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_af5f3-6a928
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4e125-da6ee
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_4e125_da6ee\rev_rev_left_4e125-rev_right_da6ee\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\ParameterProcessor.java
Different Spacing: false
Left editions: [143, 146, 150, 151, 152, 153, 154]
Right editions: [75, 76, 77]
Merged body: 
// START applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//public static Parameter applyAnnotations(Swagger swagger, Parameter parameter, Type type, List<Annotation> annotations) {
        final AnnotationsHelper helper = new AnnotationsHelper(annotations);
        if (helper.isContext()) {
            return null;
        }
        final ParamWrapper<?> param = helper.getApiParam();
// RIGHT //        if (param.isHidden()) {
// RIGHT //            return null;
// RIGHT //        }
        final String defaultValue = helper.getDefaultValue();
        final JavaType javaType = TypeFactory.defaultInstance().constructType(type);
        if (parameter instanceof AbstractSerializableParameter) {
            final AbstractSerializableParameter<?> p = (AbstractSerializableParameter<?>) parameter;

            if (param.isRequired()) {
                p.setRequired(true);
            }
            if (StringUtils.isNotEmpty(param.getName())) {
                p.setName(param.getName());
            }
            if (StringUtils.isNotEmpty(param.getDescription())) {
                p.setDescription(param.getDescription());
            }
            if (StringUtils.isNotEmpty(param.getAccess())) {
                p.setAccess(param.getAccess());
            }
            if (StringUtils.isNotEmpty(param.getDataType())) {
                p.setType(param.getDataType());
            }

            AllowableValues allowableValues = null;
            if (StringUtils.isNotEmpty(param.getAllowableValues())) {
                allowableValues = AllowableRangeValues.create(param.getAllowableValues());
                if (allowableValues == null) {
                    allowableValues = AllowableEnumValues.create(param.getAllowableValues());
                }
            }

            if (p.getItems() != null || param.isAllowMultiple()) {
                if (p.getItems() == null) {
                    // Convert to array
                    final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                    args.put(PropertyBuilder.PropertyId.DEFAULT, p.getDefaultValue());
                    p.setDefaultValue(null);
                    args.put(PropertyBuilder.PropertyId.ENUM, p.getEnum());
                    p.setEnum(null);
                    args.put(PropertyBuilder.PropertyId.MINIMUM, p.getMinimum());
                    p.setMinimum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, p.isExclusiveMinimum());
                    p.setExclusiveMinimum(null);
                    args.put(PropertyBuilder.PropertyId.MAXIMUM, p.getMaximum());
                    p.setMaximum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, p.isExclusiveMaximum());
                    p.setExclusiveMaximum(null);
                    Property items = PropertyBuilder.build(p.getType(), p.getFormat(), args);
                    p.type(ArrayProperty.TYPE).format(null).items(items);
                }

                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
                processAllowedValues(allowableValues, true, args);
                PropertyBuilder.merge(p.getItems(), args);
                p.collectionFormat("csv");
            } else {
                if (StringUtils.isNotEmpty(defaultValue)) {
                    p.setDefaultValue(defaultValue);
                }
                processAllowedValues(allowableValues, false, p);
            }
        } else {
            // must be a body param
            BodyParameter bp = new BodyParameter();
// LEFT //
            bp.setRequired(param.isRequired());
            bp.setName(StringUtils.isNotEmpty(param.getName()) ? param.getName() : "body");
// LEFT //
            if (StringUtils.isNotEmpty(param.getDescription())) {
                bp.setDescription(param.getDescription());
            }
// LEFT //
// LEFT //            if (StringUtils.isNotEmpty(param.getAccess())) {
// LEFT //                bp.setAccess(param.getAccess());
// LEFT //            }
// LEFT //
            final Property property = ModelConverters.getInstance().readAsProperty(javaType);
            if (property != null) {
                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
                bp.setSchema(PropertyBuilder.toModel(PropertyBuilder.merge(property, args)));
                for (Map.Entry<String, Model> entry : ModelConverters.getInstance().readAll(javaType).entrySet()) {
                    swagger.addDefinition(entry.getKey(), entry.getValue());
                }
            }
            parameter = bp;
        }
        return parameter;
// END applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9d7c2-c4e00
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_eb610-c4e00
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_359c5-1ddf1
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_dacf8-88495
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_88495-994e5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f96ae-df7c8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1ac40-c0a4e
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_1ac40_c0a4e\rev_rev_left_1ac40-rev_right_c0a4e\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [256, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 484]
Right editions: [328, 329, 330, 331, 332, 334]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || _typeNameResolver.isStdType(type)) {
            // We don't build models for primitive types
            return null;
        }
// LEFT //
        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

// LEFT //        if(!type.isContainerType()) {
// LEFT //            // define the model here to support self/cyclic referencing of models
// LEFT //            context.defineModel(name, model, type, null);
// LEFT //        }
// LEFT //
// LEFT //        if (type.isContainerType()) {
// LEFT //            // We treat collections as primitive types, just need to add models for values (if any)
// LEFT //            context.resolve(type.getContentType());
// LEFT //            return null;
// LEFT //        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
// RIGHT //                        final int length = altName.length();
// RIGHT //                        for (String prefix : Arrays.asList("get", "is")) {
// RIGHT //                            final int offset = prefix.length();
// RIGHT //                            if (altName.startsWith(prefix) && length > offset
// RIGHT //                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
// RIGHT //                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
            if (propDef.getSetter() == null) {
                hasSetter = false;
            } else {
                hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();

            if (member != null && !propertiesToIgnore.contains(propName)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = getPrimitiveProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = getPrimitiveProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = getPrimitiveProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else {
                        property = context.resolveProperty(propType, annotations);
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }

                    if (property instanceof StringProperty) {
                        if (mp != null) {
                            String allowableValues = mp.allowableValues();
                            LOGGER.debug("allowableValues " + allowableValues);
                            if (!"".equals(allowableValues)) {
                                String[] parts = allowableValues.split(",");
                                LOGGER.debug("found " + parts.length + " parts");
                                for (String part : parts) {
                                    if (property instanceof StringProperty) {
                                        StringProperty sp = (StringProperty) property;
                                        sp._enum(part.trim());
                                        LOGGER.debug("added enum value " + part);
                                    }
                                }
                            }
                        }
                    }

// LEFT //                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);
        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b11d8-0e6d8
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_b11d8_0e6d8\rev_rev_left_b11d8-rev_right_0e6d8\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\ParameterProcessor.java
Different Spacing: false
Left editions: [75, 76, 77, 142, 145, 149, 150, 151, 152, 153]
Right editions: []
Merged body: 
// START applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//public static Parameter applyAnnotations(Swagger swagger, Parameter parameter, Type type, List<Annotation> annotations) {
        final AnnotationsHelper helper = new AnnotationsHelper(annotations);
        if (helper.isContext()) {
            return null;
        }
        final ParamWrapper<?> param = helper.getApiParam();
// LEFT //        if (param.isHidden()) {
// LEFT //            return null;
// LEFT //        }
        final String defaultValue = helper.getDefaultValue();
        final JavaType javaType = TypeFactory.defaultInstance().constructType(type);
        if (parameter instanceof AbstractSerializableParameter) {
            final AbstractSerializableParameter<?> p = (AbstractSerializableParameter<?>) parameter;

            if (param.isRequired()) {
                p.setRequired(true);
            }
            if (StringUtils.isNotEmpty(param.getName())) {
                p.setName(param.getName());
            }
            if (StringUtils.isNotEmpty(param.getDescription())) {
                p.setDescription(param.getDescription());
            }
            if (StringUtils.isNotEmpty(param.getAccess())) {
                p.setAccess(param.getAccess());
            }
            if (StringUtils.isNotEmpty(param.getDataType())) {
                p.setType(param.getDataType());
            }

            AllowableValues allowableValues = null;
            if (StringUtils.isNotEmpty(param.getAllowableValues())) {
                allowableValues = AllowableRangeValues.create(param.getAllowableValues());
                if (allowableValues == null) {
                    allowableValues = AllowableEnumValues.create(param.getAllowableValues());
                }
            }

            if (p.getItems() != null || param.isAllowMultiple()) {
                if (p.getItems() == null) {
                    // Convert to array
                    final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                    args.put(PropertyBuilder.PropertyId.DEFAULT, p.getDefaultValue());
                    p.setDefaultValue(null);
                    args.put(PropertyBuilder.PropertyId.ENUM, p.getEnum());
                    p.setEnum(null);
                    args.put(PropertyBuilder.PropertyId.MINIMUM, p.getMinimum());
                    p.setMinimum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, p.isExclusiveMinimum());
                    p.setExclusiveMinimum(null);
                    args.put(PropertyBuilder.PropertyId.MAXIMUM, p.getMaximum());
                    p.setMaximum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, p.isExclusiveMaximum());
                    p.setExclusiveMaximum(null);
                    Property items = PropertyBuilder.build(p.getType(), p.getFormat(), args);
                    p.type(ArrayProperty.TYPE).format(null).items(items);
                }

                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
                processAllowedValues(allowableValues, true, args);
                PropertyBuilder.merge(p.getItems(), args);
            } else {
                if (StringUtils.isNotEmpty(defaultValue)) {
                    p.setDefaultValue(defaultValue);
                }
                processAllowedValues(allowableValues, false, p);
            }
        } else {
            // must be a body param
            BodyParameter bp = new BodyParameter();
// LEFT //
            bp.setRequired(param.isRequired());
            bp.setName(StringUtils.isNotEmpty(param.getName()) ? param.getName() : "body");
// LEFT //
            if (StringUtils.isNotEmpty(param.getDescription())) {
                bp.setDescription(param.getDescription());
            }
// LEFT //
// LEFT //            if (StringUtils.isNotEmpty(param.getAccess())) {
// LEFT //                bp.setAccess(param.getAccess());
// LEFT //            }
// LEFT //
            final Property property = ModelConverters.getInstance().readAsProperty(javaType);
            if (property != null) {
                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
                bp.setSchema(PropertyBuilder.toModel(PropertyBuilder.merge(property, args)));
                for (Map.Entry<String, Model> entry : ModelConverters.getInstance().readAll(javaType).entrySet()) {
                    swagger.addDefinition(entry.getKey(), entry.getValue());
                }
            }
            parameter = bp;
        }
        return parameter;
// END applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8a10e-f382a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_95182-5829d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d1cb7-38673
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_d1cb7_38673\rev_rev_left_d1cb7-rev_right_38673\modules\swagger-core\src\main\java\io\swagger\core\filter\SpecFilter.java
Different Spacing: false
Left editions: [57]
Right editions: [37, 45, 46, 62, 65, 66, 67, 68, 69, 70, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89]
Merged body: 
// START filter(Swagger-Swagger-SwaggerSpecFilter-SwaggerSpecFilter-Map<String,List<String>>-Map<String,List<String>>-Map<String,String>-Map<String,String>-Map<String,List<String>>-Map<String,List<String>>)//public Swagger filter(Swagger swagger, SwaggerSpecFilter filter, Map<String, List<String>> params, Map<String, String> cookies, Map<String, List<String>> headers) {
        Swagger clone = new Swagger();
        clone.info(swagger.getInfo())
// RIGHT //                .tags(swagger.getTags() == null ? null : new ArrayList<Tag>(swagger.getTags()))
                .host(swagger.getHost())
                .basePath(swagger.getBasePath())
                .schemes(swagger.getSchemes())
                .consumes(swagger.getConsumes())
                .produces(swagger.getProduces())
                .externalDocs(swagger.getExternalDocs());

// RIGHT //        final Set<String> filteredTags = new HashSet<String>();
// RIGHT //        final Set<String> allowedTags = new HashSet<String>();
        for (String resourcePath : swagger.getPaths().keySet()) {
            Path path = swagger.getPaths().get(resourcePath);
            Map<String, Operation> ops = new HashMap<String, Operation>();
            ops.put("get", path.getGet());
            ops.put("put", path.getPut());
            ops.put("post", path.getPost());
            ops.put("delete", path.getDelete());
            ops.put("patch", path.getPatch());
            ops.put("options", path.getOptions());

// LEFT //            Path clonedPath = new PathImpl();
            for (String key : ops.keySet()) {
                Operation op = ops.get(key);
                if (op != null) {
                    ApiDescription desc = new ApiDescription(resourcePath, key);
// RIGHT //                    final Set<String> tags;
                    if (filter.isOperationAllowed(op, desc, params, cookies, headers)) {
                        clonedPath.set(key, filterOperation(filter, op, desc, params, cookies, headers));
// RIGHT //                        tags = allowedTags;
// RIGHT //                    } else {
// RIGHT //                        tags = filteredTags;
// RIGHT //                    }
// RIGHT //                    if (op.getTags() != null) {
// RIGHT //                        tags.addAll(op.getTags());
                    }
                }
            }
            if (!clonedPath.isEmpty()) {
                clone.path(resourcePath, clonedPath);
            }
        }
// RIGHT //        final List<Tag> tags = clone.getTags();
// RIGHT //        filteredTags.removeAll(allowedTags);
// RIGHT //        if (tags != null && !filteredTags.isEmpty()) {
// RIGHT //            for (Iterator<Tag> it = tags.iterator(); it.hasNext(); ) {
// RIGHT //                if (filteredTags.contains(it.next().getName())) {
// RIGHT //                    it.remove();
// RIGHT //                }
// RIGHT //            }
// RIGHT //            if (clone.getTags().isEmpty()) {
// RIGHT //                clone.setTags(null);
// RIGHT //            }
// RIGHT //        }

        Map<String, Model> definitions = filterDefinitions(filter, swagger.getDefinitions(), params, cookies, headers);
        clone.setSecurityDefinitions(swagger.getSecurityDefinitions());
        clone.setDefinitions(definitions);
        return clone;
// END filter(Swagger-Swagger-SwaggerSpecFilter-SwaggerSpecFilter-Map<String,List<String>>-Map<String,List<String>>-Map<String,String>-Map<String,String>-Map<String,List<String>>-Map<String,List<String>>)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_d1cb7_38673\rev_rev_left_d1cb7-rev_right_38673\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [467]
Right editions: [319, 320, 321, 322, 323, 324, 325, 326, 373]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//protected Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters) {
        Api api = (Api) cls.getAnnotation(Api.class);
        Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        // only read if allowing hidden apis OR api is not marked as hidden
        final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
        if (readable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            if (parentTags != null) {
                tags.putAll(parentTags);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
                produces = new String[]{api.produces()};
            } else if (cls.getAnnotation(Produces.class) != null) {
                produces = ((Produces) cls.getAnnotation(Produces.class)).value();
            }
            if (!api.consumes().isEmpty()) {
                consumes = new String[]{api.consumes()};
            } else if (cls.getAnnotation(Consumes.class) != null) {
                consumes = ((Consumes) cls.getAnnotation(Consumes.class)).value();
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));
            Authorization[] authorizations = api.authorizations();

            for (Authorization auth : authorizations) {
                if (auth.value() != null && !"".equals(auth.value())) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    AuthorizationScope[] scopes = auth.scopes();
                    for (AuthorizationScope scope : scopes) {
                        if (scope.scope() != null && !"".equals(scope.scope())) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        // allow reading the JAX-RS APIs without @Api annotation
        if (readable || (api == null && config.isScanAllResources())) {
            // merge consumes, produces

            // look for method-level annotated properties

            // handle sub-resources by looking at return type

// RIGHT //            final List<Parameter> globalParameters = new ArrayList<Parameter>();
// RIGHT //
// RIGHT //            // look for constructor-level annotated properties
// RIGHT //            globalParameters.addAll(ReaderUtils.collectConstructorParameters(cls, swagger));
// RIGHT //
// RIGHT //            // look for field-level annotated properties
// RIGHT //            globalParameters.addAll(ReaderUtils.collectFieldParameters(cls, swagger));
// RIGHT //
            // parse the method
            final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                if (operationPath != null) {
                    String[] pps = operationPath.split("/");
                    String[] pathParts = new String[pps.length];
                    Map<String, String> regexMap = new HashMap<String, String>();

                    for (int i = 0; i < pps.length; i++) {
                        String p = pps[i];
                        if (p.startsWith("{")) {
                            int pos = p.indexOf(":");
                            if (pos > 0) {
                                String left = p.substring(1, pos);
                                String right = p.substring(pos + 1, p.length() - 1);
                                pathParts[i] = "{" + left + "}";
                                regexMap.put(left, right);
                            } else {
                                pathParts[i] = p;
                            }
                        } else {
                            pathParts[i] = p;
                        }
                    }
                    StringBuilder pathBuilder = new StringBuilder();
                    for (String p : pathParts) {
                        if (!p.isEmpty()) {
                            pathBuilder.append("/").append(p);
                        }
                    }
                    operationPath = pathBuilder.length() > 0 ? pathBuilder.toString() : PATH_DELIMITER;

                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

// RIGHT //                    Operation operation = parseMethod(method, globalParameters);
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new HashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new HashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResource(method);
                    if (subResource != null) {
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());
                    }

                    // can't continue without a valid http method
                    httpMethod = httpMethod == null ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            boolean hasExplicitTag = false;
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            if (operation != null) {
                                addExtensionProperties(apiOperation.extensions(), operation.getVendorExtensions());
                            }
                        }
                        if (operation != null) {
                            if (operation.getConsumes() == null) {
                                for (String mediaType : apiConsumes) {
                                    operation.consumes(mediaType);
                                }
                            }
                            if (operation.getProduces() == null) {
                                for (String mediaType : apiProduces) {
                                    operation.produces(mediaType);
                                }
                            }

                            if (operation.getTags() == null) {
                                for (String tagString : tags.keySet()) {
                                    operation.tag(tagString);
                                }
                            }
                            // Only add global @Api securities if operation doesn't already have more specific securities
                            if (operation.getSecurity() == null) {
                                for (SecurityRequirement security : securities) {
                                    operation.security(security);
                                }
                            }

                            Path path = swagger.getPath(operationPath);
                            if (path == null) {
// LEFT //                                path = new PathImpl();
                                swagger.path(operationPath, path);
                            }
                            path.set(httpMethod, operation);

                            readImplicitParameters(method, operation);
                        }
                    }
                }
            }
        }

        return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>)//    }

#CP_===_CP#
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_d1cb7_38673\rev_rev_left_d1cb7-rev_right_38673\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [874, 887, 921, 964]
Right editions: [943]
Merged body: 
// START parseMethod(Method-Method-List<Parameter>-List<Parameter>)//private Operation parseMethod(Method method, List<Parameter> globalParameters) {
        Operation operation = new Operation();

        ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);
        ApiResponses responseAnnotation = getAnnotation(method, ApiResponses.class);

        String operationId = method.getName();
        String responseContainer = null;

        Type responseType = null;
        Map<String, Property> defaultResponseHeaders = new HashMap<String, Property>();

        if (apiOperation != null) {
            if (apiOperation.hidden()) {
                return null;
            }
            if (!"".equals(apiOperation.nickname())) {
                operationId = method.getName();
            }

            defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());

            operation
                    .summary(apiOperation.value())
                    .description(apiOperation.notes());

            if (apiOperation.response() != null && !isVoid(apiOperation.response())) {
                responseType = apiOperation.response();
            }
            if (!"".equals(apiOperation.responseContainer())) {
                responseContainer = apiOperation.responseContainer();
            }
            if (apiOperation.authorizations() != null) {
                List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
                for (Authorization auth : apiOperation.authorizations()) {
                    if (auth.value() != null && !"".equals(auth.value())) {
                        SecurityRequirement security = new SecurityRequirement();
                        security.setName(auth.value());
                        AuthorizationScope[] scopes = auth.scopes();
                        for (AuthorizationScope scope : scopes) {
                            if (scope.scope() != null && !"".equals(scope.scope())) {
                                security.addScope(scope.scope());
                            }
                        }
                        securities.add(security);
                    }
                }
                if (securities.size() > 0) {
                    for (SecurityRequirement sec : securities) {
                        operation.security(sec);
                    }
                }
            }
            if (apiOperation.consumes() != null && !apiOperation.consumes().isEmpty()) {
                operation.consumes(apiOperation.consumes());
            }
            if (apiOperation.produces() != null && !apiOperation.produces().isEmpty()) {
                operation.produces(apiOperation.produces());
            }
        }

        if (apiOperation != null && StringUtils.isNotEmpty(apiOperation.responseReference())) {
// LEFT //            Response response = new ResponseImpl().description(SUCCESSFUL_OPERATION);
            response.schema(new RefProperty(apiOperation.responseReference()));
            operation.addResponse(String.valueOf(apiOperation.code()), response);
        } else if (responseType == null) {
            // pick out response from method declaration
            LOGGER.debug("picking up response class from method " + method);
            responseType = method.getGenericReturnType();
        }
        if (isValidResponse(responseType)) {
            final Property property = ModelConverters.getInstance().readAsProperty(responseType);
            if (property != null) {
                final Property responseProperty = ContainerWrapper.wrapContainer(responseContainer, property);
                final int responseCode = apiOperation == null ? 200 : apiOperation.code();
// LEFT //                operation.response(responseCode, new ResponseImpl().description(SUCCESSFUL_OPERATION).schema(responseProperty)
                        .headers(defaultResponseHeaders));
                appendModels(responseType);
            }
        }

        operation.operationId(operationId);

        Annotation annotation;
        if (apiOperation != null && apiOperation.consumes() != null && apiOperation.consumes().isEmpty()) {
            annotation = getAnnotation(method, Consumes.class);
            if (annotation != null) {
                String[] apiConsumes = ((Consumes) annotation).value();
                for (String mediaType : apiConsumes) {
                    operation.consumes(mediaType);
                }
            }
        }

        if (apiOperation != null && apiOperation.produces() != null && apiOperation.produces().isEmpty()) {
            annotation = getAnnotation(method, Produces.class);
            if (annotation != null) {
                String[] apiProduces = ((Produces) annotation).value();
                for (String mediaType : apiProduces) {
                    operation.produces(mediaType);
                }
            }
        }

        List<ApiResponse> apiResponses = new ArrayList<ApiResponse>();
        if (responseAnnotation != null) {
            for (ApiResponse apiResponse : responseAnnotation.value()) {
                Map<String, Property> responseHeaders = parseResponseHeaders(apiResponse.responseHeaders());

// LEFT //                Response response = new ResponseImpl()
                        .description(apiResponse.message())
                        .headers(responseHeaders);

                if (apiResponse.code() == 0) {
                    operation.defaultResponse(response);
                } else {
                    operation.response(apiResponse.code(), response);
                }

                if (StringUtils.isNotEmpty(apiResponse.reference())) {
                    response.schema(new RefProperty(apiResponse.reference()));
                } else if (!isVoid(apiResponse.response())) {
                    responseType = apiResponse.response();
                    final Property property = ModelConverters.getInstance().readAsProperty(responseType);
                    if (property != null) {
                        response.schema(ContainerWrapper.wrapContainer(apiResponse.responseContainer(), property));
                        appendModels(responseType);
                    }
                }
            }
        }
// RIGHT //        if (getAnnotation(method, Deprecated.class) != null) {
            operation.setDeprecated(true);
        }

        // process parameters
        for (Parameter globalParameter : globalParameters) {
            operation.parameter(globalParameter);
        }

        Type[] genericParameterTypes = method.getGenericParameterTypes();
        Annotation[][] paramAnnotations = method.getParameterAnnotations();
        for (int i = 0; i < genericParameterTypes.length; i++) {
            Type type = genericParameterTypes[i];
            List<Parameter> parameters = getParameters(type, Arrays.asList(paramAnnotations[i]));

            for (Parameter parameter : parameters) {
                operation.parameter(parameter);
            }
        }

        if (operation.getResponses() == null) {
// LEFT //            Response response = new ResponseImpl().description(SUCCESSFUL_OPERATION);
            operation.defaultResponse(response);
        }
        return operation;
// END parseMethod(Method-Method-List<Parameter>-List<Parameter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_38673-6d5ac
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c35a0-32f73
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_13f39-1edfb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_29bba-efb2c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ef712-10b59
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_acf99-e47fb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4a467-c16f4
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1e6e9-d9583
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_47535-5a3f6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8481b-81383
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7155d-3c00d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fe71f-cea99
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_efca8-679f3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_805b1-b431e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fdf13-f25e7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e2422-afdc0
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_e2422_afdc0\rev_rev_left_e2422-rev_right_afdc0\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [249, 387, 400, 410]
Right editions: [463, 464, 465, 466]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
// LEFT //        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            // We don't build models for primitive types
            return null;
        }

        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

        if(!type.isContainerType()) {
            // define the model here to support self/cyclic referencing of models
            context.defineModel(name, model, type, null);
        }

        if (type.isContainerType()) {
            // We treat collections as primitive types, just need to add models for values (if any)
            context.resolve(type.getContentType());
            return null;
        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        final int length = altName.length();
                        for (String prefix : Arrays.asList("get", "is")) {
                            final int offset = prefix.length();
                            if (altName.startsWith(prefix) && length > offset
                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
            if (propDef.getSetter() == null) {
                hasSetter = false;
            } else {
                hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();

            if (member != null && !propertiesToIgnore.contains(propName)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
// LEFT //                        Property primitiveProperty = PrimitiveType.createProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
// LEFT //                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
// LEFT //                        Property primitiveProperty = PrimitiveType.createProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else {
                        property = context.resolveProperty(propType, annotations);
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }
                        if (mp != null) {
// RIGHT //                        final AllowableValues allowableValues = AllowableValuesUtils.create(mp.allowableValues());
// RIGHT //                        if (allowableValues != null) {
// RIGHT //                            final Map<PropertyBuilder.PropertyId, Object> args = allowableValues.asPropertyArguments();
// RIGHT //                            PropertyBuilder.merge(property, args);
                            }
                        }
                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);
        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_69dbf-e253a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_164db-166c0
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7b369-7ecec
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2338e-a2a9a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e8848-b3d67
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_23625-53437
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_36a5d-0553c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e67e1-9f3d5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2e30c-142fe
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_90405-7e915
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_90405_7e915\rev_rev_left_90405-rev_right_7e915\modules\swagger-models\src\main\java\io\swagger\models\Path.java
Different Spacing: false
Left editions: [287]
Right editions: [292]
Merged body: 
// START hashCode({FormalParametersInternal})//// LEFT //public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((delete == null) ? 0 : delete.hashCode());
        result = prime * result + ((get == null) ? 0 : get.hashCode());
// RIGHT //        result = prime * result + ((head == null) ? 0 : head.hashCode());
        result = prime * result + ((options == null) ? 0 : options.hashCode());
        result = prime * result
                + ((parameters == null) ? 0 : parameters.hashCode());
        result = prime * result + ((patch == null) ? 0 : patch.hashCode());
        result = prime * result + ((post == null) ? 0 : post.hashCode());
        result = prime * result + ((put == null) ? 0 : put.hashCode());
        result = prime * result
                + ((vendorExtensions == null) ? 0 : vendorExtensions.hashCode());
        return result;
// END hashCode({FormalParametersInternal})//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b4fbe-253bd
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_b4fbe_253bd\rev_rev_left_b4fbe-rev_right_253bd\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\ParameterProcessor.java
Different Spacing: false
Left editions: [73, 74, 75, 97, 123, 124, 125, 131, 136, 139, 143, 144, 145, 146, 147]
Right editions: [69]
Merged body: 
// START applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//public static Parameter applyAnnotations(Swagger swagger, Parameter parameter, Type type, List<Annotation> annotations) {
        final AnnotationsHelper helper = new AnnotationsHelper(annotations);
// RIGHT //        if (helper.isContext() && parameter.getVendorExtensions().isEmpty()) {
            return null;
        }
        final ParamWrapper<?> param = helper.getApiParam();
// LEFT //        if (param.isHidden()) {
// LEFT //            return null;
// LEFT //        }
        final String defaultValue = helper.getDefaultValue();
        final JavaType javaType = TypeFactory.defaultInstance().constructType(type);
        if (parameter instanceof AbstractSerializableParameter) {
            final AbstractSerializableParameter<?> p = (AbstractSerializableParameter<?>) parameter;

            if (param.isRequired()) {
                p.setRequired(true);
            }
            if (StringUtils.isNotEmpty(param.getName())) {
                p.setName(param.getName());
            }
            if (StringUtils.isNotEmpty(param.getDescription())) {
                p.setDescription(param.getDescription());
            }
            if (StringUtils.isNotEmpty(param.getAccess())) {
                p.setAccess(param.getAccess());
            }
            if (StringUtils.isNotEmpty(param.getDataType())) {
                p.setType(param.getDataType());
            }

// LEFT //            AllowableValues allowableValues = AllowableValuesUtils.create(param.getAllowableValues());

            if (p.getItems() != null || param.isAllowMultiple()) {
                if (p.getItems() == null) {
                    // Convert to array
                    final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                    args.put(PropertyBuilder.PropertyId.DEFAULT, p.getDefaultValue());
                    p.setDefaultValue(null);
                    args.put(PropertyBuilder.PropertyId.ENUM, p.getEnum());
                    p.setEnum(null);
                    args.put(PropertyBuilder.PropertyId.MINIMUM, p.getMinimum());
                    p.setMinimum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, p.isExclusiveMinimum());
                    p.setExclusiveMinimum(null);
                    args.put(PropertyBuilder.PropertyId.MAXIMUM, p.getMaximum());
                    p.setMaximum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, p.isExclusiveMaximum());
                    p.setExclusiveMaximum(null);
                    Property items = PropertyBuilder.build(p.getType(), p.getFormat(), args);
                    p.type(ArrayProperty.TYPE).format(null).items(items);
                }

                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
// LEFT //                if (allowableValues != null) {
// LEFT //                    args.putAll(allowableValues.asPropertyArguments());
// LEFT //                }
                PropertyBuilder.merge(p.getItems(), args);
            } else {
                if (StringUtils.isNotEmpty(defaultValue)) {
                    p.setDefaultValue(defaultValue);
                }
// LEFT //                processAllowedValues(allowableValues, p);
            }
        } else {
            // must be a body param
            BodyParameter bp = new BodyParameter();
// LEFT //
            bp.setRequired(param.isRequired());
            bp.setName(StringUtils.isNotEmpty(param.getName()) ? param.getName() : "body");
// LEFT //
            if (StringUtils.isNotEmpty(param.getDescription())) {
                bp.setDescription(param.getDescription());
            }
// LEFT //
// LEFT //            if (StringUtils.isNotEmpty(param.getAccess())) {
// LEFT //                bp.setAccess(param.getAccess());
// LEFT //            }
// LEFT //
            final Property property = ModelConverters.getInstance().readAsProperty(javaType);
            if (property != null) {
                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
                bp.setSchema(PropertyBuilder.toModel(PropertyBuilder.merge(property, args)));
                for (Map.Entry<String, Model> entry : ModelConverters.getInstance().readAll(javaType).entrySet()) {
                    swagger.addDefinition(entry.getKey(), entry.getValue());
                }
            }
            parameter = bp;
        }
        return parameter;
// END applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_91593-24c41
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9eb55-d174a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fe2f4-033d5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1b637-89a93
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_15e4d-e5594
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5928a-22782
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a3c2f-1f47f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fa093-62678
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5a287-087d5
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fc66d-ec8e4
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_fc66d_ec8e4\rev_rev_left_fc66d-rev_right_ec8e4\modules\swagger-core\src\main\java\io\swagger\util\PropertyDeserializer.java
Different Spacing: false
Left editions: [123]
Right editions: [137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147]
Merged body: 
// START propertyFromNode(JsonNode-JsonNode)//Property propertyFromNode(JsonNode node) {
        final String type = getString(node, PropertyBuilder.PropertyId.TYPE);
        final String format = getString(node, PropertyBuilder.PropertyId.FORMAT);
        final String description = getString(node, PropertyBuilder.PropertyId.DESCRIPTION);
// LEFT //        final Xml xml = getXml(node);

        JsonNode detailNode = node.get("$ref");
        if (detailNode != null) {
            return new RefProperty(detailNode.asText()).description(description);
        }

        if (ObjectProperty.isType(type)) {
            detailNode = node.get("additionalProperties");
            if (detailNode != null) {
                Property items = propertyFromNode(detailNode);
                if (items != null) {
                    return new MapProperty(items).description(description);
                }
// RIGHT //            } else {
// RIGHT //              detailNode = node.get("properties");
// RIGHT //              Map<String, Property> properties = new HashMap<String, Property>();
// RIGHT //              if(detailNode != null){
// RIGHT //                  for(Iterator<Map.Entry<String,JsonNode>> iter = detailNode.fields(); iter.hasNext();){
// RIGHT //                      Map.Entry<String,JsonNode> field = iter.next();
// RIGHT //                      Property property = propertyFromNode(field.getValue());
// RIGHT //                      properties.put(field.getKey(), property);
// RIGHT //                  }
// RIGHT //              }
// RIGHT //              return new ObjectProperty(properties);
            }
        }
        if (ArrayProperty.isType(type)) {
            detailNode = node.get("items");
            if (detailNode != null) {
                Property subProperty = propertyFromNode(detailNode);
                return new ArrayProperty().items(subProperty).description(description);
            }
        }

        final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
        args.put(PropertyBuilder.PropertyId.TYPE, type);
        args.put(PropertyBuilder.PropertyId.FORMAT, format);
        args.put(PropertyBuilder.PropertyId.DESCRIPTION, description);
        args.put(PropertyBuilder.PropertyId.EXAMPLE, getString(node, PropertyBuilder.PropertyId.EXAMPLE));
        args.put(PropertyBuilder.PropertyId.ENUM, getEnum(node, PropertyBuilder.PropertyId.ENUM));
        args.put(PropertyBuilder.PropertyId.TITLE, getString(node, PropertyBuilder.PropertyId.TITLE));
        args.put(PropertyBuilder.PropertyId.DEFAULT, getString(node, PropertyBuilder.PropertyId.DEFAULT));
        args.put(PropertyBuilder.PropertyId.PATTERN, getString(node, PropertyBuilder.PropertyId.PATTERN));
        args.put(PropertyBuilder.PropertyId.DESCRIMINATOR, getString(node, PropertyBuilder.PropertyId.DESCRIMINATOR));
        args.put(PropertyBuilder.PropertyId.MIN_ITEMS, getInteger(node, PropertyBuilder.PropertyId.MIN_ITEMS));
        args.put(PropertyBuilder.PropertyId.MAX_ITEMS, getInteger(node, PropertyBuilder.PropertyId.MAX_ITEMS));
        args.put(PropertyBuilder.PropertyId.MIN_PROPERTIES, getInteger(node, PropertyBuilder.PropertyId.MIN_PROPERTIES));
        args.put(PropertyBuilder.PropertyId.MAX_PROPERTIES, getInteger(node, PropertyBuilder.PropertyId.MAX_PROPERTIES));
        args.put(PropertyBuilder.PropertyId.MIN_LENGTH, getInteger(node, PropertyBuilder.PropertyId.MIN_LENGTH));
        args.put(PropertyBuilder.PropertyId.MAX_LENGTH, getInteger(node, PropertyBuilder.PropertyId.MAX_LENGTH));
        args.put(PropertyBuilder.PropertyId.MINIMUM, getDouble(node, PropertyBuilder.PropertyId.MINIMUM));
        args.put(PropertyBuilder.PropertyId.MAXIMUM, getDouble(node, PropertyBuilder.PropertyId.MAXIMUM));
        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, getBoolean(node, PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM));
        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, getBoolean(node, PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM));
        args.put(PropertyBuilder.PropertyId.UNIQUE_ITEMS, getBoolean(node, PropertyBuilder.PropertyId.UNIQUE_ITEMS));

        Property output = PropertyBuilder.build(type, format, args);
        if (output == null) {
            LOGGER.warn("no property from " + type + ", " + format + ", " + args);
            return null;
        }
        output.setDescription(description);
        return output;
// END propertyFromNode(JsonNode-JsonNode)//    }
Has references on the following methods: 
#HAS_***REFERENCE_#
Type: EditDiffMC
File: C:\download\ssmerge\swagger-core\revisions\rev_fc66d_ec8e4\rev_rev_left_fc66d-rev_right_ec8e4\modules\swagger-core\src\main\java\io\swagger\util\PropertyDeserializer.java
Different Spacing: false
Left editions: [113, 114, 115]
Right editions: []
Merged body: 
// START deserialize(JsonParser-JsonParser-DeserializationContext-DeserializationContext)//@Override
    public Property deserialize(JsonParser jp, DeserializationContext ctxt)
            throws IOException, JsonProcessingException {
        JsonNode node = jp.getCodec().readTree(jp);
// LEFT //        Property property = propertyFromNode(node);
// LEFT //        property.setXml(getXml(node));
// LEFT //        return property;
// END deserialize(JsonParser-JsonParser-DeserializationContext-DeserializationContext)//    }
Edition adds call: 1
#HAS_***REFERENCE_#

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0d7cc-cd458
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_477ea-8bd31
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4a588-eebd2
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e199b-cc4e4
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_e199b_cc4e4\rev_rev_left_e199b-rev_right_cc4e4\modules\swagger-models\src\main\java\io\swagger\models\properties\PropertyBuilder.java
Different Spacing: false
Left editions: [797, 798, 799, 800]
Right editions: [777, 778, 779]
Merged body: 
// START merge(Property-Property-Map<PropertyId,Object>-Map<PropertyId,Object>)//public Property merge(Property property, Map<PropertyId, Object> args) {
// RIGHT //            if(args.containsKey(PropertyId.READ_ONLY)) {
// RIGHT //                property.setReadOnly(PropertyId.READ_ONLY.<Boolean>findValue(args));
// RIGHT //            }
            if (property instanceof AbstractProperty) {
                final AbstractProperty resolved = (AbstractProperty) property;
                if (resolved.getFormat() == null) {
                    resolved.setFormat(PropertyId.FORMAT.<String>findValue(args));
                }
                if (args.containsKey(PropertyId.TITLE)) {
                    final String value = PropertyId.TITLE.findValue(args);
                    resolved.setTitle(value);
                }
                if (args.containsKey(PropertyId.DESCRIPTION)) {
                    final String value = PropertyId.DESCRIPTION.findValue(args);
                    resolved.setDescription(value);
                }
                if (args.containsKey(PropertyId.EXAMPLE)) {
                    final String value = PropertyId.EXAMPLE.findValue(args);
                    resolved.setExample(value);
                }
// LEFT //                if(args.containsKey(PropertyId.VENDOR_EXTENSIONS)) {
// LEFT //                    final Map<String, Object> value = PropertyId.VENDOR_EXTENSIONS.findValue(args);
// LEFT //                    resolved.setVendorExtensionMap(value);
// LEFT //                }
            }
            return property;
// END merge(Property-Property-Map<PropertyId,Object>-Map<PropertyId,Object>)//        }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_90ba7-12288
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e688d-2a936
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8ef72-82d30
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_35379-4e702
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8e9ec-92ef7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3fba6-2773d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2c855-ceda3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d5ab2-8b4ed
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_535d2-13d2f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b05f3-5bd87
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_21211-4851d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ade30-5cb81
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5c2f6-8404f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ba0ec-818d2
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ef66a-14e7f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b8269-41cee
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_88725-bc1ec
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ee9f2-6714f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0d59e-6c0ac
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_0d59e_6c0ac\rev_rev_left_0d59e-rev_right_6c0ac\modules\swagger-core\src\main\java\io\swagger\util\PropertyDeserializer.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START propertyFromNode(JsonNode-JsonNode)//Property propertyFromNode(JsonNode node) {
        final String type = getString(node, PropertyBuilder.PropertyId.TYPE);
        final String format = getString(node, PropertyBuilder.PropertyId.FORMAT);
        final String description = getString(node, PropertyBuilder.PropertyId.DESCRIPTION);
        final Xml xml = getXml(node);

        JsonNode detailNode = node.get("$ref");
        if (detailNode != null) {
            return new RefProperty(detailNode.asText()).description(description);
        }

        if (ObjectProperty.isType(type)) {
            detailNode = node.get("additionalProperties");
            if (detailNode != null) {
                Property items = propertyFromNode(detailNode);
                if (items != null) {
                    return new MapProperty(items).description(description);
                }
            } else {
              detailNode = node.get("properties");
              Map<String, Property> properties = new HashMap<String, Property>();
              if(detailNode != null){
                  for(Iterator<Map.Entry<String,JsonNode>> iter = detailNode.fields(); iter.hasNext();){
                      Map.Entry<String,JsonNode> field = iter.next();
                      Property property = propertyFromNode(field.getValue());
                      properties.put(field.getKey(), property);
                  }
              }
              return new ObjectProperty(properties);
            }
        }
        if (ArrayProperty.isType(type)) {
            detailNode = node.get("items");
            if (detailNode != null) {
                Property subProperty = propertyFromNode(detailNode);
                ArrayProperty arrayProperty = new ArrayProperty().items(subProperty).description(description);
                arrayProperty.setVendorExtensionMap(getVendorExtensions(node));
                return arrayProperty;
            }
        }

        final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
        args.put(PropertyBuilder.PropertyId.TYPE, type);
        args.put(PropertyBuilder.PropertyId.FORMAT, format);
        args.put(PropertyBuilder.PropertyId.DESCRIPTION, description);
        args.put(PropertyBuilder.PropertyId.EXAMPLE, getString(node, PropertyBuilder.PropertyId.EXAMPLE));
        args.put(PropertyBuilder.PropertyId.ENUM, getEnum(node, PropertyBuilder.PropertyId.ENUM));
        args.put(PropertyBuilder.PropertyId.TITLE, getString(node, PropertyBuilder.PropertyId.TITLE));
        args.put(PropertyBuilder.PropertyId.DEFAULT, getString(node, PropertyBuilder.PropertyId.DEFAULT));
        args.put(PropertyBuilder.PropertyId.PATTERN, getString(node, PropertyBuilder.PropertyId.PATTERN));
        args.put(PropertyBuilder.PropertyId.DESCRIMINATOR, getString(node, PropertyBuilder.PropertyId.DESCRIMINATOR));
        args.put(PropertyBuilder.PropertyId.MIN_ITEMS, getInteger(node, PropertyBuilder.PropertyId.MIN_ITEMS));
        args.put(PropertyBuilder.PropertyId.MAX_ITEMS, getInteger(node, PropertyBuilder.PropertyId.MAX_ITEMS));
        args.put(PropertyBuilder.PropertyId.MIN_PROPERTIES, getInteger(node, PropertyBuilder.PropertyId.MIN_PROPERTIES));
        args.put(PropertyBuilder.PropertyId.MAX_PROPERTIES, getInteger(node, PropertyBuilder.PropertyId.MAX_PROPERTIES));
        args.put(PropertyBuilder.PropertyId.MIN_LENGTH, getInteger(node, PropertyBuilder.PropertyId.MIN_LENGTH));
        args.put(PropertyBuilder.PropertyId.MAX_LENGTH, getInteger(node, PropertyBuilder.PropertyId.MAX_LENGTH));
        args.put(PropertyBuilder.PropertyId.MINIMUM, getDouble(node, PropertyBuilder.PropertyId.MINIMUM));
        args.put(PropertyBuilder.PropertyId.MAXIMUM, getDouble(node, PropertyBuilder.PropertyId.MAXIMUM));
        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, getBoolean(node, PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM));
        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, getBoolean(node, PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM));
        args.put(PropertyBuilder.PropertyId.UNIQUE_ITEMS, getBoolean(node, PropertyBuilder.PropertyId.UNIQUE_ITEMS));
        args.put(PropertyBuilder.PropertyId.READ_ONLY, getBoolean(node, PropertyBuilder.PropertyId.READ_ONLY));
        args.put(PropertyBuilder.PropertyId.VENDOR_EXTENSIONS, getVendorExtensions(node));

        Property output = PropertyBuilder.build(type, format, args);
        if (output == null) {
            LOGGER.warn("no property from " + type + ", " + format + ", " + args);
            return null;
        }
        output.setDescription(description);
        return output;
// END propertyFromNode(JsonNode-JsonNode)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_72b58-0567e
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_72b58_0567e\rev_rev_left_72b58-rev_right_0567e\modules\swagger-core\src\main\java\io\swagger\util\PropertyDeserializer.java
Different Spacing: false
Left editions: [209, 210, 211, 223, 224, 225, 232, 233, 234, 267]
Right editions: []
Merged body: 
// START propertyFromNode(JsonNode-JsonNode)//Property propertyFromNode(JsonNode node) {
        final String type = getString(node, PropertyBuilder.PropertyId.TYPE);
        final String format = getString(node, PropertyBuilder.PropertyId.FORMAT);
        final String description = getString(node, PropertyBuilder.PropertyId.DESCRIPTION);
        final Xml xml = getXml(node);

        JsonNode detailNode = node.get("$ref");
        if (detailNode != null) {
            return new RefProperty(detailNode.asText()).description(description);
        }

        if (ObjectProperty.isType(type)) {
            detailNode = node.get("additionalProperties");
            if (detailNode != null) {
                Property items = propertyFromNode(detailNode);
                if (items != null) {
// LEFT //                    MapProperty mapProperty = new MapProperty(items).description(description);
// LEFT //                    mapProperty.setVendorExtensionMap(getVendorExtensions(node));
// LEFT //                    return mapProperty;
                }
            } else {
              detailNode = node.get("properties");
              Map<String, Property> properties = new HashMap<String, Property>();
              if(detailNode != null){
                  for(Iterator<Map.Entry<String,JsonNode>> iter = detailNode.fields(); iter.hasNext();){
                      Map.Entry<String,JsonNode> field = iter.next();
                      Property property = propertyFromNode(field.getValue());
                      properties.put(field.getKey(), property);
                  }
              }
// LEFT //                ObjectProperty objectProperty = new ObjectProperty(properties);
// LEFT //                objectProperty.setVendorExtensionMap(getVendorExtensions(node));
// LEFT //                return objectProperty;
            }
        }
        if (ArrayProperty.isType(type)) {
            detailNode = node.get("items");
            if (detailNode != null) {
                Property subProperty = propertyFromNode(detailNode);
// LEFT //                ArrayProperty arrayProperty = new ArrayProperty().items(subProperty).description(description);
// LEFT //                arrayProperty.setVendorExtensionMap(getVendorExtensions(node));
// LEFT //                return arrayProperty;
            }
        }

        final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
        args.put(PropertyBuilder.PropertyId.TYPE, type);
        args.put(PropertyBuilder.PropertyId.FORMAT, format);
        args.put(PropertyBuilder.PropertyId.DESCRIPTION, description);
        args.put(PropertyBuilder.PropertyId.EXAMPLE, getString(node, PropertyBuilder.PropertyId.EXAMPLE));
        args.put(PropertyBuilder.PropertyId.ENUM, getEnum(node, PropertyBuilder.PropertyId.ENUM));
        args.put(PropertyBuilder.PropertyId.TITLE, getString(node, PropertyBuilder.PropertyId.TITLE));
        args.put(PropertyBuilder.PropertyId.DEFAULT, getString(node, PropertyBuilder.PropertyId.DEFAULT));
        args.put(PropertyBuilder.PropertyId.PATTERN, getString(node, PropertyBuilder.PropertyId.PATTERN));
        args.put(PropertyBuilder.PropertyId.DESCRIMINATOR, getString(node, PropertyBuilder.PropertyId.DESCRIMINATOR));
        args.put(PropertyBuilder.PropertyId.MIN_ITEMS, getInteger(node, PropertyBuilder.PropertyId.MIN_ITEMS));
        args.put(PropertyBuilder.PropertyId.MAX_ITEMS, getInteger(node, PropertyBuilder.PropertyId.MAX_ITEMS));
        args.put(PropertyBuilder.PropertyId.MIN_PROPERTIES, getInteger(node, PropertyBuilder.PropertyId.MIN_PROPERTIES));
        args.put(PropertyBuilder.PropertyId.MAX_PROPERTIES, getInteger(node, PropertyBuilder.PropertyId.MAX_PROPERTIES));
        args.put(PropertyBuilder.PropertyId.MIN_LENGTH, getInteger(node, PropertyBuilder.PropertyId.MIN_LENGTH));
        args.put(PropertyBuilder.PropertyId.MAX_LENGTH, getInteger(node, PropertyBuilder.PropertyId.MAX_LENGTH));
        args.put(PropertyBuilder.PropertyId.MINIMUM, getDouble(node, PropertyBuilder.PropertyId.MINIMUM));
        args.put(PropertyBuilder.PropertyId.MAXIMUM, getDouble(node, PropertyBuilder.PropertyId.MAXIMUM));
        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, getBoolean(node, PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM));
        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, getBoolean(node, PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM));
        args.put(PropertyBuilder.PropertyId.UNIQUE_ITEMS, getBoolean(node, PropertyBuilder.PropertyId.UNIQUE_ITEMS));
        args.put(PropertyBuilder.PropertyId.READ_ONLY, getBoolean(node, PropertyBuilder.PropertyId.READ_ONLY));
        args.put(PropertyBuilder.PropertyId.VENDOR_EXTENSIONS, getVendorExtensions(node));
        Property output = PropertyBuilder.build(type, format, args);
        if (output == null) {
            LOGGER.warn("no property from " + type + ", " + format + ", " + args);
            return null;
        }
        output.setDescription(description);
// LEFT //        
        return output;
// END propertyFromNode(JsonNode-JsonNode)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2360a-19f81
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0d8ae-1e294
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c15a6-3afa0
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2713b-e7260
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6423d-4a62d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_500c7-efd7e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b5768-2506a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ed60d-0d6c9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_40ba4-798eb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9ccad-6761d
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_9ccad_6761d\rev_rev_left_9ccad-rev_right_6761d\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [297, 302, 359]
Right editions: [339]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//private Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters, Set<Class<?>> scannedResources) {
        Api api = (Api) cls.getAnnotation(Api.class);
        Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        // only read if allowing hidden apis OR api is not marked as hidden
        final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
        if (readable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            if (parentTags != null) {
                tags.putAll(parentTags);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
                produces = new String[]{api.produces()};
            } else if (cls.getAnnotation(Produces.class) != null) {
// LEFT //                produces = ReaderUtils.splitContentValues(cls.getAnnotation(Produces.class).value());
            }
            if (!api.consumes().isEmpty()) {
                consumes = new String[]{api.consumes()};
            } else if (cls.getAnnotation(Consumes.class) != null) {
// LEFT //                consumes = ReaderUtils.splitContentValues(cls.getAnnotation(Consumes.class).value());
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));
            Authorization[] authorizations = api.authorizations();

            for (Authorization auth : authorizations) {
                if (auth.value() != null && !"".equals(auth.value())) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    AuthorizationScope[] scopes = auth.scopes();
                    for (AuthorizationScope scope : scopes) {
                        if (scope.scope() != null && !"".equals(scope.scope())) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        // allow reading the JAX-RS APIs without @Api annotation
        if (readable || (api == null && config.isScanAllResources())) {
            // merge consumes, produces

            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            final List<Parameter> globalParameters = new ArrayList<Parameter>();

            // look for constructor-level annotated properties
            globalParameters.addAll(ReaderUtils.collectConstructorParameters(cls, swagger));

            // look for field-level annotated properties
            globalParameters.addAll(ReaderUtils.collectFieldParameters(cls, swagger));

            // parse the method
// RIGHT //            final javax.ws.rs.Path apiPath = ReflectionUtils.getAnnotation(cls, javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = ReflectionUtils.getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                Map<String, String> regexMap = new HashMap<String, String>();
                operationPath = PathUtils.parsePath(operationPath, regexMap);
                if (operationPath != null) {
                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = ReflectionUtils.getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

                    Operation operation = null;
// LEFT //                    if(apiOperation != null || config.isScanAllResources() || httpMethod != null || methodPath != null) {
                        operation = parseMethod(cls, method, globalParameters);
                    }
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new HashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new HashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResource(method);
                    if (subResource != null && !scannedResources.contains(subResource)) {
                        scannedResources.add(subResource);
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters(), scannedResources);
                    }

                    // can't continue without a valid http method
                    httpMethod = httpMethod == null ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            boolean hasExplicitTag = false;
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            if (operation != null) {
                                addExtensionProperties(apiOperation.extensions(), operation.getVendorExtensions());
                            }
                        }
                        if (operation != null) {
                            if (operation.getConsumes() == null) {
                                for (String mediaType : apiConsumes) {
                                    operation.consumes(mediaType);
                                }
                            }
                            if (operation.getProduces() == null) {
                                for (String mediaType : apiProduces) {
                                    operation.produces(mediaType);
                                }
                            }

                            if (operation.getTags() == null) {
                                for (String tagString : tags.keySet()) {
                                    operation.tag(tagString);
                                }
                            }
                            // Only add global @Api securities if operation doesn't already have more specific securities
                            if (operation.getSecurity() == null) {
                                for (SecurityRequirement security : securities) {
                                    operation.security(security);
                                }
                            }

                            Path path = swagger.getPath(operationPath);
                            if (path == null) {
                                path = new Path();
                                swagger.path(operationPath, path);
                            }
                            path.set(httpMethod, operation);

                            readImplicitParameters(method, operation);
                        }
                    }
                }
            }
        }

        return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f6542-0ffb0
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_646d3-be46b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_69b95-c322b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ddd3a-dc70b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_68903-91a4d
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_68903_91a4d\rev_rev_left_68903-rev_right_91a4d\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [899, 900, 901, 908, 909, 910]
Right editions: [832]
Merged body: 
// START parseMethod(Class<?>-Class<?>-Method-Method-List<Parameter>-List<Parameter>)//private Operation parseMethod(Class<?> cls, Method method, List<Parameter> globalParameters) {
        Operation operation = new Operation();

        ApiOperation apiOperation = ReflectionUtils.getAnnotation(method, ApiOperation.class);
        ApiResponses responseAnnotation = ReflectionUtils.getAnnotation(method, ApiResponses.class);

        String operationId = method.getName();
        String responseContainer = null;

        Type responseType = null;
        Map<String, Property> defaultResponseHeaders = new HashMap<String, Property>();

        if (apiOperation != null) {
            if (apiOperation.hidden()) {
                return null;
            }
            if (!"".equals(apiOperation.nickname())) {
// RIGHT //                operationId = apiOperation.nickname();
            }

            defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());

            operation
                    .summary(apiOperation.value())
                    .description(apiOperation.notes());

            if (apiOperation.response() != null && !isVoid(apiOperation.response())) {
                responseType = apiOperation.response();
            }
            if (!"".equals(apiOperation.responseContainer())) {
                responseContainer = apiOperation.responseContainer();
            }
            if (apiOperation.authorizations() != null) {
                List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
                for (Authorization auth : apiOperation.authorizations()) {
                    if (auth.value() != null && !"".equals(auth.value())) {
                        SecurityRequirement security = new SecurityRequirement();
                        security.setName(auth.value());
                        AuthorizationScope[] scopes = auth.scopes();
                        for (AuthorizationScope scope : scopes) {
                            if (scope.scope() != null && !"".equals(scope.scope())) {
                                security.addScope(scope.scope());
                            }
                        }
                        securities.add(security);
                    }
                }
                if (securities.size() > 0) {
                    for (SecurityRequirement sec : securities) {
                        operation.security(sec);
                    }
                }
            }
            if (apiOperation.consumes() != null && !apiOperation.consumes().isEmpty()) {
                operation.consumes(apiOperation.consumes());
            }
            if (apiOperation.produces() != null && !apiOperation.produces().isEmpty()) {
                operation.produces(apiOperation.produces());
            }
        }

        if (apiOperation != null && StringUtils.isNotEmpty(apiOperation.responseReference())) {
            Response response = new Response().description(SUCCESSFUL_OPERATION);
            response.schema(new RefProperty(apiOperation.responseReference()));
            operation.addResponse(String.valueOf(apiOperation.code()), response);
        } else if (responseType == null) {
            // pick out response from method declaration
            LOGGER.debug("picking up response class from method " + method);
            responseType = method.getGenericReturnType();
        }
        if (isValidResponse(responseType)) {
            final Property property = ModelConverters.getInstance().readAsProperty(responseType);
            if (property != null) {
                final Property responseProperty = ContainerWrapper.wrapContainer(responseContainer, property);
                final int responseCode = apiOperation == null ? 200 : apiOperation.code();
                operation.response(responseCode, new Response().description(SUCCESSFUL_OPERATION).schema(responseProperty)
                        .headers(defaultResponseHeaders));
                appendModels(responseType);
            }
        }

        operation.operationId(operationId);

        if (apiOperation != null && apiOperation.consumes() != null && apiOperation.consumes().isEmpty()) {
// LEFT //            final Consumes consumes = ReflectionUtils.getAnnotation(method, Consumes.class);
// LEFT //            if (consumes != null) {
// LEFT //                for (String mediaType : ReaderUtils.splitContentValues(consumes.value())) {
                    operation.consumes(mediaType);
                }
            }
        }

        if (apiOperation != null && apiOperation.produces() != null && apiOperation.produces().isEmpty()) {
// LEFT //            final Produces produces = ReflectionUtils.getAnnotation(method, Produces.class);
// LEFT //            if (produces != null) {
// LEFT //                for (String mediaType : ReaderUtils.splitContentValues(produces.value())) {
                    operation.produces(mediaType);
                }
            }
        }

        List<ApiResponse> apiResponses = new ArrayList<ApiResponse>();
        if (responseAnnotation != null) {
            for (ApiResponse apiResponse : responseAnnotation.value()) {
                Map<String, Property> responseHeaders = parseResponseHeaders(apiResponse.responseHeaders());

                Response response = new Response()
                        .description(apiResponse.message())
                        .headers(responseHeaders);

                if (apiResponse.code() == 0) {
                    operation.defaultResponse(response);
                } else {
                    operation.response(apiResponse.code(), response);
                }

                if (StringUtils.isNotEmpty(apiResponse.reference())) {
                    response.schema(new RefProperty(apiResponse.reference()));
                } else if (!isVoid(apiResponse.response())) {
                    responseType = apiResponse.response();
                    final Property property = ModelConverters.getInstance().readAsProperty(responseType);
                    if (property != null) {
                        response.schema(ContainerWrapper.wrapContainer(apiResponse.responseContainer(), property));
                        appendModels(responseType);
                    }
                }
            }
        }
        if (ReflectionUtils.getAnnotation(method, Deprecated.class) != null) {
            operation.setDeprecated(true);
        }

        // process parameters
        for (Parameter globalParameter : globalParameters) {
            operation.parameter(globalParameter);
        }

        Type[] genericParameterTypes = method.getGenericParameterTypes();
        Annotation[][] paramAnnotations = method.getParameterAnnotations();
        for (int i = 0; i < genericParameterTypes.length; i++) {
            final Type type = TypeFactory.defaultInstance().constructType(genericParameterTypes[i], cls);
            List<Parameter> parameters = getParameters(type, Arrays.asList(paramAnnotations[i]));

            for (Parameter parameter : parameters) {
                operation.parameter(parameter);
            }
        }

        if (operation.getResponses() == null) {
            Response response = new Response().description(SUCCESSFUL_OPERATION);
            operation.defaultResponse(response);
        }
        return operation;
// END parseMethod(Class<?>-Class<?>-Method-Method-List<Parameter>-List<Parameter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5d0b8-4ddb6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d492b-6de48
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fc91c-16a8b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e655e-5fe87
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_e655e_5fe87\rev_rev_left_e655e-rev_right_5fe87\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [505, 506, 507, 508, 509]
Right editions: [444, 445, 446, 447, 448, 449]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            // We don't build models for primitive types
            return null;
        }

        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

        if (!type.isContainerType()) {
            // define the model here to support self/cyclic referencing of models
            context.defineModel(name, model, type, null);
        }

        if (type.isContainerType()) {
            // We treat collections as primitive types, just need to add models for values (if any)
            context.resolve(type.getContentType());
            return null;
        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        final int length = altName.length();
                        for (String prefix : Arrays.asList("get", "is")) {
                            final int offset = prefix.length();
                            if (altName.startsWith(prefix) && length > offset
                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
            if (propDef.getSetter() == null) {
                hasSetter = false;
            } else {
                hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();

            if (member != null && !propertiesToIgnore.contains(propName)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);
                
                if(mp != null && mp.readOnly()) {
                  isReadOnly = mp.readOnly();
                }

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = PrimitiveType.createProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = PrimitiveType.createProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
// RIGHT //                    } else if (member.getAnnotation(JsonIdentityInfo.class) != null) {
// RIGHT //                        property = GeneratorWrapper.processJsonIdentity(propType, context, _mapper,
// RIGHT //                                member.getAnnotation(JsonIdentityInfo.class),
// RIGHT //                                member.getAnnotation(JsonIdentityReference.class));
// RIGHT //                    }
// RIGHT //                    if (property == null) {
                        property = context.resolveProperty(propType, annotations);
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }
                    if (mp != null) {
                        final AllowableValues allowableValues = AllowableValuesUtils.create(mp.allowableValues());
                        if (allowableValues != null) {
                            final Map<PropertyBuilder.PropertyId, Object> args = allowableValues.asPropertyArguments();
                            PropertyBuilder.merge(property, args);
                        }
                    }
                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);
// LEFT //
// LEFT //        if (!resolveSubtypes(model, beanDesc, context)) {
// LEFT //            model.setDiscriminator(null);
// LEFT //        }
// LEFT //
        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_739b6-daa0a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ac4ec-41a6a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_468a3-ba0dc
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_34309-a5126
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_feedc-83781
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_83781-798bf
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_83781_798bf\rev_rev_left_83781-rev_right_798bf\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [298, 303, 340, 360]
Right editions: [428]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//private Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters, Set<Class<?>> scannedResources) {
        Api api = (Api) cls.getAnnotation(Api.class);
        Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        // only read if allowing hidden apis OR api is not marked as hidden
        final boolean readable = (api != null && readHidden) || (api != null && !api.hidden());
        if (readable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            if (parentTags != null) {
                tags.putAll(parentTags);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
                produces = new String[]{api.produces()};
            } else if (cls.getAnnotation(Produces.class) != null) {
// LEFT //                produces = ReaderUtils.splitContentValues(cls.getAnnotation(Produces.class).value());
            }
            if (!api.consumes().isEmpty()) {
                consumes = new String[]{api.consumes()};
            } else if (cls.getAnnotation(Consumes.class) != null) {
// LEFT //                consumes = ReaderUtils.splitContentValues(cls.getAnnotation(Consumes.class).value());
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));
            Authorization[] authorizations = api.authorizations();

            for (Authorization auth : authorizations) {
                if (auth.value() != null && !"".equals(auth.value())) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    AuthorizationScope[] scopes = auth.scopes();
                    for (AuthorizationScope scope : scopes) {
                        if (scope.scope() != null && !"".equals(scope.scope())) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        // allow reading the JAX-RS APIs without @Api annotation
        if (readable || (api == null && config.isScanAllResources())) {
            // merge consumes, produces

            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            final List<Parameter> globalParameters = new ArrayList<Parameter>();

            // look for constructor-level annotated properties
            globalParameters.addAll(ReaderUtils.collectConstructorParameters(cls, swagger));

            // look for field-level annotated properties
            globalParameters.addAll(ReaderUtils.collectFieldParameters(cls, swagger));

            // parse the method
// LEFT //            final javax.ws.rs.Path apiPath = ReflectionUtils.getAnnotation(cls, javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = ReflectionUtils.getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                Map<String, String> regexMap = new HashMap<String, String>();
                operationPath = PathUtils.parsePath(operationPath, regexMap);
                if (operationPath != null) {
                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = ReflectionUtils.getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

                    Operation operation = null;
// LEFT //                    if(apiOperation != null || config.isScanAllResources() || httpMethod != null || methodPath != null) {
                        operation = parseMethod(cls, method, globalParameters);
                    }
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new HashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new HashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResource(method);
                    if (subResource != null && !scannedResources.contains(subResource)) {
                        scannedResources.add(subResource);
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters(), scannedResources);
                    }

                    // can't continue without a valid http method
                    httpMethod = httpMethod == null ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            boolean hasExplicitTag = false;
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            if (operation != null) {
// RIGHT //                                operation.getVendorExtensions().putAll(BaseReaderUtils.parseExtensions(apiOperation.extensions()));
                            }
                        }
                        if (operation != null) {
                            if (operation.getConsumes() == null) {
                                for (String mediaType : apiConsumes) {
                                    operation.consumes(mediaType);
                                }
                            }
                            if (operation.getProduces() == null) {
                                for (String mediaType : apiProduces) {
                                    operation.produces(mediaType);
                                }
                            }

                            if (operation.getTags() == null) {
                                for (String tagString : tags.keySet()) {
                                    operation.tag(tagString);
                                }
                            }
                            // Only add global @Api securities if operation doesn't already have more specific securities
                            if (operation.getSecurity() == null) {
                                for (SecurityRequirement security : securities) {
                                    operation.security(security);
                                }
                            }

                            Path path = swagger.getPath(operationPath);
                            if (path == null) {
                                path = new Path();
                                swagger.path(operationPath, path);
                            }
                            path.set(httpMethod, operation);

                            readImplicitParameters(method, operation);
                        }
                    }
                }
            }
        }

        return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_81ed7-48375
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5576a-da61c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_560af-f9909
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_75394-6b619
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ffa65-6999a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4b174-4e7a8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_05475-deda3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6de2d-6f801
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a906d-62058
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a906d-941a0
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3c4c9-afa3c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c6ee7-e96fc
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6fc3a-262f8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_43c7f-f1585
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_11e68-8ad52
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_00117-17587
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d319d-cd85f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_914c1-422b9
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_37547-d0f25
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d90a3-353fe
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1064c-75b33
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_50a02-42bfa
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a7645-83793
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_4e665-27103
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_cfa59-e1dcf
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d2ba9-78834
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9a99b-6f238
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_74fa4-30886
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0bfdc-a95ef
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b0bdc-77d0f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_aa6a4-94692
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e10dc-4fa16
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c7ef0-c6922
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_c7ef0_c6922\rev_rev_left_c7ef0-rev_right_c6922\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: false
Left editions: [312, 315, 343, 344, 345, 346, 347, 348]
Right editions: [361, 362, 363, 364, 365, 366, 367, 390]
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//private Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean isSubresource, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters, Set<Class<?>> scannedResources) {
        Map<String, SecurityScope> globalScopes = new HashMap<String, SecurityScope>();

        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        Api api = (Api) cls.getAnnotation(Api.class);

        boolean hasPathAnnotation = (ReflectionUtils.getAnnotation(cls, javax.ws.rs.Path.class) != null);
        boolean hasApiAnnotation = (api != null);
        boolean isApiHidden = hasApiAnnotation && api.hidden();

        // class readable only if annotated with @Path or isSubresource, or and @Api not hidden
        boolean classReadable = (hasPathAnnotation || isSubresource) && !isApiHidden ;

        // readable if classReadable or (scanAllResources true in config and @Api not hidden)
        boolean readable = classReadable || (!isApiHidden && config.isScanAllResources());

        if (!readable) {
            return swagger;
        }

        // api readable only if @Api present; cannot be hidden because checked in classReadable.
        boolean apiReadable =  hasApiAnnotation;

        if (apiReadable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
// LEFT //                produces = ReaderUtils.splitContentValues(new String[] {api.produces()});
            }
            if (!api.consumes().isEmpty()) {
// LEFT //                consumes = ReaderUtils.splitContentValues(new String[] {api.consumes()});
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));
            Authorization[] authorizations = api.authorizations();

            for (Authorization auth : authorizations) {
                if (auth.value() != null && !"".equals(auth.value())) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    AuthorizationScope[] scopes = auth.scopes();
                    for (AuthorizationScope scope : scopes) {
                        if (scope.scope() != null && !"".equals(scope.scope())) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        if (readable) {

            if (isSubresource) {
                if (parentTags != null) {
                    tags.putAll(parentTags);
                }
            }
            // merge consumes, produces
// LEFT //            if (consumes.length == 0 && cls.getAnnotation(Consumes.class) != null) {
// LEFT //                consumes = ReaderUtils.splitContentValues(cls.getAnnotation(Consumes.class).value());
// LEFT //            }
// LEFT //            if (produces.length == 0 && cls.getAnnotation(Produces.class) != null) {
// LEFT //                produces = ReaderUtils.splitContentValues(cls.getAnnotation(Produces.class).value());
// LEFT //            }
            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            final List<Parameter> globalParameters = new ArrayList<Parameter>();

            // look for constructor-level annotated properties
            globalParameters.addAll(ReaderUtils.collectConstructorParameters(cls, swagger));

            // look for field-level annotated properties
            globalParameters.addAll(ReaderUtils.collectFieldParameters(cls, swagger));

// RIGHT //            // build class/interface level @ApiResponse list
// RIGHT //            ApiResponses classResponseAnnotation = ReflectionUtils.getAnnotation(cls, ApiResponses.class);
// RIGHT //            List<ApiResponse> classApiResponses = new ArrayList<ApiResponse>();
// RIGHT //            if (classResponseAnnotation != null) {
// RIGHT //                classApiResponses.addAll(Arrays.asList(classResponseAnnotation.value()));
// RIGHT //            }
// RIGHT //
            // parse the method
            final javax.ws.rs.Path apiPath = ReflectionUtils.getAnnotation(cls, javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = ReflectionUtils.getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                Map<String, String> regexMap = new HashMap<String, String>();
                operationPath = PathUtils.parsePath(operationPath, regexMap);
                if (operationPath != null) {
                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = ReflectionUtils.getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

                    Operation operation = null;
                    if(apiOperation != null || config.isScanAllResources() || httpMethod != null || methodPath != null) {
// RIGHT //                        operation = parseMethod(cls, method, globalParameters, classApiResponses);
                    }
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new HashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new HashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new HashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new HashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new HashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResourceWithJaxRsSubresourceLocatorSpecs(method);
                    if (subResource != null && !scannedResources.contains(subResource)) {
                        scannedResources.add(subResource);
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters(), scannedResources);
                        // remove the sub resource so that it can visit it later in another path
                        // but we have a room for optimization in the future to reuse the scanned result
                        // by caching the scanned resources in the reader instance to avoid actual scanning
                        // the the resources again
                        scannedResources.remove(subResource);
                    }

                    // can't continue without a valid http method
                    httpMethod = httpMethod == null ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            boolean hasExplicitTag = false;
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            operation.getVendorExtensions().putAll(BaseReaderUtils.parseExtensions(apiOperation.extensions()));
                        }

                        if (operation.getConsumes() == null) {
                            for (String mediaType : apiConsumes) {
                                operation.consumes(mediaType);
                            }
                        }
                        if (operation.getProduces() == null) {
                            for (String mediaType : apiProduces) {
                                operation.produces(mediaType);
                            }
                        }

                        if (operation.getTags() == null) {
                            for (String tagString : tags.keySet()) {
                                operation.tag(tagString);
                            }
                        }
                        // Only add global @Api securities if operation doesn't already have more specific securities
                        if (operation.getSecurity() == null) {
                            for (SecurityRequirement security : securities) {
                                operation.security(security);
                            }
                        }

                        Path path = swagger.getPath(operationPath);
                        if (path == null) {
                            path = new Path();
                            swagger.path(operationPath, path);
                        }
                        path.set(httpMethod, operation);

                        readImplicitParameters(method, operation);
                    }
                }
            }
        }

        return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_62388-dc1d6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a4a1d-93a49
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_18716-6e98f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2c08a-12642
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1fdf5-00c7f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d98de-3dc60
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_aee65-878c8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_05670-cb5a8
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_05670_cb5a8\rev_rev_left_05670-rev_right_cb5a8\modules\swagger-core\src\main\java\io\swagger\core\filter\SpecFilter.java
Different Spacing: false
Left editions: [195, 196, 197, 198, 200]
Right editions: [138, 139, 140, 148, 149, 150, 161, 162, 163, 172, 173, 174, 182, 183, 184]
Merged body: 
// START removeBrokenReferenceDefinitions(Swagger-Swagger)//private Swagger removeBrokenReferenceDefinitions (Swagger swagger) {

        if (swagger.getDefinitions() == null || swagger.getDefinitions().isEmpty()) return swagger;

        Set<String> referencedDefinitions =  new TreeSet<String>();

        if (swagger.getResponses() != null) {
            for (Response response: swagger.getResponses().values()) {
// RIGHT //                String propertyRef = getPropertyRef(response.getSchema());
// RIGHT //                if (propertyRef != null) {
// RIGHT //                    referencedDefinitions.add(propertyRef);
                }
            }
        }
        if (swagger.getParameters() != null) {
            for (Parameter p: swagger.getParameters().values()) {
                if (p instanceof BodyParameter) {
                    BodyParameter bp = (BodyParameter) p;
// RIGHT //                    String modelRef = getModelRef(bp.getSchema());
// RIGHT //                    if (modelRef != null) {
// RIGHT //                        referencedDefinitions.add(modelRef);
                    }
                }
            }
        }
        if (swagger.getPaths() != null) {
            for (Path path : swagger.getPaths().values()) {
                if (path.getParameters() != null) {
                    for (Parameter p: path.getParameters()) {
                        if (p instanceof BodyParameter) {
                            BodyParameter bp = (BodyParameter) p;
// RIGHT //                            String modelRef = getModelRef(bp.getSchema());
// RIGHT //                            if (modelRef != null) {
// RIGHT //                                referencedDefinitions.add(modelRef);
                            }
                        }
                    }
                }
                if (path.getOperations() != null) {
                    for (Operation op: path.getOperations()) {
                        if (op.getResponses() != null) {
                            for (Response response: op.getResponses().values()) {
// RIGHT //                                String propertyRef = getPropertyRef(response.getSchema());
// RIGHT //                                if (propertyRef != null) {
// RIGHT //                                    referencedDefinitions.add(propertyRef);
                                }
                            }
                        }
                        if (op.getParameters() != null) {
                            for (Parameter p: op.getParameters()) {
                                if (p instanceof BodyParameter) {
                                    BodyParameter bp = (BodyParameter) p;
// RIGHT //                                    String modelRef = getModelRef(bp.getSchema());
// RIGHT //                                    if (modelRef != null) {
// RIGHT //                                        referencedDefinitions.add(modelRef);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (swagger.getDefinitions() != null) {
// LEFT //            Set<String> nestedReferencedDefinitions =  new TreeSet<String>();
// LEFT //            for (String ref : referencedDefinitions){
// LEFT //                Model m = swagger.getDefinitions().get(ref);
// LEFT //                locateNestedReferencedDefinitions (m.getProperties(), nestedReferencedDefinitions, swagger);
            }
// LEFT //            referencedDefinitions.addAll(nestedReferencedDefinitions);
            swagger.getDefinitions().keySet().retainAll(referencedDefinitions);
        }
        
        return swagger;
// END removeBrokenReferenceDefinitions(Swagger-Swagger)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_05670-a0244
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d2490-a73f4
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c7c9a-e8265
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3e6b3-c52f2
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0c46e-8d706
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_54bb3-54e64
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b70a3-7a60e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_46988-8db0f
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_46988_8db0f\rev_rev_left_46988-rev_right_8db0f\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: []
Right editions: [460, 461, 462, 463]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            // We don't build models for primitive types
            return null;
        }

        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        /**
         * --Preventing parent/child hierarchy creation loops - Comment 1--
         * Creating a parent model will result in the creation of child models. Creating a child model will result in
         * the creation of a parent model, as per the second If statement following this comment.
         *
         * By checking whether a model has already been resolved (as implemented below), loops of parents creating
         * children and children creating parents can be short-circuited. This works because currently the
         * ModelConverterContextImpl will return null for a class that already been processed, but has not yet been
         * defined. This logic works in conjunction with the early immediate definition of model in the context
         * implemented later in this method (See "Preventing parent/child hierarchy creation loops - Comment 2") to
         * prevent such
         */
        Model resolvedModel = context.resolve(type.getRawClass());
        if (resolvedModel != null) {
            if (!(resolvedModel instanceof ModelImpl || resolvedModel instanceof ComposedModel)
                    || (resolvedModel instanceof ModelImpl && ((ModelImpl) resolvedModel).getName().equals(name))) {
                return resolvedModel;
            } else if (resolvedModel instanceof ComposedModel) {
                Model childModel = ((ComposedModel) resolvedModel).getChild();
                if (childModel != null && (!(childModel instanceof ModelImpl)
                        || ((ModelImpl) childModel).getName().equals(name))) {
                    return resolvedModel;
                }
            }
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

        if (!type.isContainerType()) {
            // define the model here to support self/cyclic referencing of models
            context.defineModel(name, model, type, null);
        }

        if (type.isContainerType()) {
            // We treat collections as primitive types, just need to add models for values (if any)
            context.resolve(type.getContentType());
            return null;
        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }
        final XmlAccessorType xmlAccessorTypeAnnotation = beanDesc.getClassAnnotations().get(XmlAccessorType.class);

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        final int length = altName.length();
                        for (String prefix : Arrays.asList("get", "is")) {
                            final int offset = prefix.length();
                            if (altName.startsWith(prefix) && length > offset
                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
            if (propDef.getSetter() == null) {
                hasSetter = false;
            } else {
                hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();

            if (member != null && !ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                if (mp != null && mp.readOnly()) {
                    isReadOnly = mp.readOnly();
                }

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = PrimitiveType.createProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = PrimitiveType.createProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else if (member.getAnnotation(JsonIdentityInfo.class) != null) {
                        property = GeneratorWrapper.processJsonIdentity(propType, context, _mapper,
                                member.getAnnotation(JsonIdentityInfo.class),
                                member.getAnnotation(JsonIdentityReference.class));
                    }
                    if (property == null) {
// RIGHT //                        JsonUnwrapped uw = member.getAnnotation(JsonUnwrapped.class);
// RIGHT //                        if (uw != null && uw.enabled()) {
// RIGHT //                            handleUnwrapped(props, context.resolve(propType), uw.prefix(), uw.suffix());
// RIGHT //                        } else {
                        property = context.resolveProperty(propType, annotations);
                    }
                }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }
                    if (mp != null) {
                        final AllowableValues allowableValues = AllowableValuesUtils.create(mp.allowableValues());
                        if (allowableValues != null) {
                            final Map<PropertyBuilder.PropertyId, Object> args = allowableValues.asPropertyArguments();
                            PropertyBuilder.merge(property, args);
                        }
                    }
                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);

        /**
         * --Preventing parent/child hierarchy creation loops - Comment 2--
         * Creating a parent model will result in the creation of child models, as per the first If statement following
         * this comment. Creating a child model will result in the creation of a parent model, as per the second If
         * statement following this comment.
         *
         * The current model must be defined in the context immediately. This done to help prevent repeated
         * loops where  parents create children and children create parents when a hierarchy is present. This logic
         * works in conjunction with the "early checking" performed earlier in this method
         * (See "Preventing parent/child hierarchy creation loops - Comment 1"), to prevent repeated creation loops.
         *
         *
         * As an aside, defining the current model in the context immediately also ensures that child models are
         * available for modification by resolveSubtypes, when their parents are created.
         */
        Class<?> currentType = type.getRawClass();
        context.defineModel(name, model, currentType, null);

        /**
         * This must be done after model.setProperties so that the model's set
         * of properties is available to filter from any subtypes
         **/
        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

        if (apiModel != null) {
            /**
             * Check if the @ApiModel annotation has a parent property containing a value that should not be ignored
             */
            Class<?> parentClass = apiModel.parent();
            if (parentClass != null && !parentClass.equals(Void.class) && !this.shouldIgnoreClass(parentClass)) {
                JavaType parentType = _mapper.constructType(parentClass);
                final BeanDescription parentBeanDesc = _mapper.getSerializationConfig().introspect(parentType);

                /**
                 * Retrieve all the sub-types of the parent class and ensure that the current type is one of those types
                 */
                boolean currentTypeIsParentSubType = false;
                List<NamedType> subTypes = _intr.findSubtypes(parentBeanDesc.getClassInfo());
                for (NamedType subType : subTypes) {
                    if (subType.getType().equals(currentType)) {
                        currentTypeIsParentSubType = true;
                        break;
                    }
                }

                /**
                 Retrieve the subTypes from the parent class @ApiModel annotation and ensure that the current type
                 is one of those types.
                 */
                boolean currentTypeIsParentApiModelSubType = false;
                final ApiModel parentApiModel = parentBeanDesc.getClassAnnotations().get(ApiModel.class);
                if (parentApiModel != null) {
                    Class<?>[] apiModelSubTypes = parentApiModel.subTypes();
                    for (Class<?> subType : apiModelSubTypes) {
                        if (subType.equals(currentType)) {
                            currentTypeIsParentApiModelSubType = true;
                            break;
                        }
                    }
                }

                /**
                 If the current type is a sub-type of the parent class and is listed in the subTypes property of the
                 parent class @ApiModel annotation, then do the following:
                 1. Resolve the model for the parent class. This will result in the parent model being created, and the
                 current child model being updated to be a ComposedModel referencing the parent.
                 2. Resolve and return the current child type again. This will return the new ComposedModel from the
                 context, which was created in step 1 above. Admittedly, there is a small chance that this may result
                 in a stack overflow, if the context does not correctly cache the model for the current type. However,
                 as context caching is assumed elsewhere to avoid cyclical model creation, this was deemed to be
                 sufficient.
                 */
                if (currentTypeIsParentSubType && currentTypeIsParentApiModelSubType) {
                    context.resolve(parentClass);
                    return context.resolve(currentType);
                }
            }
        }

        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8db0f-3bbe3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f58db-e9f0b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7a94c-96b9a
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f529c-964ff
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9231b-bc681
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9543d-3a79f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b47ab-699de
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_92e6d-8bee0
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e42e6-adde6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_adde6-8e670
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_33a8a-9fe0b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_03462-7878c
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_03462_7878c\rev_rev_left_03462-rev_right_7878c\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START parseMethod(Class<?>-Class<?>-Method-Method-List<Parameter>-List<Parameter>-List<ApiResponse>-List<ApiResponse>)//private Operation parseMethod(Class<?> cls, Method method, List<Parameter> globalParameters, List<ApiResponse> classApiResponses) {
        Operation operation = new Operation();

        ApiOperation apiOperation = ReflectionUtils.getAnnotation(method, ApiOperation.class);
        ApiResponses responseAnnotation = ReflectionUtils.getAnnotation(method, ApiResponses.class);

        String operationId = null;
        // check if it's an inherited method.
        if(ReflectionUtils.findMethod(method, cls.getSuperclass()) == null) {
            operationId = method.getName();
        } else {
            operationId = this.getOperationId(method.getName());
        }
        String responseContainer = null;

        Type responseType = null;
        Map<String, Property> defaultResponseHeaders = new HashMap<String, Property>();

        if (apiOperation != null) {
            if (apiOperation.hidden()) {
                return null;
            }
            if (!apiOperation.nickname().isEmpty()) {
                operationId = apiOperation.nickname();
            }

            defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());

            operation.summary(apiOperation.value())
                    .description(apiOperation.notes());

            if (!isVoid(apiOperation.response())) {
                responseType = apiOperation.response();
            }
            if (!apiOperation.responseContainer().isEmpty()) {
                responseContainer = apiOperation.responseContainer();
            }
            List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();
            for (Authorization auth : apiOperation.authorizations()) {
                if (!auth.value().isEmpty()) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    for (AuthorizationScope scope : auth.scopes()) {
                        if (!scope.scope().isEmpty()) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
            for (SecurityRequirement sec : securities) {
                operation.security(sec);
            }
            if (!apiOperation.consumes().isEmpty()) {
                String[] consumesAr = ReaderUtils.splitContentValues(new String[]{apiOperation.consumes()});
                for (String consume : consumesAr) {
                    operation.consumes(consume);
                }
            }
            if (!apiOperation.produces().isEmpty()) {
                String[] producesAr = ReaderUtils.splitContentValues(new String[]{apiOperation.produces()});
                for (String produce : producesAr) {
                    operation.produces(produce);
                }
            }
        }

        if (apiOperation != null && StringUtils.isNotEmpty(apiOperation.responseReference())) {
            Response response = new Response().description(SUCCESSFUL_OPERATION);
            response.schema(new RefProperty(apiOperation.responseReference()));
            operation.addResponse(String.valueOf(apiOperation.code()), response);
        } else if (responseType == null) {
            // pick out response from method declaration
            LOGGER.debug("picking up response class from method " + method);
            responseType = method.getGenericReturnType();
        }
        if (isValidResponse(responseType)) {
            final Property property = ModelConverters.getInstance().readAsProperty(responseType);
            if (property != null) {
                final Property responseProperty = ContainerWrapper.wrapContainer(responseContainer, property);
                final int responseCode = (apiOperation == null) ? 200 : apiOperation.code();
                operation.response(responseCode, new Response().description(SUCCESSFUL_OPERATION).schema(responseProperty)
                        .headers(defaultResponseHeaders));
                appendModels(responseType);
            }
        }

        operation.operationId(operationId);

        if (operation.getConsumes() == null || operation.getConsumes().isEmpty()) {
            final Consumes consumes = ReflectionUtils.getAnnotation(method, Consumes.class);
            if (consumes != null) {
                for (String mediaType : ReaderUtils.splitContentValues(consumes.value())) {
                    operation.consumes(mediaType);
                }
            }
        }

        if (operation.getProduces() == null || operation.getProduces().isEmpty()) {
            final Produces produces = ReflectionUtils.getAnnotation(method, Produces.class);
            if (produces != null) {
                for (String mediaType : ReaderUtils.splitContentValues(produces.value())) {
                    operation.produces(mediaType);
                }
            }
        }

        List<ApiResponse> apiResponses = new ArrayList<ApiResponse>();
        if (responseAnnotation != null) {
            apiResponses.addAll(Arrays.asList(responseAnnotation.value()));
        }

        Class<?>[] exceptionTypes = method.getExceptionTypes();
        for (Class<?> exceptionType : exceptionTypes) {
            ApiResponses exceptionResponses = ReflectionUtils.getAnnotation(exceptionType, ApiResponses.class);
            if (exceptionResponses != null) {
                apiResponses.addAll(Arrays.asList(exceptionResponses.value()));
            }
        }

        for (ApiResponse apiResponse : apiResponses) {
            addResponse(operation, apiResponse);
        }
        // merge class level @ApiResponse
        for (ApiResponse apiResponse : classApiResponses) {
            String key = (apiResponse.code() == 0) ? "default" : String.valueOf(apiResponse.code());
            if (operation.getResponses() != null && operation.getResponses().containsKey(key)) {
                continue;
            }
            addResponse(operation, apiResponse);
        }

        if (ReflectionUtils.getAnnotation(method, Deprecated.class) != null) {
            operation.setDeprecated(true);
        }

        // process parameters
        for (Parameter globalParameter : globalParameters) {
            operation.parameter(globalParameter);
        }

        Type[] genericParameterTypes = method.getGenericParameterTypes();
        Annotation[][] paramAnnotations = ReflectionUtils.getParameterAnnotations(method);
        for (int i = 0; i < genericParameterTypes.length; i++) {
            final Type type = TypeFactory.defaultInstance().constructType(genericParameterTypes[i], cls);
            List<Parameter> parameters = getParameters(type, Arrays.asList(paramAnnotations[i]));

            for (Parameter parameter : parameters) {
                operation.parameter(parameter);
            }
        }

        if (operation.getResponses() == null) {
            Response response = new Response().description(SUCCESSFUL_OPERATION);
            operation.defaultResponse(response);
        }
        
        processOperationDecorator(operation, method);
        
        return operation;
// END parseMethod(Class<?>-Class<?>-Method-Method-List<Parameter>-List<Parameter>-List<ApiResponse>-List<ApiResponse>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_68d44-a6423
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_40374-6f9ed
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_94d73-6f9ed
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d8a8a-065f6
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ba73b-b5140
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a04ec-15435
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_a04ec_15435\rev_rev_left_a04ec-rev_right_15435\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: []
Right editions: [298, 304, 305, 306, 307, 308, 309]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            // We don't build models for primitive types
            return null;
        }

        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

        if (!type.isContainerType()) {
            // define the model here to support self/cyclic referencing of models
            context.defineModel(name, model, type, null);
        }

        if (type.isContainerType()) {
            // We treat collections as primitive types, just need to add models for values (if any)
            context.resolve(type.getContentType());
            return null;
        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }
        final XmlAccessorType xmlAccessorTypeAnnotation = beanDesc.getClassAnnotations().get(XmlAccessorType.class);

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        final int length = altName.length();
                        for (String prefix : Arrays.asList("get", "is")) {
                            final int offset = prefix.length();
                            if (altName.startsWith(prefix) && length > offset
                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
// RIGHT //            try{
            if (propDef.getSetter() == null) {
                hasSetter = false;
            } else {
                hasSetter = true;
            }
// RIGHT //            }catch(IllegalArgumentException e){
// RIGHT //                //com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder would throw IllegalArgumentException
// RIGHT //                // if there are overloaded setters. If we only want to know whether a set method exists, suppress the exception
// RIGHT //                // is reasonable.
// RIGHT //                // More logs might be added here
// RIGHT //            	hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();

            if (member != null && !ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                if (mp != null && mp.readOnly()) {
                    isReadOnly = mp.readOnly();
                }

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = PrimitiveType.createProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = PrimitiveType.createProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else if (member.getAnnotation(JsonIdentityInfo.class) != null) {
                        property = GeneratorWrapper.processJsonIdentity(propType, context, _mapper,
                                member.getAnnotation(JsonIdentityInfo.class),
                                member.getAnnotation(JsonIdentityReference.class));
                    }
                    if (property == null) {
                        JsonUnwrapped uw = member.getAnnotation(JsonUnwrapped.class);
                        if (uw != null && uw.enabled()) {
                            handleUnwrapped(props, context.resolve(propType), uw.prefix(), uw.suffix());
                        } else {
                            property = context.resolveProperty(propType, annotations);
                        }
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }
                    if (mp != null) {
                        final AllowableValues allowableValues = AllowableValuesUtils.create(mp.allowableValues());
                        if (allowableValues != null) {
                            final Map<PropertyBuilder.PropertyId, Object> args = allowableValues.asPropertyArguments();
                            PropertyBuilder.merge(property, args);
                        }
                    }
                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);

        /**
         * This must be done after model.setProperties so that the model's set
         * of properties is available to filter from any subtypes
         **/
        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_05b0b-944fb
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_8f294-2f4ca
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a49d9-8ea60
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5aae8-754a7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0ef53-6d5b0
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_24eb6-4e7a7
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_24eb6_4e7a7\rev_rev_left_24eb6-rev_right_4e7a7\modules\swagger-core\src\main\java\io\swagger\util\ParameterProcessor.java
Different Spacing: false
Left editions: [145, 146, 147, 148, 149, 150]
Right editions: [76, 106, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 169, 170, 171, 172, 173, 174, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 232, 233, 237, 238, 239]
Merged body: 
// START applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//public static Parameter applyAnnotations(Swagger swagger, Parameter parameter, Type type, List<Annotation> annotations) {
// RIGHT //        final AnnotationsHelper helper = new AnnotationsHelper(annotations, type);
        if (helper.isContext()) {
            return null;
        }
        final ParamWrapper<?> param = helper.getApiParam();
        if (param.isHidden()) {
            return null;
        }
        final String defaultValue = helper.getDefaultValue();
        if (parameter instanceof AbstractSerializableParameter) {
            final AbstractSerializableParameter<?> p = (AbstractSerializableParameter<?>) parameter;

            if (param.isRequired()) {
                p.setRequired(true);
            }
            if (StringUtils.isNotEmpty(param.getName())) {
                p.setName(param.getName());
            }
            if (StringUtils.isNotEmpty(param.getDescription())) {
                p.setDescription(param.getDescription());
            }
            if (StringUtils.isNotEmpty(param.getExample())) {
                p.setExample(param.getExample());
            }
            if (StringUtils.isNotEmpty(param.getAccess())) {
                p.setAccess(param.getAccess());
            }
            if (StringUtils.isNotEmpty(param.getDataType())) {
                if("java.io.File".equalsIgnoreCase(param.getDataType())) {
                    p.setProperty(new FileProperty());
// RIGHT //                } else {
                    p.setType(param.getDataType());
                }
            }
// RIGHT //            if (helper.getMin() != null || helper.getDecimalMin() != null) {
// RIGHT //                p.setMinimum(helper.getMin() != null ? new Double(helper.getMin()) : helper.getDecimalMin());
// RIGHT //                if (helper.isMinExclusive()) {
// RIGHT //                    p.setExclusiveMinimum(true);
// RIGHT //                }
// RIGHT //            }
// RIGHT //
// RIGHT //            if (helper.getMax() != null || helper.getDecimalMax() != null) {
// RIGHT //                p.setMaximum(helper.getMax() != null ? new Double(helper.getMax()) : helper.getDecimalMax());
// RIGHT //                if (helper.isMaxExclusive()) {
// RIGHT //                    p.setExclusiveMaximum(true);
// RIGHT //                }
// RIGHT //            }
// RIGHT //
            if (helper.getMinItems() != null) {
                p.setMinItems(helper.getMinItems());
            }
            if (helper.getMaxItems() != null) {
                p.setMaxItems(helper.getMaxItems());
            }
// RIGHT //
// RIGHT //            if (helper.getMinLength() != null) {
// RIGHT //                p.setMinLength(helper.getMinLength());
// RIGHT //            }
// RIGHT //            if (helper.getMaxLength() != null) {
// RIGHT //                p.setMaxLength(helper.getMaxLength());
// RIGHT //            }
// RIGHT //
// RIGHT //            if (helper.getPattern() != null) {
// RIGHT //                p.setPattern(helper.getPattern());
// RIGHT //            }
// RIGHT //
            if (helper.isRequired() != null) {
                p.setRequired(true);
            }
// LEFT //            if(helper.getType() != null) {
// LEFT //                p.setType(helper.getType());
// LEFT //            }
// LEFT //            if(helper.getFormat() != null) {
// LEFT //                p.setFormat(helper.getFormat());
// LEFT //            }

            AllowableValues allowableValues = AllowableValuesUtils.create(param.getAllowableValues());

            if (p.getItems() != null || param.isAllowMultiple()) {
                if (p.getItems() == null) {
                    // Convert to array
                    final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                    args.put(PropertyBuilder.PropertyId.DEFAULT, p.getDefaultValue());
                    p.setDefaultValue(null);
                    args.put(PropertyBuilder.PropertyId.ENUM, p.getEnum());
                    p.setEnum(null);
                    args.put(PropertyBuilder.PropertyId.MINIMUM, p.getMinimum());
                    p.setMinimum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, p.isExclusiveMinimum());
                    p.setExclusiveMinimum(null);
                    args.put(PropertyBuilder.PropertyId.MAXIMUM, p.getMaximum());
                    p.setMaximum(null);
                    args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, p.isExclusiveMaximum());
// RIGHT //                    args.put(PropertyBuilder.PropertyId.MIN_LENGTH, p.getMinLength());
// RIGHT //                    p.setMinLength(null);
// RIGHT //                    args.put(PropertyBuilder.PropertyId.MAX_LENGTH, p.getMaxLength());
// RIGHT //                    p.setMaxLength(null);
// RIGHT //                    args.put(PropertyBuilder.PropertyId.PATTERN, p.getPattern());
// RIGHT //                    p.setPattern(null);
                    args.put(PropertyBuilder.PropertyId.EXAMPLE, p.getExample());
                    p.setExclusiveMaximum(null);
                    Property items = PropertyBuilder.build(p.getType(), p.getFormat(), args);
                    p.type(ArrayProperty.TYPE).format(null).items(items);
                }

                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
// RIGHT //
// RIGHT //                /**
// RIGHT //                 * Use jsr-303 annotations (and other bean validation annotations) if present. This essentially implies
// RIGHT //                 * that the bean validation constraints now apply to the items and not to the parent collection/array.
// RIGHT //                 * Although this  will work for swagger definition purposes, there is no default validator for many of
// RIGHT //                 * the validator annotations when applied to a collection/array. For example, a @Min annotation applied
// RIGHT //                 * to a List&gt;Long&lt; will result in a swagger definition which contains an array property with items
// RIGHT //                 * of type number and having a 'minimum' validation constraint. However, there is no default bean
// RIGHT //                 * validator for @Min when applied to a List&gt;Long&lt;, and the developer would need to implement such
// RIGHT //                 * a validator themselves.
// RIGHT //                 */
// RIGHT //
// RIGHT //                if (helper.getMin() != null || helper.getDecimalMin() != null) {
// RIGHT //                    args.put(PropertyBuilder.PropertyId.MINIMUM,
// RIGHT //                            helper.getMin() != null ? new Double(helper.getMin()) : helper.getDecimalMin());
// RIGHT //                    if (helper.isMinExclusive()) {
// RIGHT //                        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MINIMUM, true);
// RIGHT //                    }
// RIGHT //                    }
// RIGHT //
// RIGHT //                if (helper.getMax() != null || helper.getDecimalMax() != null) {
// RIGHT //                    args.put(PropertyBuilder.PropertyId.MAXIMUM,
// RIGHT //                            helper.getMax() != null ? new Double(helper.getMax()) : helper.getDecimalMax());
// RIGHT //                    if (helper.isMaxExclusive()) {
// RIGHT //                        args.put(PropertyBuilder.PropertyId.EXCLUSIVE_MAXIMUM, true);
// RIGHT //                    }
// RIGHT //                }
// RIGHT //
// RIGHT //                if (helper.getMinLength() != null) {
// RIGHT //                    args.put(PropertyBuilder.PropertyId.MIN_LENGTH, helper.getMinLength());
// RIGHT //                    }
// RIGHT //                if (helper.getMaxLength() != null) {
// RIGHT //                    args.put(PropertyBuilder.PropertyId.MAX_LENGTH, helper.getMaxLength());
// RIGHT //                }
// RIGHT //                if (helper.getPattern() != null) {
// RIGHT //                    args.put(PropertyBuilder.PropertyId.PATTERN, helper.getPattern());
// RIGHT //                }
// RIGHT //
// RIGHT //                //Overwrite Bean validation values with allowable values if present
                if (allowableValues != null) {
                    args.putAll(allowableValues.asPropertyArguments());
                }
                PropertyBuilder.merge(p.getItems(), args);
            } else {
                if (StringUtils.isNotEmpty(defaultValue)) {
                    p.setDefaultValue(defaultValue);
                }
// RIGHT //
// RIGHT //                //Overwrite Bean validation values with allowable values if present
                if (allowableValues != null) {
                    processAllowedValues(allowableValues, p);
                }
// RIGHT ////                else {
// RIGHT ////                    processJsr303Annotations(helper, p);
// RIGHT ////                }
            }
        } else {
            // must be a body param
            BodyParameter bp = new BodyParameter();

            if (helper.getApiParam() != null) {
                ParamWrapper<?> pw = helper.getApiParam();

                if (pw instanceof ApiParamWrapper) {
                    ApiParamWrapper apiParam = (ApiParamWrapper) pw;
                    Example example = apiParam.getExamples();
                    if (example != null && example.value() != null) {
                        for (ExampleProperty ex : example.value()) {
                            String mediaType = ex.mediaType();
                            String value = ex.value();
                            if (!mediaType.isEmpty() && !value.isEmpty()) {
                                bp.example(mediaType.trim(), value.trim());
                            }
                        }
                    }
                } else if (pw instanceof ApiImplicitParamWrapper) {
                    ApiImplicitParamWrapper apiParam = (ApiImplicitParamWrapper) pw;
                    Example example = apiParam.getExamples();
                    if (example != null && example.value() != null) {
                        for (ExampleProperty ex : example.value()) {
                            String mediaType = ex.mediaType();
                            String value = ex.value();
                            if (!mediaType.isEmpty() && !value.isEmpty()) {
                                bp.example(mediaType.trim(), value.trim());
                            }
                        }
                    }
                }
            }
            bp.setRequired(param.isRequired());
            bp.setName(StringUtils.isNotEmpty(param.getName()) ? param.getName() : "body");

            if (StringUtils.isNotEmpty(param.getDescription())) {
                bp.setDescription(param.getDescription());
            }

            if (StringUtils.isNotEmpty(param.getAccess())) {
                bp.setAccess(param.getAccess());
            }

            final Property property = ModelConverters.getInstance().readAsProperty(type);
            if (property != null) {
                final Map<PropertyBuilder.PropertyId, Object> args = new EnumMap<PropertyBuilder.PropertyId, Object>(PropertyBuilder.PropertyId.class);
                if (StringUtils.isNotEmpty(defaultValue)) {
                    args.put(PropertyBuilder.PropertyId.DEFAULT, defaultValue);
                }
                bp.setSchema(PropertyBuilder.toModel(PropertyBuilder.merge(property, args)));
                for (Map.Entry<String, Model> entry : ModelConverters.getInstance().readAll(type).entrySet()) {
                    swagger.addDefinition(entry.getKey(), entry.getValue());
                }
            }
            parameter = bp;
        }
        return parameter;
// END applyAnnotations(Swagger-Swagger-Parameter-Parameter-Type-Type-List<Annotation>-List<Annotation>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_68de6-a6879
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_07ebc-40c19
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9ff90-a55ed
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0ed8d-ca27b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a689f-649cf
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_6b51d-41cee
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_0e26b-54377
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_84c80-f95e7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d7992-4c1e8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_ff4c9-7ac5d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_50d6d-33a24
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_50d6d_33a24\rev_rev_left_50d6d-rev_right_33a24\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\Reader.java
Different Spacing: true
Left editions: []
Right editions: []
Merged body: 
// START read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//private Swagger read(Class<?> cls, String parentPath, String parentMethod, boolean isSubresource, String[] parentConsumes, String[] parentProduces, Map<String, Tag> parentTags, List<Parameter> parentParameters, Set<Class<?>> scannedResources) {
        Map<String, Tag> tags = new HashMap<String, Tag>();
        List<SecurityRequirement> securities = new ArrayList<SecurityRequirement>();

        String[] consumes = new String[0];
        String[] produces = new String[0];
        final Set<Scheme> globalSchemes = EnumSet.noneOf(Scheme.class);

        Api api = ReflectionUtils.getAnnotation(cls, Api.class);

        boolean hasPathAnnotation = (ReflectionUtils.getAnnotation(cls, javax.ws.rs.Path.class) != null);
        boolean hasApiAnnotation = (api != null);
        boolean isApiHidden = hasApiAnnotation && api.hidden();

        // class readable only if annotated with ((@Path and @Api) or isSubresource ) - and @Api not hidden
        boolean classReadable = ((hasPathAnnotation && hasApiAnnotation)|| isSubresource) && !isApiHidden;

        // with scanAllResources true in config and @Api not hidden scan only if it has also @Path annotation or is subresource
        boolean scanAll = !isApiHidden && config.isScanAllResources() && (hasPathAnnotation || isSubresource);

        // readable if classReadable or scanAll
        boolean readable = classReadable || scanAll;


        if (!readable) {
            return swagger;
        }

        // api readable only if @Api present; cannot be hidden because checked in classReadable.
        boolean apiReadable = hasApiAnnotation;

        if (apiReadable) {
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
            Set<String> tagStrings = extractTags(api);
            for (String tagString : tagStrings) {
                Tag tag = new Tag().name(tagString);
                tags.put(tagString, tag);
            }
            for (String tagName : tags.keySet()) {
                swagger.tag(tags.get(tagName));
            }

            if (!api.produces().isEmpty()) {
                produces = ReaderUtils.splitContentValues(new String[]{api.produces()});
            }
            if (!api.consumes().isEmpty()) {
                consumes = ReaderUtils.splitContentValues(new String[]{api.consumes()});
            }
            globalSchemes.addAll(parseSchemes(api.protocols()));

            for (Authorization auth : api.authorizations()) {
                if (auth.value() != null && !auth.value().isEmpty()) {
                    SecurityRequirement security = new SecurityRequirement();
                    security.setName(auth.value());
                    for (AuthorizationScope scope : auth.scopes()) {
                        if (scope.scope() != null && !scope.scope().isEmpty()) {
                            security.addScope(scope.scope());
                        }
                    }
                    securities.add(security);
                }
            }
        }

        if (readable) {
            if (isSubresource) {
                if (parentTags != null) {
                    tags.putAll(parentTags);
                }
            }
            // merge consumes, produces
            if (consumes.length == 0 && cls.getAnnotation(Consumes.class) != null) {
                consumes = ReaderUtils.splitContentValues(cls.getAnnotation(Consumes.class).value());
            }
            if (produces.length == 0 && cls.getAnnotation(Produces.class) != null) {
                produces = ReaderUtils.splitContentValues(cls.getAnnotation(Produces.class).value());
            }
            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            final List<Parameter> globalParameters = new ArrayList<Parameter>();

            // look for constructor-level annotated properties
            globalParameters.addAll(ReaderUtils.collectConstructorParameters(cls, swagger));

            // look for field-level annotated properties
            globalParameters.addAll(ReaderUtils.collectFieldParameters(cls, swagger));

            // build class/interface level @ApiResponse list
            ApiResponses classResponseAnnotation = ReflectionUtils.getAnnotation(cls, ApiResponses.class);
            List<ApiResponse> classApiResponses = new ArrayList<ApiResponse>();
            if (classResponseAnnotation != null) {
                classApiResponses.addAll(Arrays.asList(classResponseAnnotation.value()));
            }

            // parse the method
            final javax.ws.rs.Path apiPath = ReflectionUtils.getAnnotation(cls, javax.ws.rs.Path.class);
            Method methods[] = cls.getMethods();
            for (Method method : methods) {
                if (ReflectionUtils.isOverriddenMethod(method, cls)) {
                    continue;
                }
                javax.ws.rs.Path methodPath = ReflectionUtils.getAnnotation(method, javax.ws.rs.Path.class);

                String operationPath = getPath(apiPath, methodPath, parentPath);
                Map<String, String> regexMap = new HashMap<String, String>();
                operationPath = PathUtils.parsePath(operationPath, regexMap);
                if (operationPath != null) {
                    if (isIgnored(operationPath)) {
                        continue;
                    }

                    final ApiOperation apiOperation = ReflectionUtils.getAnnotation(method, ApiOperation.class);
                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());

                    Operation operation = null;
                    if (apiOperation != null || config.isScanAllResources() || httpMethod != null || methodPath != null) {
                        operation = parseMethod(cls, method, globalParameters, classApiResponses);
                    }
                    if (operation == null) {
                        continue;
                    }
                    if (parentParameters != null) {
                        for (Parameter param : parentParameters) {
                            operation.parameter(param);
                        }
                    }
                    for (Parameter param : operation.getParameters()) {
                        if (regexMap.get(param.getName()) != null) {
                            String pattern = regexMap.get(param.getName());
                            param.setPattern(pattern);
                        }
                    }

                    if (apiOperation != null) {
                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {
                            operation.scheme(scheme);
                        }
                    }

                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {
                        for (Scheme scheme : globalSchemes) {
                            operation.scheme(scheme);
                        }
                    }

                    String[] apiConsumes = consumes;
                    if (parentConsumes != null) {
                        Set<String> both = new LinkedHashSet<String>(Arrays.asList(apiConsumes));
                        both.addAll(new LinkedHashSet<String>(Arrays.asList(parentConsumes)));
                        if (operation.getConsumes() != null) {
                            both.addAll(new LinkedHashSet<String>(operation.getConsumes()));
                        }
                        apiConsumes = both.toArray(new String[both.size()]);
                    }

                    String[] apiProduces = produces;
                    if (parentProduces != null) {
                        Set<String> both = new LinkedHashSet<String>(Arrays.asList(apiProduces));
                        both.addAll(new LinkedHashSet<String>(Arrays.asList(parentProduces)));
                        if (operation.getProduces() != null) {
                            both.addAll(new LinkedHashSet<String>(operation.getProduces()));
                        }
                        apiProduces = both.toArray(new String[both.size()]);
                    }
                    final Class<?> subResource = getSubResourceWithJaxRsSubresourceLocatorSpecs(method);
                    if (subResource != null && !scannedResources.contains(subResource)) {
                        scannedResources.add(subResource);
                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters(), scannedResources);
                        // remove the sub resource so that it can visit it later in another path
                        // but we have a room for optimization in the future to reuse the scanned result
                        // by caching the scanned resources in the reader instance to avoid actual scanning
                        // the the resources again
                        scannedResources.remove(subResource);
                    }

                    // can't continue without a valid http method
                    httpMethod = (httpMethod == null) ? parentMethod : httpMethod;
                    if (httpMethod != null) {
                        if (apiOperation != null) {
                            for (String tag : apiOperation.tags()) {
                                if (!"".equals(tag)) {
                                    operation.tag(tag);
                                    swagger.tag(new Tag().name(tag));
                                }
                            }

                            operation.getVendorExtensions().putAll(BaseReaderUtils.parseExtensions(apiOperation.extensions()));
                        }

                        if (operation.getConsumes() == null) {
                            for (String mediaType : apiConsumes) {
                                operation.consumes(mediaType);
                            }
                        }
                        if (operation.getProduces() == null) {
                            for (String mediaType : apiProduces) {
                                operation.produces(mediaType);
                            }
                        }

                        if (operation.getTags() == null) {
                            for (String tagString : tags.keySet()) {
                                operation.tag(tagString);
                            }
                        }
                        // Only add global @Api securities if operation doesn't already have more specific securities
                        if (operation.getSecurity() == null) {
                            for (SecurityRequirement security : securities) {
                                operation.security(security);
                            }
                        }

                        Path path = swagger.getPath(operationPath);
                        if (path == null) {
                            path = new Path();
                            swagger.path(operationPath, path);
                        }
                        path.set(httpMethod, operation);

                        readImplicitParameters(method, operation);

                        readExternalDocs(method, operation);
                    }
                }
            }
        }

        return swagger;
// END read(Class<?>-Class<?>-String-String-String-String-boolean-boolean-String[]-String[]-String[]-String[]-Map<String,Tag>-Map<String,Tag>-List<Parameter>-List<Parameter>-Set<Class<?>>-Set<Class<?>>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d6f87-9a6cf
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_d6f87_9a6cf\rev_rev_left_d6f87-rev_right_9a6cf\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: []
Right editions: [400, 406, 407, 408, 409, 410, 411]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            // We don't build models for primitive types
            return null;
        }

        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        /**
         * --Preventing parent/child hierarchy creation loops - Comment 1--
         * Creating a parent model will result in the creation of child models. Creating a child model will result in
         * the creation of a parent model, as per the second If statement following this comment.
         *
         * By checking whether a model has already been resolved (as implemented below), loops of parents creating
         * children and children creating parents can be short-circuited. This works because currently the
         * ModelConverterContextImpl will return null for a class that already been processed, but has not yet been
         * defined. This logic works in conjunction with the early immediate definition of model in the context
         * implemented later in this method (See "Preventing parent/child hierarchy creation loops - Comment 2") to
         * prevent such
         */
        Model resolvedModel = context.resolve(type.getRawClass());
        if (resolvedModel != null) {
            if (!(resolvedModel instanceof ModelImpl || resolvedModel instanceof ComposedModel)
                    || (resolvedModel instanceof ModelImpl && ((ModelImpl) resolvedModel).getName().equals(name))) {
                return resolvedModel;
            } else if (resolvedModel instanceof ComposedModel) {
                Model childModel = ((ComposedModel) resolvedModel).getChild();
                if (childModel != null && (!(childModel instanceof ModelImpl)
                        || ((ModelImpl) childModel).getName().equals(name))) {
                    return resolvedModel;
                }
            }
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

        if (!type.isContainerType()) {
            // define the model here to support self/cyclic referencing of models
            context.defineModel(name, model, type, null);
        }

        if (type.isContainerType()) {
            // We treat collections as primitive types, just need to add models for values (if any)
            context.resolve(type.getContentType());
            return null;
        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }
        final XmlAccessorType xmlAccessorTypeAnnotation = beanDesc.getClassAnnotations().get(XmlAccessorType.class);

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        final int length = altName.length();
                        for (String prefix : Arrays.asList("get", "is")) {
                            final int offset = prefix.length();
                            if (altName.startsWith(prefix) && length > offset
                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
// RIGHT //            try{
            if (propDef.getSetter() == null) {
                hasSetter = false;
            } else {
                hasSetter = true;
            }
// RIGHT //            }catch(IllegalArgumentException e){
// RIGHT //                //com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder would throw IllegalArgumentException
// RIGHT //                // if there are overloaded setters. If we only want to know whether a set method exists, suppress the exception
// RIGHT //                // is reasonable.
// RIGHT //                // More logs might be added here
// RIGHT //            	hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();

            if (member != null && !ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                if (mp != null && mp.readOnly()) {
                    isReadOnly = mp.readOnly();
                }

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = PrimitiveType.createProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = PrimitiveType.createProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else if (member.getAnnotation(JsonIdentityInfo.class) != null) {
                        property = GeneratorWrapper.processJsonIdentity(propType, context, _mapper,
                                member.getAnnotation(JsonIdentityInfo.class),
                                member.getAnnotation(JsonIdentityReference.class));
                    }
                    if (property == null) {
                        JsonUnwrapped uw = member.getAnnotation(JsonUnwrapped.class);
                        if (uw != null && uw.enabled()) {
                            handleUnwrapped(props, context.resolve(propType), uw.prefix(), uw.suffix());
                        } else {
                            property = context.resolveProperty(propType, annotations);
                        }
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }
                    if (mp != null) {
                        final AllowableValues allowableValues = AllowableValuesUtils.create(mp.allowableValues());
                        if (allowableValues != null) {
                            final Map<PropertyBuilder.PropertyId, Object> args = allowableValues.asPropertyArguments();
                            PropertyBuilder.merge(property, args);
                        }
                    }
                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);

        /**
         * --Preventing parent/child hierarchy creation loops - Comment 2--
         * Creating a parent model will result in the creation of child models, as per the first If statement following
         * this comment. Creating a child model will result in the creation of a parent model, as per the second If
         * statement following this comment.
         *
         * The current model must be defined in the context immediately. This done to help prevent repeated
         * loops where  parents create children and children create parents when a hierarchy is present. This logic
         * works in conjunction with the "early checking" performed earlier in this method
         * (See "Preventing parent/child hierarchy creation loops - Comment 1"), to prevent repeated creation loops.
         *
         *
         * As an aside, defining the current model in the context immediately also ensures that child models are
         * available for modification by resolveSubtypes, when their parents are created.
         */
        Class<?> currentType = type.getRawClass();
        context.defineModel(name, model, currentType, null);

        /**
         * This must be done after model.setProperties so that the model's set
         * of properties is available to filter from any subtypes
         **/
        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

        if (apiModel != null) {
            /**
             * Check if the @ApiModel annotation has a parent property containing a value that should not be ignored
             */
            Class<?> parentClass = apiModel.parent();
            if (parentClass != null && !parentClass.equals(Void.class) && !this.shouldIgnoreClass(parentClass)) {
                JavaType parentType = _mapper.constructType(parentClass);
                final BeanDescription parentBeanDesc = _mapper.getSerializationConfig().introspect(parentType);

                /**
                 * Retrieve all the sub-types of the parent class and ensure that the current type is one of those types
                 */
                boolean currentTypeIsParentSubType = false;
                List<NamedType> subTypes = _intr.findSubtypes(parentBeanDesc.getClassInfo());
                for (NamedType subType : subTypes) {
                    if (subType.getType().equals(currentType)) {
                        currentTypeIsParentSubType = true;
                        break;
                    }
                }

                /**
                 Retrieve the subTypes from the parent class @ApiModel annotation and ensure that the current type
                 is one of those types.
                 */
                boolean currentTypeIsParentApiModelSubType = false;
                final ApiModel parentApiModel = parentBeanDesc.getClassAnnotations().get(ApiModel.class);
                if (parentApiModel != null) {
                    Class<?>[] apiModelSubTypes = parentApiModel.subTypes();
                    for (Class<?> subType : apiModelSubTypes) {
                        if (subType.equals(currentType)) {
                            currentTypeIsParentApiModelSubType = true;
                            break;
                        }
                    }
                }

                /**
                 If the current type is a sub-type of the parent class and is listed in the subTypes property of the
                 parent class @ApiModel annotation, then do the following:
                 1. Resolve the model for the parent class. This will result in the parent model being created, and the
                 current child model being updated to be a ComposedModel referencing the parent.
                 2. Resolve and return the current child type again. This will return the new ComposedModel from the
                 context, which was created in step 1 above. Admittedly, there is a small chance that this may result
                 in a stack overflow, if the context does not correctly cache the model for the current type. However,
                 as context caching is assumed elsewhere to avoid cyclical model creation, this was deemed to be
                 sufficient.
                 */
                if (currentTypeIsParentSubType && currentTypeIsParentApiModelSubType) {
                    context.resolve(parentClass);
                    return context.resolve(currentType);
                }
            }
        }

        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_e661e-9a6cf
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3ab7f-356f2
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7e497-42582
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_cb5c4-fd2ce
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_155e1-41d67
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_efd00-2f0ef
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_c1431-b1cb6
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_c1431_b1cb6\rev_rev_left_c1431-rev_right_b1cb6\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [406, 427, 441, 442, 443, 444, 542, 543, 544]
Right editions: [294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            // We don't build models for primitive types
            return null;
        }

        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

// RIGHT //        /**
// RIGHT //         * --Preventing parent/child hierarchy creation loops - Comment 1--
// RIGHT //         * Creating a parent model will result in the creation of child models. Creating a child model will result in
// RIGHT //         * the creation of a parent model, as per the second If statement following this comment.
// RIGHT //         *
// RIGHT //         * By checking whether a model has already been resolved (as implemented below), loops of parents creating
// RIGHT //         * children and children creating parents can be short-circuited. This works because currently the
// RIGHT //         * ModelConverterContextImpl will return null for a class that already been processed, but has not yet been
// RIGHT //         * defined. This logic works in conjunction with the early immediate definition of model in the context
// RIGHT //         * implemented later in this method (See "Preventing parent/child hierarchy creation loops - Comment 2") to
// RIGHT //         * prevent such
// RIGHT //         */
// RIGHT //        Model resolvedModel = context.resolve(type.getRawClass());
// RIGHT //        if (resolvedModel != null) {
// RIGHT //            if (!(resolvedModel instanceof ModelImpl || resolvedModel instanceof ComposedModel)
// RIGHT //                    || (resolvedModel instanceof ModelImpl && ((ModelImpl) resolvedModel).getName().equals(name))) {
// RIGHT //                return resolvedModel;
// RIGHT //            } else if (resolvedModel instanceof ComposedModel) {
// RIGHT //                Model childModel = ((ComposedModel) resolvedModel).getChild();
// RIGHT //                if (childModel != null && (!(childModel instanceof ModelImpl)
// RIGHT //                        || ((ModelImpl) childModel).getName().equals(name))) {
// RIGHT //                    return resolvedModel;
// RIGHT //                }
// RIGHT //            }
// RIGHT //        }
// RIGHT //
        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

        if (!type.isContainerType()) {
            // define the model here to support self/cyclic referencing of models
            context.defineModel(name, model, type, null);
        }

        if (type.isContainerType()) {
            // We treat collections as primitive types, just need to add models for values (if any)
            context.resolve(type.getContentType());
            return null;
        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
            LOGGER.debug(rootAnnotation.toString());
            Xml xml = new Xml()
                    .name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }
        final XmlAccessorType xmlAccessorTypeAnnotation = beanDesc.getClassAnnotations().get(XmlAccessorType.class);

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        final int length = altName.length();
                        for (String prefix : Arrays.asList("get", "is")) {
                            final int offset = prefix.length();
                            if (altName.startsWith(prefix) && length > offset
                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
            try{
                if (propDef.getSetter() == null) {
                    hasSetter = false;
                } else {
                    hasSetter = true;
                }
// LEFT //            } catch (IllegalArgumentException e){
                //com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder would throw IllegalArgumentException
                // if there are overloaded setters. If we only want to know whether a set method exists, suppress the exception
                // is reasonable.
                // More logs might be added here
            	hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();
// LEFT //            Boolean allowEmptyValue = null;

            if (member != null && !ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                if (mp != null && mp.readOnly()) {
                    isReadOnly = mp.readOnly();
// LEFT //                }
// LEFT //
// LEFT //                if (mp != null && mp.allowEmptyValue()) {
// LEFT //                    allowEmptyValue = mp.allowEmptyValue();
                }

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
                    LOGGER.debug("overriding datatype from " + propType + " to " + or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = PrimitiveType.createProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = PrimitiveType.createProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else if (member.getAnnotation(JsonIdentityInfo.class) != null) {
                        property = GeneratorWrapper.processJsonIdentity(propType, context, _mapper,
                                member.getAnnotation(JsonIdentityInfo.class),
                                member.getAnnotation(JsonIdentityReference.class));
                    }
                    if (property == null) {
                        JsonUnwrapped uw = member.getAnnotation(JsonUnwrapped.class);
                        if (uw != null && uw.enabled()) {
                            handleUnwrapped(props, context.resolve(propType), uw.prefix(), uw.suffix());
                        } else {
                            property = context.resolveProperty(propType, annotations);
                        }
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));
// LEFT //                    if(allowEmptyValue != null) {
// LEFT //                        property.setAllowEmptyValue(allowEmptyValue);
// LEFT //                    }

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }
                    if (mp != null) {
                        final AllowableValues allowableValues = AllowableValuesUtils.create(mp.allowableValues());
                        if (allowableValues != null) {
                            final Map<PropertyBuilder.PropertyId, Object> args = allowableValues.asPropertyArguments();
                            PropertyBuilder.merge(property, args);
                        }
                    }
                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);

        /**
// RIGHT //         * --Preventing parent/child hierarchy creation loops - Comment 2--
// RIGHT //         * Creating a parent model will result in the creation of child models, as per the first If statement following
// RIGHT //         * this comment. Creating a child model will result in the creation of a parent model, as per the second If
// RIGHT //         * statement following this comment.
// RIGHT //         *
// RIGHT //         * The current model must be defined in the context immediately. This done to help prevent repeated
// RIGHT //         * loops where  parents create children and children create parents when a hierarchy is present. This logic
// RIGHT //         * works in conjunction with the "early checking" performed earlier in this method
// RIGHT //         * (See "Preventing parent/child hierarchy creation loops - Comment 1"), to prevent repeated creation loops.
// RIGHT //         *
// RIGHT //         *
// RIGHT //         * As an aside, defining the current model in the context immediately also ensures that child models are
// RIGHT //         * available for modification by resolveSubtypes, when their parents are created.
// RIGHT //         */
// RIGHT //        Class<?> currentType = type.getRawClass();
// RIGHT //        context.defineModel(name, model, currentType, null);
// RIGHT //
// RIGHT //        /**
         * This must be done after model.setProperties so that the model's set
         * of properties is available to filter from any subtypes
         **/
        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

// RIGHT //        if (apiModel != null) {
// RIGHT //            /**
// RIGHT //             * Check if the @ApiModel annotation has a parent property containing a value that should not be ignored
// RIGHT //             */
// RIGHT //            Class<?> parentClass = apiModel.parent();
// RIGHT //            if (parentClass != null && !parentClass.equals(Void.class) && !this.shouldIgnoreClass(parentClass)) {
// RIGHT //                JavaType parentType = _mapper.constructType(parentClass);
// RIGHT //                final BeanDescription parentBeanDesc = _mapper.getSerializationConfig().introspect(parentType);
// RIGHT //
// RIGHT //                /**
// RIGHT //                 * Retrieve all the sub-types of the parent class and ensure that the current type is one of those types
// RIGHT //                 */
// RIGHT //                boolean currentTypeIsParentSubType = false;
// RIGHT //                List<NamedType> subTypes = _intr.findSubtypes(parentBeanDesc.getClassInfo());
// RIGHT //                for (NamedType subType : subTypes) {
// RIGHT //                    if (subType.getType().equals(currentType)) {
// RIGHT //                        currentTypeIsParentSubType = true;
// RIGHT //                        break;
// RIGHT //                    }
// RIGHT //                }
// RIGHT //
// RIGHT //                /**
// RIGHT //                 Retrieve the subTypes from the parent class @ApiModel annotation and ensure that the current type
// RIGHT //                 is one of those types.
// RIGHT //                 */
// RIGHT //                boolean currentTypeIsParentApiModelSubType = false;
// RIGHT //                final ApiModel parentApiModel = parentBeanDesc.getClassAnnotations().get(ApiModel.class);
// RIGHT //                if (parentApiModel != null) {
// RIGHT //                    Class<?>[] apiModelSubTypes = parentApiModel.subTypes();
// RIGHT //                    for (Class<?> subType : apiModelSubTypes) {
// RIGHT //                        if (subType.equals(currentType)) {
// RIGHT //                            currentTypeIsParentApiModelSubType = true;
// RIGHT //                            break;
// RIGHT //                        }
// RIGHT //                    }
// RIGHT //                }
// RIGHT //
// RIGHT //                /**
// RIGHT //                 If the current type is a sub-type of the parent class and is listed in the subTypes property of the
// RIGHT //                 parent class @ApiModel annotation, then do the following:
// RIGHT //                 1. Resolve the model for the parent class. This will result in the parent model being created, and the
// RIGHT //                 current child model being updated to be a ComposedModel referencing the parent.
// RIGHT //                 2. Resolve and return the current child type again. This will return the new ComposedModel from the
// RIGHT //                 context, which was created in step 1 above. Admittedly, there is a small chance that this may result
// RIGHT //                 in a stack overflow, if the context does not correctly cache the model for the current type. However,
// RIGHT //                 as context caching is assumed elsewhere to avoid cyclical model creation, this was deemed to be
// RIGHT //                 sufficient.
// RIGHT //                 */
// RIGHT //                if (currentTypeIsParentSubType && currentTypeIsParentApiModelSubType) {
// RIGHT //                    context.resolve(parentClass);
// RIGHT //                    return context.resolve(currentType);
// RIGHT //                }
// RIGHT //            }
// RIGHT //        }
// RIGHT //
        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_bb36f-2a271
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5faab-32a73
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_38324-32901
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_38324_32901\rev_rev_left_38324-rev_right_32901\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [338, 339, 412, 462, 617, 618, 619, 620, 621, 622, 634, 635, 636, 637, 638, 639]
Right editions: [428, 442, 443, 444, 445, 446, 447, 448, 546, 547, 548]
Merged body: 
// START resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Model resolve(JavaType type, ModelConverterContext context, Iterator<ModelConverter> next) {
        if (type.isEnumType() || PrimitiveType.fromType(type) != null) {
            // We don't build models for primitive types
            return null;
        }

        final BeanDescription beanDesc = _mapper.getSerializationConfig().introspect(type);
        // Couple of possibilities for defining
        String name = _typeName(type, beanDesc);

        if ("Object".equals(name)) {
            return new ModelImpl();
        }

        /**
         * --Preventing parent/child hierarchy creation loops - Comment 1--
         * Creating a parent model will result in the creation of child models. Creating a child model will result in
         * the creation of a parent model, as per the second If statement following this comment.
         *
         * By checking whether a model has already been resolved (as implemented below), loops of parents creating
         * children and children creating parents can be short-circuited. This works because currently the
         * ModelConverterContextImpl will return null for a class that already been processed, but has not yet been
         * defined. This logic works in conjunction with the early immediate definition of model in the context
         * implemented later in this method (See "Preventing parent/child hierarchy creation loops - Comment 2") to
         * prevent such
         */
        Model resolvedModel = context.resolve(type.getRawClass());
        if (resolvedModel != null) {
            if (!(resolvedModel instanceof ModelImpl || resolvedModel instanceof ComposedModel)
                    || (resolvedModel instanceof ModelImpl && ((ModelImpl) resolvedModel).getName().equals(name))) {
                return resolvedModel;
            } else if (resolvedModel instanceof ComposedModel) {
                Model childModel = ((ComposedModel) resolvedModel).getChild();
                if (childModel != null && (!(childModel instanceof ModelImpl)
                        || ((ModelImpl) childModel).getName().equals(name))) {
                    return resolvedModel;
                }
            }
        }

        final ModelImpl model = new ModelImpl().type(ModelImpl.OBJECT).name(name)
                .description(_description(beanDesc.getClassInfo()));

        if (!type.isContainerType()) {
            // define the model here to support self/cyclic referencing of models
            context.defineModel(name, model, type, null);
        }

        if (type.isContainerType()) {
            // We treat collections as primitive types, just need to add models for values (if any)
            context.resolve(type.getContentType());
            return null;
        }
        // if XmlRootElement annotation, construct an Xml object and attach it to the model
        XmlRootElement rootAnnotation = beanDesc.getClassAnnotations().get(XmlRootElement.class);
        if (rootAnnotation != null && !"".equals(rootAnnotation.name()) && !"##default".equals(rootAnnotation.name())) {
// LEFT //            LOGGER.debug("{}", rootAnnotation);
// LEFT //            Xml xml = new Xml().name(rootAnnotation.name());
            if (rootAnnotation.namespace() != null && !"".equals(rootAnnotation.namespace()) && !"##default".equals(rootAnnotation.namespace())) {
                xml.namespace(rootAnnotation.namespace());
            }
            model.xml(xml);
        }
        final XmlAccessorType xmlAccessorTypeAnnotation = beanDesc.getClassAnnotations().get(XmlAccessorType.class);

        // see if @JsonIgnoreProperties exist
        Set<String> propertiesToIgnore = new HashSet<String>();
        JsonIgnoreProperties ignoreProperties = beanDesc.getClassAnnotations().get(JsonIgnoreProperties.class);
        if (ignoreProperties != null) {
            propertiesToIgnore.addAll(Arrays.asList(ignoreProperties.value()));
        }

        final ApiModel apiModel = beanDesc.getClassAnnotations().get(ApiModel.class);
        String disc = (apiModel == null) ? "" : apiModel.discriminator();

        if (apiModel != null && StringUtils.isNotEmpty(apiModel.reference())) {
            model.setReference(apiModel.reference());
        }

        if (disc.isEmpty()) {
            // longer method would involve AnnotationIntrospector.findTypeResolver(...) but:
            JsonTypeInfo typeInfo = beanDesc.getClassAnnotations().get(JsonTypeInfo.class);
            if (typeInfo != null) {
                disc = typeInfo.property();
            }
        }
        if (!disc.isEmpty()) {
            model.setDiscriminator(disc);
        }

        List<Property> props = new ArrayList<Property>();
        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {
            Property property = null;
            String propName = propDef.getName();
            Annotation[] annotations = null;

            // hack to avoid clobbering properties with get/is names
            // it's ugly but gets around https://github.com/swagger-api/swagger-core/issues/415
            if (propDef.getPrimaryMember() != null) {
                java.lang.reflect.Member member = propDef.getPrimaryMember().getMember();
                if (member != null) {
                    String altName = member.getName();
                    if (altName != null) {
                        final int length = altName.length();
                        for (String prefix : Arrays.asList("get", "is")) {
                            final int offset = prefix.length();
                            if (altName.startsWith(prefix) && length > offset
                                    && !Character.isUpperCase(altName.charAt(offset))) {
                                propName = altName;
                                break;
                            }
                        }
                    }
                }
            }

            PropertyMetadata md = propDef.getMetadata();

            boolean hasSetter = false, hasGetter = false;
            try{
                if (propDef.getSetter() == null) {
                    hasSetter = false;
                } else {
                    hasSetter = true;
                }
            }catch(IllegalArgumentException e){
                //com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder would throw IllegalArgumentException
                // if there are overloaded setters. If we only want to know whether a set method exists, suppress the exception
                // is reasonable.
                // More logs might be added here
// LEFT //                hasSetter = true;
            }
            if (propDef.getGetter() != null) {
                JsonProperty pd = propDef.getGetter().getAnnotation(JsonProperty.class);
                if (pd != null) {
                    hasGetter = true;
                }
            }
            Boolean isReadOnly = null;
            if (!hasSetter & hasGetter) {
                isReadOnly = Boolean.TRUE;
            } else {
                isReadOnly = Boolean.FALSE;
            }

            final AnnotatedMember member = propDef.getPrimaryMember();
// RIGHT //            Boolean allowEmptyValue = null;

            if (member != null && !ignore(member, xmlAccessorTypeAnnotation, propName, propertiesToIgnore)) {
                List<Annotation> annotationList = new ArrayList<Annotation>();
                for (Annotation a : member.annotations()) {
                    annotationList.add(a);
                }

                annotations = annotationList.toArray(new Annotation[annotationList.size()]);

                ApiModelProperty mp = member.getAnnotation(ApiModelProperty.class);

                if (mp != null && mp.readOnly()) {
                    isReadOnly = mp.readOnly();
// RIGHT //                }
// RIGHT //
// RIGHT //                if (mp != null && mp.allowEmptyValue()) {
// RIGHT //                    allowEmptyValue = mp.allowEmptyValue();
// RIGHT //                }
// RIGHT //                else {
// RIGHT //                    allowEmptyValue = null;
                }

                JavaType propType = member.getType(beanDesc.bindingsForBeanType());

                // allow override of name from annotation
                if (mp != null && !mp.name().isEmpty()) {
                    propName = mp.name();
                }

                if (mp != null && !mp.dataType().isEmpty()) {
                    String or = mp.dataType();

                    JavaType innerJavaType = null;
// LEFT //                    LOGGER.debug("overriding datatype from {} to {}", propType, or);

                    if (or.toLowerCase().startsWith("list[")) {
                        String innerType = or.substring(5, or.length() - 1);
                        ArrayProperty p = new ArrayProperty();
                        Property primitiveProperty = PrimitiveType.createProperty(innerType);
                        if (primitiveProperty != null) {
                            p.setItems(primitiveProperty);
                        } else {
                            innerJavaType = getInnerType(innerType);
                            p.setItems(context.resolveProperty(innerJavaType, annotations));
                        }
                        property = p;
                    } else if (or.toLowerCase().startsWith("map[")) {
                        int pos = or.indexOf(",");
                        if (pos > 0) {
                            String innerType = or.substring(pos + 1, or.length() - 1);
                            MapProperty p = new MapProperty();
                            Property primitiveProperty = PrimitiveType.createProperty(innerType);
                            if (primitiveProperty != null) {
                                p.setAdditionalProperties(primitiveProperty);
                            } else {
                                innerJavaType = getInnerType(innerType);
                                p.setAdditionalProperties(context.resolveProperty(innerJavaType, annotations));
                            }
                            property = p;
                        }
                    } else {
                        Property primitiveProperty = PrimitiveType.createProperty(or);
                        if (primitiveProperty != null) {
                            property = primitiveProperty;
                        } else {
                            innerJavaType = getInnerType(or);
                            property = context.resolveProperty(innerJavaType, annotations);
                        }
                    }
                    if (innerJavaType != null) {
                        context.resolve(innerJavaType);
                    }
                }

                // no property from override, construct from propType
                if (property == null) {
                    if (mp != null && StringUtils.isNotEmpty(mp.reference())) {
                        property = new RefProperty(mp.reference());
                    } else if (member.getAnnotation(JsonIdentityInfo.class) != null) {
                        property = GeneratorWrapper.processJsonIdentity(propType, context, _mapper,
                                member.getAnnotation(JsonIdentityInfo.class),
                                member.getAnnotation(JsonIdentityReference.class));
                    }
                    if (property == null) {
                        JsonUnwrapped uw = member.getAnnotation(JsonUnwrapped.class);
                        if (uw != null && uw.enabled()) {
                            handleUnwrapped(props, context.resolve(propType), uw.prefix(), uw.suffix());
                        } else {
                            property = context.resolveProperty(propType, annotations);
                        }
                    }
                }

                if (property != null) {
                    property.setName(propName);

                    if (mp != null && !mp.access().isEmpty()) {
                        property.setAccess(mp.access());
                    }

                    Boolean required = md.getRequired();
                    if (required != null) {
                        property.setRequired(required);
                    }

                    String description = _intr.findPropertyDescription(member);
                    if (description != null && !"".equals(description)) {
                        property.setDescription(description);
                    }

                    Integer index = _intr.findPropertyIndex(member);
                    if (index != null) {
                        property.setPosition(index);
                    }
                    property.setDefault(_findDefaultValue(member));
                    property.setExample(_findExampleValue(member));
                    property.setReadOnly(_findReadOnly(member));
// RIGHT //                    if(allowEmptyValue != null) {
// RIGHT //                        property.setAllowEmptyValue(allowEmptyValue);
// RIGHT //                    }

                    if (property.getReadOnly() == null) {
                        if (isReadOnly) {
                            property.setReadOnly(isReadOnly);
                        }
                    }
                    if (mp != null) {
                        final AllowableValues allowableValues = AllowableValuesUtils.create(mp.allowableValues());
                        if (allowableValues != null) {
                            final Map<PropertyBuilder.PropertyId, Object> args = allowableValues.asPropertyArguments();
                            PropertyBuilder.merge(property, args);
                        }
                    }
                    JAXBAnnotationsHelper.apply(member, property);
                    applyBeanValidatorAnnotations(property, annotations);
                    props.add(property);
                }
            }
        }

        Collections.sort(props, getPropertyComparator());

        Map<String, Property> modelProps = new LinkedHashMap<String, Property>();
        for (Property prop : props) {
            modelProps.put(prop.getName(), prop);
        }
        model.setProperties(modelProps);

        /**
         * --Preventing parent/child hierarchy creation loops - Comment 2--
         * Creating a parent model will result in the creation of child models, as per the first If statement following
         * this comment. Creating a child model will result in the creation of a parent model, as per the second If
         * statement following this comment.
         *
         * The current model must be defined in the context immediately. This done to help prevent repeated
         * loops where  parents create children and children create parents when a hierarchy is present. This logic
         * works in conjunction with the "early checking" performed earlier in this method
         * (See "Preventing parent/child hierarchy creation loops - Comment 1"), to prevent repeated creation loops.
         *
         *
         * As an aside, defining the current model in the context immediately also ensures that child models are
         * available for modification by resolveSubtypes, when their parents are created.
         */
        Class<?> currentType = type.getRawClass();
        context.defineModel(name, model, currentType, null);

        /**
         * This must be done after model.setProperties so that the model's set
         * of properties is available to filter from any subtypes
         **/
        if (!resolveSubtypes(model, beanDesc, context)) {
            model.setDiscriminator(null);
        }

        if (apiModel != null) {
            /**
             * Check if the @ApiModel annotation has a parent property containing a value that should not be ignored
             */
            Class<?> parentClass = apiModel.parent();
            if (parentClass != null && !parentClass.equals(Void.class) && !this.shouldIgnoreClass(parentClass)) {
                JavaType parentType = _mapper.constructType(parentClass);
                final BeanDescription parentBeanDesc = _mapper.getSerializationConfig().introspect(parentType);

                /**
                 * Retrieve all the sub-types of the parent class and ensure that the current type is one of those types
                 */
                boolean currentTypeIsParentSubType = false;
                List<NamedType> subTypes = _intr.findSubtypes(parentBeanDesc.getClassInfo());
// LEFT //                if (subTypes != null) {
// LEFT //                    for (NamedType subType : subTypes) {
// LEFT //                        if (subType.getType().equals(currentType)) {
// LEFT //                            currentTypeIsParentSubType = true;
// LEFT //                            break;
// LEFT //                        }
                    }
                }

                /**
                 Retrieve the subTypes from the parent class @ApiModel annotation and ensure that the current type
                 is one of those types.
                 */
                boolean currentTypeIsParentApiModelSubType = false;
                final ApiModel parentApiModel = parentBeanDesc.getClassAnnotations().get(ApiModel.class);
                if (parentApiModel != null) {
                    Class<?>[] apiModelSubTypes = parentApiModel.subTypes();
// LEFT //                    if (apiModelSubTypes != null) {
// LEFT //                        for (Class<?> subType : apiModelSubTypes) {
// LEFT //                            if (subType.equals(currentType)) {
// LEFT //                                currentTypeIsParentApiModelSubType = true;
// LEFT //                                break;
// LEFT //                            }
                        }
                    }
                }

                /**
                 If the current type is a sub-type of the parent class and is listed in the subTypes property of the
                 parent class @ApiModel annotation, then do the following:
                 1. Resolve the model for the parent class. This will result in the parent model being created, and the
                 current child model being updated to be a ComposedModel referencing the parent.
                 2. Resolve and return the current child type again. This will return the new ComposedModel from the
                 context, which was created in step 1 above. Admittedly, there is a small chance that this may result
                 in a stack overflow, if the context does not correctly cache the model for the current type. However,
                 as context caching is assumed elsewhere to avoid cyclical model creation, this was deemed to be
                 sufficient.
                 */
                if (currentTypeIsParentSubType && currentTypeIsParentApiModelSubType) {
                    context.resolve(parentClass);
                    return context.resolve(currentType);
                }
            }
        }

        return model;
// END resolve(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_76465-35a75
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_76465_35a75\rev_rev_left_76465-rev_right_35a75\modules\swagger-core\src\main\java\io\swagger\jackson\ModelResolver.java
Different Spacing: false
Left editions: [195, 196, 197, 198]
Right editions: [207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 222]
Merged body: 
// START resolveProperty(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Annotation[]-Annotation[]-Iterator<ModelConverter>-Iterator<ModelConverter>)//public Property resolveProperty(JavaType propType,
// LEFT //            ModelConverterContext context,
// LEFT //            Annotation[] annotations,
// LEFT //            Iterator<ModelConverter> next) {
// LEFT //        LOGGER.debug("resolveProperty {}", propType);

        Property property = null;
        if (propType.isContainerType()) {
            JavaType keyType = propType.getKeyType();
            JavaType valueType = propType.getContentType();
            if (keyType != null && valueType != null) {
                property = new MapProperty().additionalProperties(context.resolveProperty(valueType, new Annotation[]{}));
            } else if (valueType != null) {
// RIGHT //                Property items = context.resolveProperty(valueType, new Annotation[]{});
// RIGHT //                // If property is XmlElement annotated, then use the name provided by annotation | https://github.com/swagger-api/swagger-core/issues/2047
// RIGHT //                if(annotations != null && annotations.length > 0) {
// RIGHT //                    for (Annotation annotation : annotations) {
// RIGHT //                        if(annotation instanceof XmlElement) {
// RIGHT //                            XmlElement xmlElement =   (XmlElement)annotation;
// RIGHT //                            if(xmlElement != null && xmlElement.name() != null && !"".equals(xmlElement.name()) && !"##default".equals(xmlElement.name())) {
// RIGHT //                                Xml xml = items.getXml() != null ? items.getXml() : new Xml();
// RIGHT //                                xml.setName(xmlElement.name());
// RIGHT //                                items.setXml(xml);
// RIGHT //                            }
// RIGHT //                        }
// RIGHT //                    }
// RIGHT //                }
                ArrayProperty arrayProperty =
// RIGHT //                        new ArrayProperty().items(items);
                if (_isSetType(propType.getRawClass())) {
                    arrayProperty.setUniqueItems(true);
                }
                property = arrayProperty;
            }
        } else {
            property = PrimitiveType.createProperty(propType);
        }

        if (property == null) {
            if (propType.isEnumType()) {
                property = new StringProperty();
                _addEnumProps(propType.getRawClass(), property);
            } else if (_isOptionalType(propType)) {
                property = context.resolveProperty(propType.containedType(0), null);
            } else {
                // complex type
                Model innerModel = context.resolve(propType);
                if (innerModel instanceof ComposedModel) {
                    innerModel = ((ComposedModel) innerModel).getChild();
                }
                if (innerModel instanceof ModelImpl) {
                    ModelImpl mi = (ModelImpl) innerModel;
                    property = new RefProperty(StringUtils.isNotEmpty(mi.getReference()) ? mi.getReference() : mi.getName());
                }
            }
        }
        return property;
// END resolveProperty(JavaType-JavaType-ModelConverterContext-ModelConverterContext-Annotation[]-Annotation[]-Iterator<ModelConverter>-Iterator<ModelConverter>)//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_1a945-0fb44
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_3b7b8-2135e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_77d3d-76bb7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_19bf2-8d430
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_93ee8-1ccb3
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5ba1f-c2517
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b92f5-7944d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_46c26-5065c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5b73d-7fdaf
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5c912-aedf7
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_791d4-9aa65
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_9d821-9a446
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_5018e-e0f71
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_7a0a7-6435a
#CP_===_CP#
Type: EditSameMC
File: C:\download\ssmerge\swagger-core\revisions\rev_7a0a7_6435a\rev_rev_left_7a0a7-rev_right_6435a\modules\swagger-jaxrs\src\main\java\io\swagger\jaxrs\config\BeanConfig.java
Different Spacing: false
Left editions: [458]
Right editions: [454, 455, 456]
Merged body: 
// START classes({FormalParametersInternal})//@Override
    public Set<Class<?>> classes() {
        ConfigurationBuilder config = new ConfigurationBuilder();
        Set<String> acceptablePackages = new HashSet<String>();

        boolean allowAllPackages = false;

        if (resourcePackage != null && !"".equals(resourcePackage)) {
            String[] parts = resourcePackage.split(",");
            for (String pkg : parts) {
                if (!"".equals(pkg)) {
                    acceptablePackages.add(pkg);
                    config.addUrls(ClasspathHelper.forPackage(pkg));
                }
            }
        } else {
            allowAllPackages = true;
        }

        config.setScanners(new ResourcesScanner(), new TypeAnnotationsScanner(), new SubTypesScanner());

        final Reflections reflections = new Reflections(config);
        Set<Class<?>> classes = reflections.getTypesAnnotatedWith(javax.ws.rs.Path.class);
        Set<Class<?>> typesAnnotatedWith = reflections.getTypesAnnotatedWith(SwaggerDefinition.class);
				classes.addAll(typesAnnotatedWith);
        
        /*
         * Find concrete types annotated with @Api, but with a supertype annotated with @Path.
         * This would handle split resources where the interface has jax-rs annotations
         * and the implementing class has Swagger annotations 
         */
        for (Class<?> cls : reflections.getTypesAnnotatedWith(Api.class)) {
        	for (Class<?> intfc : TypeToken.of(cls).getTypes().interfaces().rawTypes()) {
        		Annotation ann = intfc.getAnnotation(javax.ws.rs.Path.class);
        		if (ann != null) {
        			classes.add(cls);
        			break;
        		}
					}
				}
        
        Set<Class<?>> output = new HashSet<Class<?>>();
        for (Class<?> cls : classes) {
            if (allowAllPackages) {
                output.add(cls);
            } else {
                for (String pkg : acceptablePackages) {
// RIGHT //                    // startsWith allows everything within a package
// RIGHT //                    // the dots ensures that package siblings are not considered
// RIGHT //                    if ((cls.getPackage().getName() + ".").startsWith(pkg + ".")) {
                        output.add(cls);
// LEFT //			break;
                    }
                }
            }
        }
        return output;
// END classes({FormalParametersInternal})//    }

#CP_===_CP#
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_88341-e6fde
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d5614-ab02b
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_f53c8-52ce4
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_fcc85-da00c
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_a9781-a497e
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_65e6b-f2b48
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_b5bb7-86b98
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_05fd2-c5f5f
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_2362d-44e9d
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_d9599-fe5e8
#MS_XXX_MS#
#MS_XXX_MS#
Merge scenario: rev_15b14-71ef9
#MS_XXX_MS#
